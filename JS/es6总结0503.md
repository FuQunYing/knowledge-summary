#Day07 010-69156114
## 二、正则的扩展
### 1.RegExp构造函数
  在es5中，RegExp构造函数的参数有两种情况，第一种情况是参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）
```javascript
var regex=new RegExp('xyz','i')//等价于
var regex=/xyz/i  // i ignore，忽略大小写
```
  第二种情况是，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝：
```javascript
var regex=new RegExp(/xyz/i) // 等价于
var regex=/xyz/i
```
  但是es5不允许此时使用第二个参数添加修饰符，否则就会报错：
```javascript
var regex=new RegExp(/xyz/, ''i'')//报错，从另一个RegExp构建一个RegExp时不支持修饰符
```
  es6改变了这种行为，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符吗，而且返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新的指定的修饰符：
```javascript
new RegExp(/abc/ig,'i').flags//原有正则对象的修饰符是ig，但是会被后面的i覆盖
```
### 2.字符串的正则方法
  字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。es6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法全都定义在RegExp对象上：
  - String.prototype.match调用RegExp.prototype[Symbol.match]
  - String.prototype.replace调用RegExp.prototype[Symbol.replace]
  - String.prototype.split调用RegExp.prototype[Symbol.split]
### 3.u修饰符
  es6对正则表达式添加了u修饰符，含义就是Unicode模式，用来正确处理大于\uuFFFF的Unicode字符，就是说，会正确处理四个字节的UTF-16编码。
```javascript
/^\uD83D/u.test('\uD83D\uDC2A') //false
/^\uD83D/.test('\uD83D\uDC2A') //true
//这里面，\uD83D]\uDC2A是一个四字节的UUTF-16编码，代表一个字符，但是es5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码的结果为true，加了u修饰符以后，es6就会识别其为一个字符，所以第一行的就是true
```
  加上u修饰符，就会修改下面这些正则表达式的行为：
  - 点字符
  点( . )字符在正则表达式中，含义是除了换行符以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符
```javascript
var s = '𠮷';
/^.$/.test(s) //false
/^.$/u.test(s) //true
//如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败
```
  - Unicode字符表示法
  es6新增了使用大括号表示Unicode字符，这种表示方法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解释为量词：
```javascript
/\u{61}/.test('a') //false
/\u{61}/u.test('a') //true
/\u{20BB7}/u.test('𠮷') //true
//如果不加修饰符，正则表达式无法识别\u{61}这种表示法，只会认为匹配61个连续的u
```
  - 量词
  使用u修饰符后，所有的量词都会正确识别码点大于0xFFFF的Unicode字符：
```javascript
/a{2}/.test('aa') //true
/a{2}/u.test('aa') //true
/𠮷{2}/.test('𠮷𠮷') //false
/𠮷{2}/u.test('𠮷𠮷') //true
```
  - 预定义模式
  u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符：
```javascript
/^\S$/.test('𠮷') //false
/^\S$/u.test('𠮷') //true
//\s是预定义模式，匹配所有的非空白字符，只有加了u修饰符，才能正确匹配码点大于0xFFFF的Unicode字符，利用这一点，可以写出一个正确返回字符串长度的函数
function codePointLength(text) {
  var result=text.match(/[\s\S]/gu);
  return result?result.length:0;
}
var s='𠮷𠮷';
s.length // 4
codePointLength(s) // 2
```
  - i修饰符
  有些Unicode字符的编码不同，但是字型很接近，比如\u0048和\u212A都是大写的K：
```javascript
/[a-z]/i.test('\u212A') //false,不加u就无法识别非规范的K字符
/[a-z]/iu.test('\u212A') //true
```
### 4.y修饰符
  















