# Day24
## 十五、Generator函数的异步应用
  es6之前，异步编程的方法，大概有这几种：
  - 回调函数
  - 事件监听
  - 发布/订阅
  - Promise对象
### 1.基本概念
#### 1.1 异步
  异步 ，就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其它任务，等做好了准备，再回头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件，然后程序执行其它任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。相应的，连续的执行就叫做同步，由于是连续执行，不能插入其它任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着~
#### 1.2 回调函数
  JavaScript语言对异步编程的实现，就是回调函数，所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。
  读取文件进行处理，是这个样子的：
```javascript
fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
  if (err) throw err;
  console.log(data);
});
//readFile函数的第三个参数，就是回调函数，也就是任务的第二段，等到操作系统返回了/etc.passwd这个文件以后，回调函数才会执行
```
  那问题来了，Node约定，回调函数的第一个参数，必须是错误对象err是为啥，原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了，在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当做参数，传入第二段。
#### 1.3 Promise
  回调函数本身并没有问题，它的问题出现在多个回调函数嵌套，假定读取A文件之后，再读取B文件，代码长这样：
```javascript
fs.readFile(fileA,'utf-8',function(err,data){
    fs.readFile(fileB,'utf-8',function(err,data){
        ....
    })
})
//那如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理，因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改，这种情况就是 callback hell
```
  Promise对象就是为了解决这个问题提出的，它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用，采用Promise，连续读取多个文件，写法长这样：
```javascript
var readFile=require('fs-readFile-promise')
readFile(fileA).then(function(data){
    console.log(data.toString())
}).then(function(){
    return readFile(fileB)
}).then(function(data){
    console.log(data.toString())
}).catch(function(err){
    console.log(err)
})
//这段代码，使用fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误
```
  其实Promise的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行 看的更清楚了，除此之外，没啥新东西，但是一堆的then看着也不舒服。
### 2.Generator函数
#### 2.1 协程




















