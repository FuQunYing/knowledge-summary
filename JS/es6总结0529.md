# Day24
## 十五、Generator函数的异步应用
  es6之前，异步编程的方法，大概有这几种：
  - 回调函数
  - 事件监听
  - 发布/订阅
  - Promise对象
### 1.基本概念
#### 1.1 异步
  异步 ，就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其它任务，等做好了准备，再回头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件，然后程序执行其它任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。相应的，连续的执行就叫做同步，由于是连续执行，不能插入其它任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着~
#### 1.2 回调函数
  JavaScript语言对异步编程的实现，就是回调函数，所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。
  读取文件进行处理，是这个样子的：
```javascript
fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
  if (err) throw err;
  console.log(data);
});
//readFile函数的第三个参数，就是回调函数，也就是任务的第二段，等到操作系统返回了/etc.passwd这个文件以后，回调函数才会执行
```
  那问题来了，Node约定，回调函数的第一个参数，必须是错误对象err是为啥，原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了，在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当做参数，传入第二段。
#### 1.3 Promise
  回调函数本身并没有问题，它的问题出现在多个回调函数嵌套，假定读取A文件之后，再读取B文件，代码长这样：
```javascript
fs.readFile(fileA,'utf-8',function(err,data){
    fs.readFile(fileB,'utf-8',function(err,data){
        ....
    })
})
//那如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理，因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改，这种情况就是 callback hell
```
  Promise对象就是为了解决这个问题提出的，它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用，采用Promise，连续读取多个文件，写法长这样：
```javascript
var readFile=require('fs-readFile-promise')
readFile(fileA).then(function(data){
    console.log(data.toString())
}).then(function(){
    return readFile(fileB)
}).then(function(data){
    console.log(data.toString())
}).catch(function(err){
    console.log(err)
})
//这段代码，使用fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误
```
  其实Promise的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行 看的更清楚了，除此之外，没啥新东西，但是一堆的then看着也不舒服。
### 2.Generator函数
#### 2.1 协程
  传统的编程语言是有异步编程的解决方案的，其中有一种叫做 协程 ，意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程，它的运行流程大致如下：
  - 第一步，协程A开始执行
  - 第二步，协程A执行到一半，进入暂停，执行权转移到协程B
  - 第三步，一段时间后，协程B交还执行权
  - 第四步，协程A恢复执行
    这个流程的协程A，就是异步任务，因为它分成两段或多段执行。
    举例来说，读取文件的协程写法长这样：
```javascript
function* asyncJob() {
  // 其它代码
  var f = yield readFile(fileA);
  //其它代码
}
//这段代码 的函数asyncJob是一个协程，其中的yield命令，表示执行到此处，执行权将交给其它协程，也就是说yield命令是异步两个阶段的分界线
```
  协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行，它的最大优点，就是代码的写法非常像同步操作，去掉yield命令看，差不多一模一样。
#### 2.2 协程的Generator函数实现
  Generator函数是协程在es6的实现，最大的特点就是可以交出函数的执行权就是暂停执行。
  整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器 ，异步操作需要暂停的地方，都用yield语句注明，Generator函数的执行方法如下：
```javascript
function* gen(x){
    var y=yield x+2
    return y
}
var g=gen(1);
g.next()//{value:3,done:false}
g.next()//{value:undefined,done:true}
//这段代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。
```
#### 2.3 Generator函数的数据交换和错误处理
  Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，他还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。next返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，想Generator函数体内输入数据：
```javascript
function* gen(x){
  var y = yield x + 2;
  return y;
}
var g = gen(1);
g.next()// { value: 3, done: false }
g.next(2)// { value: 2, done: true }
//这段代码中，第一个next的方法的value属性，返回表达式x+2的值3，第二个next方法带有参数2，这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收，因此，这一步的value属性，返回的就是2--变量y的值
```
  Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误：
```javascript
function* gen(x){
    try{
        var y=yield x+2
    }catch(e){
        console.log(e)
    }
    return y;
}
var g=gen(1)
g.next()
g.throw('出错了')//出错了，Generator函数体外，使用指针对象throw方法抛出的错误，可以被函数体内的try catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的
```
#### 2.4 异步任务的封装
  使用Generator函数，执行一个真实的异步任务：
```javascript
var fetch=require('node-fetch')
function* gen(){
    var uri='suibian.url'
    var result=yield fetch(url)
    console.log(result.bio)
}
//这段代码中，Generator函数封装了异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息，就像前面说过的，这段代码非常像同步操作，除了加上yield命令

//执行这段代码的方法如下：
var g=gen()
var result=g.next()
result.value.then(function(data){
    return data.json()
}).then(function(data){
    g.next()
})
//首先执行Generator函数，获取遍历器对象，然后使用next方法，执行异步任务的第一阶段，由于Fetch模块的是一个Promise对象，因此要用then方法调用下一个next方法
```




















