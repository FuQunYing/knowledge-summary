# Day25
### 3.Thunk 函数
  Thunk函数是自动执行Generator函数 的一种方法
#### 3.1 参数的求值策略
  编程语言起初关注焦点在于 求值策略，即函数的参数到底应该何时求值：
```javascript
var x=1;
function fun(m){
    return m*2
}
fun(x+5)
//在这里，先定义了函数fun，然后向它传入表达式x+5，那么问题来了，这个表达式应该何时求值
```
  一种意见是传值调用，就是在进入函数体之前，就计算x+5的值，再将这个值传入函数f,相当于直接传6进去；还有就是 传名调用，就是直接将x+5传入进去，只在调用的时候求值。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失，比如：
```javascript
function f(a, b){
  return b;
}
f(3 * x * x - 2 * x - 1, x);//第一个参数是一个复杂的表达式，但是函数体内根本没用到，对于这个参数值，实际上是不必要的
```
#### 3.2 Thunk函数的含义
  编译器的 传名调用 实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做Thunk函数：
```javascript
function f(m){
    return m*2
}
f(x+5)
//相当于
var thunk=function(){
    return x+5
}
function f(thunk){
    return thunk()*2
}
//函数f的参数x+—5被一个函数替换了，凡是用到原参数的地方，对Thunk函数求值即可
```
  这就是Thunk函数的定义，它是 传名调用的一种实现策略，用来替换某个表达式
#### 3.3 JavaScript语言的Thunk函数
  JavaScript语言是传值调用，它的Thunk函数含义有所不同，在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数：
```javascript
//正常版本的readFile（多参数）
fs.readFile(fileName,callback)
//Thunk版本的readFile（单参数）
var Thunk=function(fileName){
    return function(callback){
        return fs.readFile(fileName,callback)
    }
}
var readFileThunk=Thunk(fileName)
readFileThunk(callback)
//fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数，经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数，这个单参数版本，就叫做Thunk函数
```
  任何函数，只要参数有回调函数，就能写成Thunk函数的形式，下面是一个Thunk函数转换器：
```javascript
//es5版本
var Thunk=function(fn){
    return function(){
        var args=Array.prototype.slice.call(arguments)
        return function(callback){
            args.push(callback)
            return fn.apply(this,args)
        }
    }
}
//es6版本
const Thunk=function(fn){
    return function(...args){
        return function(callback){
            return fn.call(this,...args,callback)
        }
    }
}
//使用上面的转换器，生成fs.readFile的Thunk函数
var readFileThunk=Thunk(fs.readFile)
readFile(fileA)(callback)
```
  一个完整的栗子：
```javascript
function f(a,cb){
    cb(a)
}
const ft=Thunk(f)
ft(1)(console.log)//1
```
#### 3.4 Thunkify模块
  生产环境的转换器，建议使用Thunkify模块。
  首先是安装：npm i thunkify
  使用方式如下：
```javascript
var thunkify=require('thunkify')
var fs=require('fs')
var read=thunkify(fs.readFile)
read('package.json')(function(err,str){....})
```
  Thunkify的源码与上一节那个简单的转换器非常像：
```javascript
function thunkify(fn){
    return function(){
        var args=new Array(arguments.length)
        var ctx=this;
        for (var i=0;i<arr.length;i++){
            args[i]=arguments[i]
        }
        return function(done){
            var called;
            args.push(function(){
                if(called) return;
                called=true;
                done.apply(null,arguments)
            })
            try{
                fn.apply(ctx,args)
            }catch(err){
                done(err)
            }
        }
    }
}
```
  它的源码主要多了一个检查机制，变量called确保回调函数只运行一次，这样的设计与下面的Generator函数相关，看个栗子：
```javascript
function f(a,b,callback){
    var sum=a+b
    callback(sum)
    callback(num)
}
var ft=thunkify(f)
var print=console.log.bind(console)
ft(1,2)(print)//3,由于thunkify只允许回调函数执行一次，所以只输出一行结果
```
#### 3.5 Generator函数的流程管理
  Thunk函数可以用于Generator函数的自动流程管理。
  Generator函数可以自动执行：
```javascript
function* gen(){...}
var g=gen()
var res=g.next()
while(!res.reault){
    console.log(res.result)
    res=g.next()
}
```
  上面的代码Generator函数gen会自动执行完所有步骤，但是这不适合异步操作，如果必须保证前一步执行完才能执行后一步，上面的自动执行就不可行，这时，Thunk函数就可以用了，以读取文件为例，下面的Generator函数封装了两个异步操作：
```javascript
var fs=require('fs')
var thunkify=require('thunkify')
var readFileThunk=thunkify(fs.readFile)
var gen=function* (){
    var r1=yield readFileThunk('/etc/fatab')
    console.log(r1.toString())
    var r2=yield readFileThunk('/etc/shells')
    console.log(r2.toString())
}
//这段代码中，yield命令用于将程序的执行权移除Generator函数，那么就需要一种方法，将执行权再交给Generator函数
```
  这种方法就是Thunk函数，因为它可以在回调函数里将执行权交给Generator函数，先看一下如何手动执行上面这个Generator函数：
```javascript
var g=gen()
var r1=g.next()
r1.value(function(err,data){
    if(err) throw err;
    var r2=g.next(data)
    r2.value(function(err,data){
        if(err) throw err
        g.next(data)
    })
})
//变量g是Generator函数的内部指针，表示目前执行到哪一步，next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。
```
  Generator函数的执行过程，其实是将偶同一个回调函数，反复传入next方法的value属性。那就可以用递归来自动完成这个过程
#### 3.6 Thunk函数的自动流程
  Thunk函数最大的作用就是在于可以自动执行Generator函数，一个基于Thunk函数的Generator执行器：
```javascript
function run(fn) {
    var gen=fn();
    function next(err,data){
        var result=gen.next(data);
        if (result.done) return
        result.value(next)
    }
    next()
}
function* g(){.....}
run(g)
//run函数，就是一个Generator函数的自动执行器，内部的next函数就是Thunk的回调函数，next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出

//有了这个执行器，执行Generator函数就方便多了，不管内部有多少个异步操作，直接把Generator函数传入run函数就行，前提是每个异步操作，都要是Thunk函数，也就是说跟在yield命令后面的必须是Thunk函数：
var g=function* (){
    var f1=yield readFileThunk('fileA')
    var f2=yield readFileThunk('fileB')
    ....
    var fn=yield readFileThunk('fileN')
}
run(g)
//函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成，这样一来，异步操作不仅可以写的像同步操作，而且一行代码就可以执行
```
  Thunk函数并不是Generator函数自动执行的唯一方案，因为自动执行的关键是必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权，回调函数可以做到这一点，Promise对象也可以做到这一点、
### 4.co模块
#### 4.1 基本用法
  co模块用于Generator函数的自动执行，下面是一个Generator函数，用于依次读取两个文件：
```javascript
var gen=function* (){
    var f1=yield readFile('/etc/fstab')
    var f2=yield readFile('/etc/shells')
    console.log(f1.toString())
    console.log(f2.toString())
}
//有co模块，可以不用再编写Generator函数的执行器
var co=require('co')
co(gen)//Generator函数只要传入co函数，就会自动执行
//co函数返回一个Promise对象，因此可以用then方法添加回调函数：
co(gen).then(function(){
    console.log('Generator 函数执行完成')//等到Generator函数执行结束，就会输出一行提示
})
```
#### 4.2 co模块的原理
  Generator就是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。
  两种方法可以做到这一点：
  - 回调函数，将异步操作包装成Thunk函数，在回调函数里面交回执行权
  - Promise对象，将异步操作包装成Promise对象，用then方法交回执行权
  co模块其实就是将两种自动执行器，包装成一个模块，使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象，如果数组或对象的成员，全部都是Promise对象，也可以使用co
#### 4.3 基于Promise对象的自动执行
  沿用上面的例子，首先把fs模块的readFile方法包装成一个Promise对象：
```javascript
var fs=require('fs')
var readFile=function(fileName){
    return new Promise(function(resolve,reject){
        fs.readFile(fileName,function(error,data){
            if(error) return reject(error)
            resolve(data)
        })
    })
}
var gen=function*(){
    var f1=yield readFile('/etc/fstab')
    var f2=yield readFile('/etc/shells')
    console.log(f1.toString())
    console.log(f2.toString())
}
//然后手动执行上面的Generator函数
var g=gen()
g.next().value.then(function(data){
    g.next(data).value.then(function(data){
        g.next(data)
    })
})
```
  手动执行其实就是用then方法，层层添加回调函数，基于此，可以写一个自动执行器：
```javascript
function run(gen){
    var g=gen()
    function next(data){
        var result = g.next(data)
        if(result.done) return result.value
        result.value.then(function(data){
            next(data)
        })
    }
    next()
}
run(gen)//只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行
```
#### 4.4 co模块的源码
  co就是上面那个自动执行器的扩展，源码有几十行，简单毛线。
  首先，co函数接受Generator函数作为参数，返回一个Promise对象：
```javascript
function co(gen){
    var ctx=this;
    return new Promise(function(resolve,reject){
        if (typeof gen === 'function') gen = gen.call(ctx)
        if(!gen || typeof gen.next !== 'function') return resolve(gen)
    })
}
```
  接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数，这主要是为了能够捕捉抛出的错误：
```javascript
function co(gen){
    var ctx=this;
    return new Promise(function(resolve,reject){
        if (typeof gen === 'function') gen=gen.call(ctx)
        if(!gen || typeof gen.next !=='function') return resolve(gen)
        onFulfilled()
        function onFulfilled(res){
            var ret;
            try{
                ret=gen.next(res)
            }catch(e){
                return reject(e)
            }
            next(ret)
        }
    })
}
```
  最后就是next函数，它会反复调用自身：
```javascript
function next(ret){
    if(ret.done) return resolve(ret.value)
    var value=toPromise.call(ctx,ret.value)
    if(value && isPromise(value)) return value.then(onFulfilled,onRejected)
    return onRejected(
      new TypeError('You may only yield a function, promise, generator, array, or object, but the following object was passed: "'+ String(ret.value)+ '"')
    )
}
```
  上面代码中，next函数的内部代码，一共只有四行命令，第一行检查当前是否为Generator函数的最后一步，如果是就返回；第二行确保每一步的返回值，都是Promise对象；第三行使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数；第四行，在参数不符合要求的情况下（参数非Thunk函数和Promise对象），将Promise对象的状态改为rejected，从而终止运行。
#### 4.5 处理并发的异步操作
  co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面
```javascript
//数组的写法:
co(function* (){
    var res=yield[
        Promise.resolve(1),
        Promise.resolve(2)
    ]
    console.log(res)
}).cactch(onerror)
//对象的写法
co(function* (){
    var res=yield{
        1:Promise.resolve(1),
        2:Promise.resolve(2)
    }
    console.log(res)
}).catch(onerror)
```
  另一个栗子：
```javascript
co(function* (){
    var values=[n1,n2,n3]
    yield values.map(suibianAsync)
})
function* suibianAsync(x){
    //....
    return y
}
//这里允许并发三个suibianAsync异步操作，等到它们全部完成，才会进行下一步
```
#### 4.6 实例：Stream
  Node提供Stream面膜是读写数据，特点是一次只处理数据的一部分，数据分成一块一块依次处理，就好像 数据流 一样，这对于处理大规模数据非常有利，Stream模式使用EventEmitterAPI，会释放三个事件：
  - data事件：下一块数据块已经准备好了
  - end事件：整个  数据流  处理  完了
  - error事件：发生错误
  使用Promise.race()函数，可以判断这三个事件之中哪个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理，从而，可以通过一个while循环，完成所有的数据读取：
```javascript
const co=require('co')
const fs=require('fs')
const stream=fs.createReadStream('./les_miserables.txt')
let valjeanCount=0
co(function*(){
    while(true){
        const res=yield Promise.race([
            new Promsie(resolve => stream.once('data',resolve))
            new Promise(resolve => stream.once('end',resolve))
            new Promsie((resolve,reject)=>stream.once('error',reject))
        ])
        if(!res) break;
        stream.removeAllListeners('data')
        stream.removeAllListeners('end')
        stream.removeAllListeners('error')
        valjeanCount += (res.toString().match(/valjean/ig) || []).length
    }
    console.log('count:',valjeanCount)//count:1120
})
 //这里采用stream模式读取 悲惨世界 的文本文件，对于每个数据都使用stream.once方法，在data、end、error三个事件上添加一次性回调函数，变量res只有在data事件发生时才有值，然后累加每个数据块之中valjean这个词出现的次数
```






















