# Day26
## 十七、async函数
### 1.含义
  async函数就是Generator函数的语法糖，之前有一个依次读取两个文件的Generator函数：
```javascript
const fs = require('fs');
const readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if (error) return reject(error);
      resolve(data);
    });
  });
};
const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```
  写成async函数，就是这样：
```javascript
const asyncReadFile=async function(){
    const f1=await readFile('/etc/fstab')
    const f2=await readFile('/etc/shells')
    console.log(f1.toString())
    console.log(f2.toString())
}
```
  async 函数就是将Generator函数的星号 替换成async，将 yield替换成await。async函数对Generator函数的改进，体现在四点：
  - 内置执行器
```javascript
  //Generator函数的执行必须依靠执行器，所以才有了co模块，而async函数自带执行器，也就是说,async函数的执行，与普通函数一模一样，只要一行
  asyncReadFIle()
  //这里调用了asyncReadFile函数，然后它就会自动执行，输出最后的结果，这完全不像Generator函数，需要调用next方法，或者用co模块，才能真正执行，得到最后的结果
```
  - 更好的语义
    async和await，比起星号和yield，语义要更清楚，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
  - 更广的适用性
    co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值， 但这时等同于同步操作）
  - 返回值是Promise
    async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了，这样可以用then方法指定下一步的操作
  async函数 完全可以看做多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。
### 2.基本用法
  async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体后面的语句。
  举个栗子：
```javascript
async function getStockPriceByName(name){
    const symbol=await getStockSymbol(name)
    const stockPrice=await getStockPrice(symbol)
    return stockPrice
}
getStockPriceByName('goog').then(function (result){
    console.log(result)
})
//这是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作，调用该函数时，会立即返回一个Promise对象
```
  还有一个栗子，指定多少毫秒以后输出一个值：
```javascript
function timeout(ms){
    return new Promise((resolve)=>{
        setTimeout(resolve,ms)
    })
}
async function asyncPrint(value,ms){
    await timeout(ms);
    console.log(value)
}
asyncPrint('luelue',50)
```
  async 函数有多种使用形式：
```javascript
//函数声明
async function foo()
//函数表达式
const foo=async function(){}
//对象的方法
let obj={async foo(){}}
obj.foo().thne(...)
//Class的方法
class Storage{
    constructor(){
        this.cachePromise=caches.open('avatars')
    }
    async getAvatar(name){
        const cache=await this.cachePromise
        return cache.match(`/avatars/${name}.jpg`)
    }
}
const storage=new Storage();
storage.getAvatar('jake').then(....)
//箭头函数
const foo=async()=>{}
```
### 3.语法
#### 3.1 返回Promise对象
  async函数返回一个Promise对象。async函数内部return语句返回的值，会成为then方法回调函数的参数：
```javascript
async function f(){
    return 'hello world'
}
f().then(v => console.log(v))//'hello world'，函数f内部return命令返回的值，会被then方法回调函数接收到
```
  async函数内部抛出错误，会导致返回的Promise对象变为reject状态，抛出的错误对象会被catch方法回调函数接收到：
```javascript
async funcrtion f(){
    throw nnew Error('出错了')
}
f().then(
	v => console.log(v)
	e => console.log(e)
)//Error，出错了
```
#### 3.2 Promise对象的状态变化
  async函数返回的Promise对象，必须等到内部所有await命令后面的Promise对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误，也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。
  举个栗子：
```javascript
async function getTitle(url){
    let response=await fetch(url);
    let html=await response.text()
    return html.match(/<title>([\s\s]+)<\/title>/i)[i]
}
getTitle('https://suibian.url').then(console.log)// suibian
//函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题，只有这三个操作全部完成，才会then方法里面的consol.log
```
#### 3.3 await命令
  正常情况下，await命令后面是一个Promise，如果不是，会被转成一个立即resolve的Promise对象：
```javascript
async function f(){
    return await 123
}
f().then(v => console.log(v))//123
```
  await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到：
```javascript
async function f(){
    await Promise.reject('出错了')
}
f().then(v => console.log(v))
	.catch(e => console.log(e))//出错了，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数，这里如果在await前面加上return，效果是一样的
```
  只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行：
```javascript
async function f(){
    await Promise.reject('出错了')
    await Promise.resolve('hello world')//不会执行，因为第一个await语句状态变成了reject
}
```
  有时会希望即使前一个异步操作失败，也不要中断后面的异步操作，这时可以将第一个await放在try catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行：
```javascript
async function f(){
    try{
        await Promise.reject('出错了')
    }catch(e){}
    return await Promise.resolve('hello world')
}
f().then(v => console.log(v))//hello world
```
  另一种方法是await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误：
```javascript
async function f(){
    await Promise.reject('出错了').catch(e => console.log(e))
    return await Promise.resole('hello world')
}
f().then(v => console.log(v))// 出错了  hello world
```
#### 3.4 错误处理
  如果reject后面的异步操作出错，那么等同于async函数返回的Promise对象被reject：
```javascript
async function f(){
    await new Promise(function(resolve,reject){
        throw new Error('出错啦')
    })
}
f().then(v => console.log(v)).catch(e => console.log(e))//Error： 出错啦
//async函数f执行后，await后面的Promise对象就会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。
```
  防止出错的方法，也是将其放在try catch代码块之中：
```javascript
async function f(){
    try{
        await new Promise(function (resolve,reject){
            throw new Error('出错啦')
        })
    }catch(e){}
    return await('hello world')
}
```
  如果有多个await命令，可以统一放在 try catch结构中
```javascript
async function main(){
    try{
        const val1=await firstStep()
        const val2=await seconedStep(val1)
        cosnt val3=await thirdStep(val1,val2)
        console.log('最后：',val3)
    }
    catch(err){console.log(err)}
}
```
  使用try catch结构，实现多次重复尝试：
```javascript
const superagent=require('superagent')
const NUM_RETRIES=2
async function test(){
    let i;
    for(i=0;i<NUM_RETRIES;i++){
        try{
            await superagent.get('suibian.url');
            break;
        }catch(err){}
    }
    console.log(i)//2
}
test()
//如果await成功，就会使用break语句退出循环，如果失败，会被catch语句捕捉，然后进入下一轮循环
```
#### 3.5 使用 ご注意
  第一点，前面说过的，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try catch代码中:
```javascript
async function fun(){
    try{
        await somethingThatReturnsAPromise()
    }catch(err){
        console.log(err)
    }
}
//另一种写法
async function fun(){
    await somethingThatReturnsAPromise()
    .catch(function(err){
        console.log(err)
    })
}
```
  第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发：
```javascript
let foo=await getFoo()
let bar=await getBar()
//getFoo和getBar是两个独立的操作，被写成继发关系，这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发

//写法一
let [foo,bar]=await Promise.all([getFoo(),getBar()])
//写法二
let fooPromise=getFoo()
let barPromise=getBar()
let foo=await fooPromise;
let bar=await barPromise
//getFoo和getBar都是同时触发的，这样就会缩短程序的执行时间
```
  第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错：
```javascript
async function dbFuc(db){
    let docs=[{},{},{}]
    //报错
    docs.forEach(function(doc){
        await db.post(doc)
    })
}
//因为await用在普通函数之中，所以报错了吗，但是如果将forEach方法的参数改成async函数，也有问题
function dbFuc(db){//这里不需要async
     let docs=[{},{},{}]
     //可能得到错误结果
     docs.forEach(async function(doc){
         await db.post(doc)
     })
}
//上面的代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环
async function dnFuc(db){
    let docs=[{},{},{}]
    for(let doc of docs){
        await db.post(doc)
    }
}
```
  如果确实希望多个请求并发执行，可以使用Promise.all方法，当三个请求都会resolved时，下面两种写法效果相同：
```javascript
async function dbFuc(db){
    let docs=[{},{},{}]
    let Promises=docs.map((doc)=> db.post(doc))
    let results=await Promise.all(promises)
    console.log(results)
}
//或者使用下面的写法
async function dbFuc(db){
    let docs=[{},{},{}]
    let promises=docs.map((doc)=>db.post(doc))
    let results=[];
    for(let promise of promises){
        results.push(await promise)
    }
    console.log(results)
}
```
  目前@std/esm模块加载器支持顶层await，即await命令可以不放在async函数里面，直接使用：
```javascript
//async函数的写法
const start=async()=>{
    const res=await fetch('xxxx.com')
    return res.text();
}
start().then(console.log)
//顶层await的写法,脚本必须使用@std/esm加载器才会生效
const res=await fetch('xxxx.com')
console.log(await res.text())
```
### 4.async函数的实现原理
  async函数的实现原理，就是将Generator函数和自动执行器，包装在一个函数里：
```javascript
async function fun(args){....}
//等同于
function fun(args){
    return spawn(function*(){....})
}
//所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器
```
  spawn函数实现：
```javascript
function spawn(genF){
    return new Promise(function(resole,reject){
        const gen=genF()
        functionstep(nextF){
            let next;
            try{
                next=nextF()
            }catch(e){
                return reject(e)
            }
            if(next.done){
                return resolve(next.value)
            }
            Promise.resolve(next.value).then(function(v){
                step(function(){return gen.next(v)})
            },function(e){
                step(function(){return gen.throw(e)})
            })
        }
        step(function(){return gen.next(undefined)})
    })
}
```
### 5.与其它异步处理方法的比较
  通过下面这个例子，看一下async函数与Promise、Generator函数的比较
  假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个，如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画返回值。
  首先是Promise的写法：
```javascript
function chainAnimationsPromise(elem,animations){
    //变量ret用来保存上一个动画的返回值
    let ret=null;
    //新建一个空的Promise
    let p=Promise.resolve()
    //使用then方法，添加所有动画
    for(let anim of animations){
        p=p.then(functiion(val){
            ret=val;
            return anim(elem)
        })
    }
    //返回一个部署了错误捕捉机制的Promise
    return p.catch(function(e){
        //忽略错误，继续执行
    }).then(function(){
        return ret
    })
}
//虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API，操作本身额语义反而不容易看出来
```
  然后是Generator函数的写法：
```javascript
function chainAnimationsGenerator(elem,animations){
    return spawn(function* (){
        let ret=null;
        try{
            for(let anim of animations){
                ret=yield anim(elem)
            }
        }catch(e){//忽略错误，继续执行}
        return ret;
    })
}
//这段代码使用Generator函数遍历了每个动画，语义化比Promise写法更清晰，用户定义的操作，全部都出现在spawn函数的内部，这个写法的问题在于，必须有一个任务运行期，自动执行Generator函数，上面代码spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise
```
  最后是一个async函数的写法：
```javascript
async function chainAniamtionsAsync(elem,animations){
    let ret=null;
    try{
        for(let anim of animations){
            ret=await anim(elem)
        }
    }catch(e){//忽略错误，继续执行}
    return ret
}
//Async函数的实现最简洁有没有，最符合语义，几乎没有语义不相关的代码，它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少，如果使用Generator写法，自动执行器需要用户自己提供
```
























