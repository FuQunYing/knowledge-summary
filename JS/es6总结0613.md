# Day34
## 二十六、最新提案
### 1.do表达式
  本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值：
```json
{
    let t=f()
    t=t*t+1
}
//在这里，块级作用域将两个语句封装在一起，但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。
```
  现在有一个提案，使得块级作用语言可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值：
```javascript
let x=do{
    let t=f()
    t*t+1
}
//变量x会得到整个块级作用域的返回值(t*t+1)
```
  do表达式的逻辑非常简单：封装的是什么，就会返回什么：
```javascript
//等同于<表达式>
do {<表达式>}
//等同于<语句>
do{<语句>}
```
  do表达式的好处是可以封装多个语句，让程序更加模块化：
```javascript
let x=do{
    if(foo()){f()}
    else if (bar()){g()}
    else {h()}
}
//这里代码的本质就是根据函数foo的执行结果，调用不同的函数，将返回结果赋给变量x，使用do表达式，就将这个操作的意图表达的非常简洁清晰。而且，do块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝
```
  do表达式在JSX语法中非常好用：
```javascript
return (
	<nav>
		<Home/>
		{
            do {
                if(loggedIn){
                    <LogoutButton/>
                }else{
                    LoginButton/>
                }
            }
		}
	</nav>
)
//如果不使用do表达式，就只能用三元运算符。那如果判断逻辑复杂的话，代码就会变得很不易读。
```
### 2.throw表达式
  JavaScript语法规定throw是一个命令，用来抛出错误，不能用于表达式之中：
```javascript
//报错
consolee.log(throw new Error())//console.log参数必须是一个表达式，如果是一个throw语句就会报错
```
  现在有一个提案，允许throw用于表达式：
```javascript
//参数的默认值
function save(filename=throw new TypeError('Argument requirred')){}
//箭头函数的返回值
lint(ast,{
    with: () => throw new Error('避免使用 with 语句')
})
//条件表达式
function getEncoder(encoding){
    const encoder=encoding ==='utf8'?
      new UTF*Encoder():
      encoding==='utf16le'?
        new UTF16Encoder(false):
        encodiing ==='utf16be'?
          new UTF16Encoder(true):
          throw new Error('不支持的编码')
}
// 逻辑表达式
class Product {
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value || throw new Error("Invalid value");
  }
}
//上面代码中，throw都出现在表达式里面
```
  语法上，throw表达式里面的throw不再是一个命令，而是一个运算符。为了避免与throw命令混淆，规定throw出现在行首，一律解释为throw语句，而不是throw表达式。
### 3.链式判断运算符
  编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在，比如，要读取message.body.user.firstName，安全的写法是写成这样：
```javascript
const firstName=(message && message.body && message.body.user && message.body.user.firstName) || 'default';
```
  这样的层层判断非常麻烦，因此现在有一个提案，引入了链判断运算符?.，简化上面的写法：
```javascript
const firstName = message?.body?.user?.firstName || 'default';
```
  上面代码有三个?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。
  链判断运算符有三种写法：
  - obj?.prop // 读取对象属性
  - obj?.[expr] // 同上
  - func?.(...args) // 函数或对象方法的调用
  判断是否存在：
```javascript
iterator.return?.()//iterator.return如果有定义，就会调用该方法，否则直接返回undefined。
```
  一袋栗子：
```javascript
a?.b
//等同于
a==null?undefined:a.b

a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
```
  使用这个运算符，有几个注意点：
  - 短路机制
```javascript
a?.[++x]
//等同于
a==null?undefined:a[++x]//如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值
```
  - delete运算符
```javascript
delete a?.b
//等同于
a==null?undefined:delete a.b//如果a是undefined或null，会直接返回undefined，而不会进行delete运算。
```
  - 报错场合
```javascript
//以下写法禁止，会报错
// 构造函数判断
new a?.()

// 运算符右侧是模板字符串
a?.`{b}`

// 链判断运算符前后有构造函数或模板字符串
new a?.b()
a?.b`{c}`

// 链运算符用于赋值运算符左侧
a?.b = c
```
  - 右侧不得为十进制数值
```txt
	为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。
```
### 4.直接输入 U+2028 和 U+2029
  JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\u4e2d，两者是等价的。
```javascript
'中' === '\u4e2d' // true
```
  但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。
  - U+005C：反斜杠（reverse solidus)
  - U+000D：回车（carriage return）
  - U+2028：行分隔符（line separator）
  - U+2029：段分隔符（paragraph separator）
  - U+000A：换行符（line feed）
  举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\或者\u005c。
  这个规定本身没有问题，麻烦在于JSON格式允许字符串里面直接使用U+2028（行分隔符）和U+2029（段分隔符），这样一来，服务器输出的JSON被JSON.parse解析，就有可能直接报错。
  JSON格式已经冻结（RFC7159），没法修改了。为了消除这个报错，现在有一个提案，允许JavaScript字符串直接输入U+2028（行分隔符）和U+2029（段分隔符）
```javascript
const PS=eval("'\u2029")//根据提案，这个代码不会报错。
```
  注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为JSON本身就不允许直接包含正则表达式。



















