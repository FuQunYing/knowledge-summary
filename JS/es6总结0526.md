# Day23
### 4.Generator.prototype.throw()
  Geneartor函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获:
```javascript
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};
var i = g();
i.next();
try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
//这段代码中，遍历器对象i连续抛出两个错误，第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获
```
  throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例：
```javascript
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log(e);
  }
};
var i = g();
i.next();
i.throw(new Error('出错了！'));
// Error: 出错了！(…),注意不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获

var g = function* () {
  while (true) {
    try {
      yield;
    } catch (e) {
      if (e != 'a') throw e;
      console.log('内部捕获', e);
    }
  }
};
var i = g();
i.next();
try {
  throw new Error('a');
  throw new Error('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 外部捕获 [Error: a]，之所以捕获a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面的剩余的语句了
```
  如果Generator函数内部没有部署try catch代码块，那么throw方法抛出的错误，将被外部try catch代码块捕获：
```javascript
var g=function* (){
    while(true){
        yield;
        console.log('内部错误',e)
    }
}
var i=g()
i.next()
try{
    i.throw('a')
    i.throw('b')
} catch(e){
    console.log('外部捕获',e)
}
//外部 捕获 a，Generator函数g内部没有部署try catch代码块，所以抛出的错误直接被外部catch代码块捕获
```
  如果Generator函数内部和外部，都没有部署try catch 代码块，那么程序将报错，直接中断执行：
```javascript
var gen=function* gen(){
    yield console.log('hello')
    yield console.log('world')
}
var g=gen()
g.next();//hello
g.throw()//Uncaught undefined
//g.throw抛出错误以后，没有任何try catch代码块可以捕获这个错误，导致程序报错，中断执行
```
  throw 方法抛出的错误要被内部捕获，前提是必须执行过一次next方法：
```javascript
function* gen(){
    try{
        yield 1;
    }catch(e){
        console.log('内部捕获')
    }
}
var g=gen()
g.throw(1)//Uncaught 1
//g.throw(1)执行时，next方法一次都没有执行过，这时抛出的错误不会被内部捕获而是直接在外部抛出，导致程序出错。这种行为其实比较好理解，因为第一次执行next方法，等同于启动执行Generator函数的内部代码，否则Generator函数还没有开始执行，这时候throw方法抛出错误只可能抛出在函数外部
```
  throw 方法被捕获以后，会附带执行下一条yield表达式，也就是说会附带执行一次next方法：
```javascript
var gen=function* gen(){
    try{
        yield console.log('a')
    }catch(e){....}
    yield console.log('b')
    yield console.log('c')
}
vvar g=gen()
g.next()//a
g.throw()//b
g.next()//c
//g.throw方法被捕获以后，会自动执行一次next方法，所以会打印b。另外，只要Generator函数内部 部署了try catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
```
  另外，throw命令与g.throw方法是无关的，两个互不影响：
```javascript
var gen=function* gen(){
    yield console.log('hello');
    yield console.log('world')
}
var g=gen();
g.next()
try{
    throw new Error();
}catch(e){
    g.next()
}
//hello    world
//throw命令抛出的错误不会影响到遍历器的状态，所以两个执行next方法，都进行了正确的操作。
```
  这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。
  Generator函数体外抛出的错误，可以在函数天内捕获，反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获：
```javascript
function* foo(){
    var x=yield 3;
    var y=x.toUpperCase();
    yield y
}
var it=foo()
it.next()//{value:3,done:false}
try{
	it.next(42)
}ctach(err){
    console.log(err)
}
//第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获
```
  一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了，如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了：
```javascript
function* g(){
    yield 1;;
    console.log('抛出一个异常');
    throw new Error('generator broke')
    yield 2;
    yield 3;
}
function log(generator){
    var v;
    console.log('开始 generator')
    try {
        v=generator.next();
        console.log('第一个运行next方法',v)
    }catch(err){
        console.log('捕捉错误',v)
    }
    try{
        v=generator.next();
        console.log('第二次运行next方法',v)
    }catch((err)){
        console.log('捕捉错误',v)
    }
    try{
        v=generator.next();
        console.log('第三次运行next方法',v)
    }ctach(err){
        console.log('捕捉粗偶',v)
    }
    console.log('结束')
}
log(g())
//开始 generator
//第一次运行next方法 {value:1,done:false}
//抛出一个异常
//捕捉错误 {value:1,done:false}
//第三次运行next方法 {value:undefined,done:true}
//结束
//这段代码总共运行了三次next方法，第二次运行的时候抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了
```
### 5.Generator.prototype.return()
  Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数：
```javascript
function* gen(){
    yield 1;
    yield 2;
    yield 3
}
var g=gen()
g.next()//{value:1,done:false}
g.return()//{valule:'foo',done:true}
g.next()//{value:undefined,done:true}
//遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true
```
  如果return方法调用时，不用提供参数，则返回值的value属性为undefined：
```javascript
function* gen(){
    yield 1;
    yield 2;
    yield 3
}
var g=gen()
g.next()//{value:1,done:false}
g.return()//{value:undefined,done:true}
```
  如果Generator函数内部有try finally代码块，那么return方法会推迟到finally代码块执行完再执行：
```javascript
function* numbers(){
    yield 1;
    try{
        yield 2;
        yield 3;
    }finally{
        yield 4;
        yield 5;
    }
    yield 6
}
var g=numbers();
g.next()//{value:1,done:false}
g.next()//{value:2,done:fasle}
g.return(7)//{value:4,done:false}
g.next()//{value:5,done:false}
g.next()//{value:7,done:true}
//调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法
```
### 6.next()、throw()、return()的共同点
  next()  throw()  return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同弄的语句替换yield表达式。
  next() 是将yield表达式替换成一个值：
```javascript
const g=function* (x,y){
    let result=yield x+y;
    returrn result;
}
const gen=g(1,2)
gen.next()//Object{value:3,done:false}
gen.next(1)//Object{value:1,done:true}
//相当于let result = yield x+y 替换成 let result=1，如果next方法没有参数，就相当于替换成undefined
```
  throw()是将yield表达式替换成一个throw语句：
```javascript
gen.throw(new Error('出错了'))//Uncaught Error:出错了
//相当于将let result=yield x+Y，替换成let result=throw(new Error('出错了'))
```
  return()是将yield表达式替换成一个return语句：
```javascript
gen.return(2)//Object{value:2,done:true}
//相当于将let result=yield x+y替换成let result =return 2
```
### 7.yield* 表达式
  如果在Generator函数内部调用另一个Generator函数，默认情况下是没有效果的：
```javascript
function* foo(){
    yield 'a'
    yield 'b'
}
function* bar(){
    yield 'x';
    foo();
    yield 'y'
}
for (let v of bar()){
    console.log(v)/// 'x'   'y'
}
//foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的
```
  这个就需要用到yield\*表达式，用来在一个Generator函数里面执行另一个Generator函数：
```javascript
function* bar(){
    yield 'x';
    yield* foo();
    yield 'y'
}
//等同于
function* bar(){
    yield 'x'
    yield 'a'
    yield 'b'
    yield 'y'
}
//相当于
function* bar(){
    yield 'x'
    for(let v of foo()){
        yield v;
    }
    yield 'y'
}
for (let v of bar()){
    console.log(v)
}
//'x'  'a'  'b'  'y'
```
  举一个对比的栗子：
```javascript
function* inner() {
  yield 'hello';
}
function* outer1() {
  yield 'open';
  yield inner();
  yield 'close';
}
var gen = outer1()
gen.next().value // "open"
gen.next().value // 返回一个遍历器对象
gen.next().value // "close"
function* outer2() {
  yield 'open'
  yield* inner()
  yield 'close'
}
var gen = outer2()
gen.next().value// 'open'
gen.next().value// 'hello'
gen.next().value// 'close'
//这个栗子里面，outer2使用了yield*,outer1没使用，结果就是outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值
```
  从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象，这被称为yield\*表达式
```javascript
let delegatedIterator=(function* (){
    yield 'hello'
    yield 'sayonara'
}())
let delegatingIterator=(function*(){
    yield 'Greeting'
    yield* delegatedIterator
    yield 'ok, ja'
}())
for(let value of delegatingIterator){
    console.log(value)
}
//'Greeting'  'hello'  'sayyonara' 'ok, ja'
//这段代码，delegatingIterator是代理者，delegatedIterator是被代理者，由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示，运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果
```
  yield\*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for of 循环：
```javascript
function* concat(iter1,iter2){
    yield* iter1;
    yield* iter2
}
//相当于
function* concat(iter1,iter2){
    for(var value of iter1){
        yield value
    }
    for (var value of iter2){
        yield value
    }
}
//这段代码说明，yield* 后面的Generator函数（没有return语句时），不过是for of的一种简写形式，完全可以用后者代替前者，反之，在有return语句时，则需要用var value=yield* Iterator的形式获取return语句的值。
```
  如果yield\*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员：
```javascript
function* gen(){
    yield* ['a','b','c']
}
gen().next()//{value:'a',done:false}
//yield表达式返回整个字符串，yield*语句返回单个字符，因为字符串具有Iterator接口，所以被yield* 遍历
```
  如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据：
```javascript
function* foo(){
    yield 2;
    yield 3
    return 'foo'
}
function* bar(){
    yield 1
    var v=yield* foo()
    console.log('v:' +v)
    yield 4
}
var it=bar()
it.next()//{value:1,done:false}
it.next()//{vaule:2,done:false}
it.next()//{value:3,done:false}
it.next()//'v:foo'  {value:4,done:false}
it.next()//{value:undefined,done:true}
//在第四次调用next方法的时候会有输出，这是因为函数foo的return语句，向函数bar提供了返回值
```
  再举个栗子：
```javascript
function* genFuncWithReturn(){
    yield 'a'
    yield 'b'
    return '结果类'
}
function* logReturned(genObj){
    let result=yield*genObj;
    console.log(result)
}
[...logReturned(genFuncWithReturn())]// 结果类  值为['a','b']
//这段代码存在两次遍历，第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象，这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以最后的数据表达式得到的值等于['z','b'],但是函数genFuncWithReturn的return语句的返回值 结果类，会返回给函数logReturned内部的result变量，因此会有终端输出。。
```
  yield\*命令可以很方便地去除嵌套数组的所有成员：
```javascript
function* iterTree(tree){
    if(Array.isArray(tree)){
        for(let i=0;i<tree.length;i++){
            yield* iterTree(treee[i])
        }
    }else{
        yield tree
    }
}
const tree=['a',['b','c'],['d','e']]
for (let x of iterTree(tree)){
    console.log(x)//a  b  c  d  e
}
```
  使用yield\*语句遍历完全二叉树：
```javascript
// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树
function Tree(left, label, right) {
  this.left = left;
  this.label = label;
  this.right = right;
}
// 下面是中序（inorder）遍历函数。由于返回的是一个遍历器，所以要用generator函数。函数体内采用递归算法，所以左树和右树要用yield*遍历
function* inorder(t) {
  if (t) {
    yield* inorder(t.left);
    yield t.label;
    yield* inorder(t.right);
  }
}
// 下面生成二叉树
function make(array) {
  if (array.length == 1) return new Tree(null, array[0], null);// 判断是否为叶节点
  return new Tree(make(array[0]), array[1], make(array[2]));
}
let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);
// 遍历二叉树
var result = [];
for (let node of inorder(tree)) {
  result.push(node);
}
result// ['a', 'b', 'c', 'd', 'e', 'f', 'g']
```
### 8.作为对象属性的Generator函数
  如果一个对象的属性是Generator函数，可以简写成下面的形式：
```javascript
let obj = {
  * myGeneratorMethod() {...}//myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数
};
//相当于：
let obj = {
  myGeneratorMethod: function* () {...}
};
```
### 9.Generator函数的this
  Generator函数总是返回一个遍历器，es6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法：
```javascript
function* g() {}
g.prototype.hello = function () {
  return 'hi';
};
let obj = g()
obj instanceof g // true
obj.hello() // 'hi'
//这段代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype，但是如果把g当做普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象：
function* g() {
  this.a = 11;
}
let obj = g();
obj.next();
obj.a // undefined，Generator函数g在this对象上添加了一个属性a,但是obj对象拿不到这个属性
```
  Generator函数也不能跟new命令一起用，会报错：
```javascript
function* F() {
  yield this.x = 2;
  yield this.y = 3;
}
new F()//报错: F is not a constructor
```
  如果想让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this，可以用一些变通的方法。首先生成一个空对象，使用call方法绑定Generator函数内部的this，这样构造函数调用以后，这个空对象就是Generator函数的实例对象了：
```javascript
function* F(){
    this.a=1
    yield this.b=2
    yield this.c=3
}
var obj={}
var f=F.call(obj)
f.next()//Object{value:2,done:false}
f.next()//Object{value:3,done:false}
f.next()//Object{value:undefined,done:true}
obj.a//1
obj.b//2
obj.c//3
//这段代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象，这个对象执行三次next方法（因为F内部有两个yield表达式），完成F内部所有代码的运行，这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例，上面执行的是遍历器对象f，但是生成是对象实例是obj，如果想要这个两个对象的统一的话：
//一个方法就是将obj换成F.prototype
function* F() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}
var f = F.call(F.prototype);
f.next()// Object {value: 2, done: false}
f.next()// Object {value: 3, done: false}
f.next()// Object {value: undefined, done: true}
f.a // 1
f.b // 2
f.c // 3
//再将F改成构造函数，就可以对它执行new命令了:
function* gen(){
    this.a=1;
    yield this.b=2;
    yield this.c=3
}
function F(){
    returrn gen.call(gen.prototype)
}
var f=new F()
f.next()//Object{value:2,done:false}
f.next()//Object{value:3,done:false}
f.next()//Object{value:undefined,done:true}
f.a//1
f.b//2
f.c//3
```
### 10.含义
#### 10.1 Generator与状态机
  Generator是实现状态机的最佳结构，比如，下面的clock函数就是一个状态机：
```javascript
var ticking=true;
var clock=function(){
    if(ticking) console.log('tick')
    else console.log('tock')
    ticking = !ticking
}
//这段代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样：
var clock = function* () {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
}
//上面的Generator实现与es5星币，少了用来保存状态的外部变量ticking，这样就更简洁，更安全、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停状态
```
#### 10.1 Generator与协程
  协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。
##### 10.1.1 协程与子例程的差异
  传统的 子例程 采用堆栈式 后进先出 的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程不一样，多个线程（单线程的情况下，就是多个函数了）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其它线程或者函数都处于暂停态，线程或函数之间可以交换执行权，也就是说一个线程或者函数执行到一半，可以暂停执行，将执行权交给另一个线程或函数，等到稍后收回执行权的时候，再恢复执行，这种可以并行执行、交换执行权的线程或函数。就称为协程。从实现看，在内存中，子例程只使用一个栈，而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行 。
##### 10.1.2 协程与普通线程的差异
  协程适合用于多任务运行的环境，在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量，它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其它协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。
  由于JavaScript是单线程语言，只能保持一个调用栈，引入协程以后，每个任务可以保持自己调用栈，这样做的最大好处就是抛出错误的时候，可以找到原始的调用栈，不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束掉了。
  Generator函数是es6对协程的实现，但属于不完全实现，Generator函数被称为 半协程 ，意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数，如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。
  如果将Generator函数当做协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield表达式交换控制权。































