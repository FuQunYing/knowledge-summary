# Day23
### 4.Generator.prototype.throw()
  Geneartor函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获:
```javascript
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};
var i = g();
i.next();
try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
//这段代码中，遍历器对象i连续抛出两个错误，第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获
```
  throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例：
```javascript
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log(e);
  }
};
var i = g();
i.next();
i.throw(new Error('出错了！'));
// Error: 出错了！(…),注意不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获

var g = function* () {
  while (true) {
    try {
      yield;
    } catch (e) {
      if (e != 'a') throw e;
      console.log('内部捕获', e);
    }
  }
};
var i = g();
i.next();
try {
  throw new Error('a');
  throw new Error('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 外部捕获 [Error: a]，之所以捕获a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面的剩余的语句了
```
  如果Generator函数内部没有部署try catch代码块，那么throw方法抛出的错误，将被外部try catch代码块捕获：
```javascript
var g=function* (){
    while(true){
        yield;
        console.log('内部错误',e)
    }
}
var i=g()
i.next()
try{
    i.throw('a')
    i.throw('b')
} catch(e){
    console.log('外部捕获',e)
}
//外部 捕获 a，Generator函数g内部没有部署try catch代码块，所以抛出的错误直接被外部catch代码块捕获
```
  如果Generator函数内部和外部，都没有部署try catch 代码块，那么程序将报错，直接中断执行：
```javascript
var gen=function* gen(){
    yield console.log('hello')
    yield console.log('world')
}
var g=gen()
g.next();//hello
g.throw()//Uncaught undefined
//g.throw抛出错误以后，没有任何try catch代码块可以捕获这个错误，导致程序报错，中断执行
```
  throw 方法抛出的错误要被内部捕获，前提是必须执行过一次next方法：
```javascript
function* gen(){
    try{
        yield 1;
    }catch(e){
        console.log('内部捕获')
    }
}
var g=gen()
g.throw(1)//Uncaught 1
//g.throw(1)执行时，next方法一次都没有执行过，这时抛出的错误不会被内部捕获而是直接在外部抛出，导致程序出错。这种行为其实比较好理解，因为第一次执行next方法，等同于启动执行Generator函数的内部代码，否则Generator函数还没有开始执行，这时候throw方法抛出错误只可能抛出在函数外部
```
  throw 方法被捕获以后，会附带执行下一条yield表达式，也就是说会附带执行一次next方法：
```javascript
var gen=function* gen(){
    try{
        yield console.log('a')
    }catch(e){....}
    yield console.log('b')
    yield console.log('c')
}
vvar g=gen()
g.next()//a
g.throw()//b
g.next()//c
//g.throw方法被捕获以后，会自动执行一次next方法，所以会打印b。另外，只要Generator函数内部 部署了try catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
```
  另外，throw命令与g.throw方法是无关的，两个互不影响：
```javascript
var gen=function* gen(){
    yield console.log('hello');
    yield console.log('world')
}
var g=gen();
g.next()
try{
    throw new Error();
}catch(e){
    g.next()
}
//hello    world
//throw命令抛出的错误不会影响到遍历器的状态，所以两个执行next方法，都进行了正确的操作。
```
  这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。
  Generator函数体外抛出的错误，可以在函数天内捕获，反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获：
```javascript
function* foo(){
    var x=yield 3;
    var y=x.toUpperCase();
    yield y
}
var it=foo()
it.next()//{value:3,done:false}
try{
	it.next(42)
}ctach(err){
    console.log(err)
}
//第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获
```
  一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了，如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了：
```javascript
function* g(){
    yield 1;;
    console.log('抛出一个异常');
    throw new Error('generator broke')
    yield 2;
    yield 3;
}
function log(generator){
    var v;
    console.log('开始 generator')
    try {
        v=generator.next();
        console.log('第一个运行next方法',v)
    }catch(err){
        console.log('捕捉错误',v)
    }
    try{
        v=generator.next();
        console.log('第二次运行next方法',v)
    }catch((err)){
        console.log('捕捉错误',v)
    }
    try{
        v=generator.next();
        console.log('第三次运行next方法',v)
    }ctach(err){
        console.log('捕捉粗偶',v)
    }
    console.log('结束')
}
log(g())
//开始 generator
//第一次运行next方法 {value:1,done:false}
//抛出一个异常
//捕捉错误 {value:1,done:false}
//第三次运行next方法 {value:undefined,done:true}
//结束
//这段代码总共运行了三次next方法，第二次运行的时候抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了
```
### 5.Generator.prototype.return()
  Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数：
```javascript
function* gen(){
    yield 1;
    yield 2;
    yield 3
}
var g=gen()
g.next()//{value:1,done:false}
g.return()//{valule:'foo',done:true}
g.next()//{value:undefined,done:true}
//遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true
```
  如果return方法调用时，不用提供参数，则返回值的value属性为undefined：
```javascript
function* gen(){
    yield 1;
    yield 2;
    yield 3
}
var g=gen()
g.next()//{value:1,done:false}
g.return()//{value:undefined,done:true}
```
  如果Generator函数内部有try finally代码块，那么return方法会推迟到finally代码块执行完再执行：
```javascript
function* numbers(){
    yield 1;
    try{
        yield 2;
        yield 3;
    }finally{
        yield 4;
        yield 5;
    }
    yield 6
}
var g=numbers();
g.next()//{value:1,done:false}
g.next()//{value:2,done:fasle}
g.return(7)//{value:4,done:false}
g.next()//{value:5,done:false}
g.next()//{value:7,done:true}
//调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法
```
### 6.next()、throw()、return()的共同点
  next()  throw()  return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同弄的语句替换yield表达式。
  next() 是将yield表达式替换成一个值：
```javascript
const g=function* (x,y){
    let result=yield x+y;
    returrn result;
}
const gen=g(1,2)
gen.next()//Object{value:3,done:false}
gen.next(1)//Object{value:1,done:true}
//相当于let result = yield x+y 替换成 let result=1，如果next方法没有参数，就相当于替换成undefined
```
  throw()是将yield表达式替换成一个throw语句：
```javascript
gen.throw(new Error('出错了'))//Uncaught Error:出错了
//相当于将let result=yield x+Y，替换成let result=throw(new Error('出错了'))
```
  return()是将yield表达式替换成一个return语句：
```javascript
gen.return(2)//Object{value:2,done:true}
//相当于将let result=yield x+y替换成let result =return 2
```
### 7.yield* 表达式
  如果在Generator函数内部调用另一个Generator函数，默认情况下是没有效果的：
```javascript
function* foo(){
    yield 'a'
    yield 'b'
}
function* bar(){
    yield 'x';
    foo();
    yield 'y'
}
for (let v of bar()){
    console.log(v)/// 'x'   'y'
}
//foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的
```
  这个就需要用到yield\*表达式，用来在一个Generator函数里面执行另一个Generator函数：
```javascript
function* bar(){
    yield 'x';
    yield* foo();
    yield 'y'
}
//等同于
function* bar(){
    yield 'x'
    yield 'a'
    yield 'b'
    yield 'y'
}
//相当于
function* bar(){
    yield 'x'
    for(let v of foo()){
        yield v;
    }
    yield 'y'
}
for (let v of bar()){
    console.log(v)
}
//'x'  'a'  'b'  'y'
```
  举一个对比的栗子：
```javascript
function* inner() {
  yield 'hello';
}
function* outer1() {
  yield 'open';
  yield inner();
  yield 'close';
}
var gen = outer1()
gen.next().value // "open"
gen.next().value // 返回一个遍历器对象
gen.next().value // "close"
function* outer2() {
  yield 'open'
  yield* inner()
  yield 'close'
}
var gen = outer2()
gen.next().value// 'open'
gen.next().value// 'hello'
gen.next().value// 'close'
//这个栗子里面，outer2使用了yield*,outer1没使用，结果就是outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值
```
  从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象，这被称为yield\*表达式
```javascript
let delegatedIterator=(function* (){
    yield 'hello'
    yield 'sayonara'
}())
let delegatingIterator=(function*(){
    yield 'Greeting'
    yield* delegatedIterator
    yield 'ok, ja'
}())
for(let value of delegatingIterator){
    console.log(value)
}
//'Greeting'  'hello'  'sayyonara' 'ok, ja'
//这段代码，delegatingIterator是代理者，delegatedIterator是被代理者，由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示，运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果
```
  yield\*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for of 循环：
```javascript
function* concat(iter1,iter2){
    yield* iter1;
    yield* iter2
}
//相当于
function* concat(iter1,iter2){
    for(var value of iter1){
        yield value
    }
    for (var value of iter2){
        yield value
    }
}
//这段代码说明，yield* 后面的Generator函数（没有return语句时），不过是for of的一种简写形式，完全可以用后者代替前者，反之，在有return语句时，则需要用var value=yield* Iterator的形式获取return语句的值。
```
  如果yield\*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员：
```javascript
function* gen(){
    yield* ['a','b','c']
}
gen().next()//{value:'a',done:false}
//yield表达式返回整个字符串，yield*语句返回单个字符，因为字符串具有Iterator接口，所以被yield* 遍历
```
  如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据：
```javascript
function* foo(){
    yield 2;
    yield 3
    return 'foo'
}
function* bar(){
    yield 1
    var v=yield* foo()
    console.log('v:' +v)
    yield 4
}
var it=bar()
it.next()//{value:1,done:false}
it.next()//{vaule:2,done:false}
it.next()//{value:3,done:false}
it.next()//'v:foo'  {value:4,done:false}
it.next()//{value:undefined,done:true}
//在第四次调用next方法的时候会有输出，这是因为函数foo的return语句，向函数bar提供了返回值
```
  再举个栗子：
```javascript
function* genFuncWithReturn(){
    yield 'a'
    yield 'b'
    return '结果类'
}
function* logReturned(genObj){
    let result=yield*genObj;
    console.log(result)
}
[...logReturned(genFuncWithReturn())]// 结果类  值为['a','b']
//这段代码存在两次遍历，第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象，这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以最后的数据表达式得到的值等于['z','b'],但是函数genFuncWithReturn的return语句的返回值 结果类，会返回给函数logReturned内部的result变量，因此会有终端输出。。
```
  yield\*命令可以很方便地去除嵌套数组的所有成员：
```javascript
function* iterTree(tree){
    if(Array.isArray(tree)){
        for(let i=0;i<tree.length;i++){
            yield* iterTree(treee[i])
        }
    }else{
        yield tree
    }
}
const tree=['a',['b','c'],['d','e']]
for (let x of iterTree(tree)){
    console.log(x)//a  b  c  d  e
}
```
  使用yield\*语句遍历完全二叉树：
```javascript

```






























