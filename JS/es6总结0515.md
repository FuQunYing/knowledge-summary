# Day14
## 九、Symbol
### 1.概述
  es5的对象属性名都是字符串，这容易造成属性名的冲突，比如，我使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能提供与现有方法产生冲突，如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。所以es6引入Symbol。
  es6引入了一种新的原始数据类型Symbol，表示独一无二的值，它是JavaScript语言的第七种数据类型。Symbol值通过Symbol函数生成，这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型，凡是属性名属于Symbol累心，就都是独一无二的，可以保证不会与其他属性名产生冲突：
```javascript
let s=Symbol();
typeof s//symbol,变量s就是一个独一无二的值，typeof运算符的结果，表明变量s是Symbol数据类型，而不是字符串之类的其它类型。
```
  Symbol函数前不能使用new命令，否则会报错，这是因为生成的Symbol是一个原始类型的值，不是对象，也就是说由于Symbol值不是对象，所以不能添加属性，基本上它是一种类似于字符串的数据类型。
  Symbol函数可以接受一个字符串作为参数，表示Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分：
```javascript
let s1=Symbol('foo')
let s2=Symbol('bar')
s1//Symbol(foo)
s2//Symbol(bar)
s1.toString()//'Symbol(foo)'
s2.toString)()//'Symbol(bar)'
//s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。

//Symbol值不能与其它类型的值进行运算，会报错
let sym =Symbol('a symbol')
'there is a symbol' + sym//报错：can'tconvert symbol toostring
`there is  a symbol ${sym}`

//但是Symbol值可以显式转为字符串
let sym = Symbol('a symbol');
String(sym) // 'Symbol(a symbol)'
sym.toString() // 'Symbol(a symbol)'

//另外，Symbol值也可以转为布尔值，但是不能转为数值
let sym = Symbol();
Boolean(sym) // true
!sym  // false
if (sym) {...}
Number(sym) //报错
sym + 2 //报错
```






















