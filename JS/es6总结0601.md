# Day27
### 7.异步遍历器
  Iterator接口是一种数据遍历的协议，只要调用遍历器对象的next烦恼歌发，就会得到一个对象，表示当前遍历指针所在的那个位置的信息，next方法返回的对象的结构是{value,done},其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值，也就是说，一旦执行next方法，就必须同步的得到value和done这两个属性，如果遍历指针正好指向同步操作，没毛病，但是对于异步操作，就不太合适了，目前的解决方法是，Generator函数里面的异步操作，返回一个Thunk函数或者Promise对象，即value属性是一个Thunk函数或者Promise对象，等待以后返回真正的值，而done属性则还是同步产生的。es2018引入了 异步遍历器，为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。
#### 7.1 异步遍历器的接口
  异步比那里器的最大语法特点，就是调用遍历器的next方法，返回的是一个Promise对象：
```javascript
asyncIterator.next().then(({value,done})=> //....)
//asyncIterator是一个异步遍历器，调用next方法以后，返回一个Promise对象，因此，可以使用then方法指定，这个Promise对象的状态变为resolve以后的回调函数，回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的
```
  一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面，同样的，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面，不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。
  一个异步遍历器的栗子：
```javascript
const asyncIterable=createAsyncIterable(['a','b'])
const asyncIterator=asyncIterable[Symbol.asyncIterator]()
asyncIterator.next()
.then(iterResult1 => {
    console.log(iterResult1)//{value:'a',done:false}
    return asyncIterator.next()
}).then(iterResult22 => {
    console.log(iterResult2)//{value:'b',done:false}
    return asyncIterator.next()
}).then(iterResult3 => {
    console.log(iterResult3)//{value: undefined,done:true}
})
//异步遍历器其实返回了两次值，第一次调用的时候，返回一个Promise对象；等到Promise对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只会先返回Promise对象，作为中介
```
  由于异步遍历器的next方法，返回的是一个Promise对象，因此可以把它放在await命令后面：
```javascript
async function f(){
    const asyncIterable=createAsyncIterable(['a','b'])
    const asyncIterator=asyncIterable[Symbol.asynncIterator]()
    console.log(await asyncIterator.next())//{value:'a',done:false}
    console.log(await asyncIterator.next())//{value:'b',done:false}
    console.log(await asyncIterator.next())//{value:undefined,done:true}
    //next方法用await处理以后，就不必使用then方法了，整个流程已经很接近同步处理了
}
```
  注意异步遍历器的next方法是可以连续调用的，不必等到上一步产生的Promise对象resolve以后再调用，这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。
```javascript
//把所有的next方法放在Promise.all方法里面
const asyncGenObj=createAsyncIterable(['a','b'])
const [{value:v1},{value:v2}]=await Promsie.all([
    asyncGenObj.next(),asyncGenObj.next()
])
console.log(v1,v2)//a b
```
  另一种用法是一次性调用所有的next方法，然后await最后一步操作：
```javascript
async function runner(){
    const writer=openFile('someFile.txt')
    writer.next('hello')
    writer.next('world')
    await writer.return()
}
runner()
```
#### 7.2 for await of
  前面说的，for of循环用于遍历同步的Iterator接口，新引入的for await of 循环则是用于遍历异步的Iterator接口：
```javascript
async function fun(){
    for await(const x of createAsyncIterable(['a','b'])){
        console.log(x)//a //b
    }
}
//createAsyncIterable()返回一个拥有异步遍历器接口的对象，for of循环自动调用这个对象的一步遍历器的next方法，会得到一个Promise对象。await用来出来这个Promise对象，一旦resolve，就把得到的值（x）传入for of的循环体
```
  for await of循环的一个用途，是部署了asyncIterable操作的异步接口，可以直接放入这个循环：
```javascript
let body =''
async function f(){
    for await (const data of req) body+=data
    const parsed=JSON.parse(body)
    console.log('got',parsed)
}
//req是一个asyncIterable对象，用来异步读取数据，可以看到，使用for await of循环的一个用途，是部署了asyncIterable操作的异步接口，可以直接放入这个循环
let body = ''
async function fun() {
    for await(const data of req) body += data
    const parsed=JSON.parse(body)
    console.log('got',parsed)
}
//req是一个asyncIterable对象，用来异步读取数据，使用for await of循环的话，代码会非常简洁
```
  如果next方法返回的Promise对象被reject，for await of就会报错，要用try catch捕捉：
```javascript
async function(){
    try{
        for await(const x of createRejectingIterable()){
            console.log(x)
        }
    }catch(e){
        console.log(e)
    }
}
```
  注意，for await of 循环也可以用于同步遍历器：
```javascript
(async function(){
    for await(const x of ['a','b']){
        console.log(x)//a //b
    }
})()
```
  Node V10支持异步遍历器，Stream就部署了这个接口，下面是读取文件的传统写法与异步遍历器写法的差异：
```javascript
//传统写法
function main(inputFilePath){
    const readStream=fs.createReadStream(inputFilePath,{encoding:'utf8',highWaterMark:1024});
    readStream.on('data',(chunk)=>{
        console.log('>>>'+chunk)
    });
    readStream.on('end',()=>{
        console.log('### DONE ###')
    })
}
//异步遍历器写法
async function main(inputFilePath){
    const readStream=fs.createReadStream(inputFilePath,{encoding:'utf8',highWaterMark:1024});
    for await (const chunk of readStream){
        console.log('>>>'+chunk)
    }
    console.log('### DONE ###')
}
```
























