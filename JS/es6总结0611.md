# Day 33
## 二十三、编程风格
### 1.块级作用域
#### 1.1 let取代var
  ES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。
```javascript
'use strict';
if (true) {
  let x = 'hello';
}

for (let i = 0; i < 10; i++) {
  console.log(i);
}
//如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。
```
  var命令存在变量提升效用，let命令没有这个问题。
```javascript
'use strict';
if (true) {
  console.log(x); // ReferenceError
  let x = 'hello';
}
//如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。
```
  所以，建议不再使用var命令，而是使用let命令取代。
#### 1.2 全局常量和线程安全
  在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。const优于let有几个原因。一是const可以提醒阅读程序的人，这个变量不应该改变，另个一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是JavaScript编译器会对const进行优化，所以多使用const有利于提高程序的运行效率，也就是说let和const的本质区别，是编译器内部的处理不同：
```javascript
//bad
var a=1,b=2,c=3
//good
const a=1;
const b=2;
const c=3;
//best
const [a,b,c]=[1,2,3]
```
  const声明常量还有两个好处，一是阅读代码的人会立刻意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。
  所有的函数都应该设置为常量。
  长远来看，JavaScript可能会有多线程的实现，这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。
### 2.字符串
  静态字符串一律使用单引号或反引号，不使用双引号，动态字符串使用反引号：
```javascript
// bad
const a = "foobar";
const b = 'foo' + a + 'bar';
// acceptable
const c = `foobar`;
// good
const a = 'foobar';
const b = `foo${a}bar`;
const c = 'foobar';
```
### 3.解构赋值
  使用数组成员对变量赋值时，优先使用解构赋值：
```javascript
const arr=[1,2,3,4]
//bad
const first=arr[0]
const second=arr[1]
//good
const [first,second]=arr
```
  函数的参数如果是对象的成员，优先使用解构赋值：
```javascript
//bad
function getFullName(user){
    const firstName=user.firstName
    const lastName=user.lastName
}
//good
function getFullName(obj){
    const {firstName,lastName}=obj
}
//best
function getFullName({firstName,lastName})
```
  如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序：
```javascript
//bad
function processInput(input){
    return [left,right,top,bottom]
}
//good
function processInput(input){
    return {left,right,top,bottom}
}
const {left,right}=processInput(input)
```
### 4.对象
  单行定义的对象，最后一个成员不以逗号结尾，多行定义的对象，最后一个成员以逗号结尾：
```javascript
//bad
const a={k1:v1,k2:v2}
const b={
    k1:v1,
    k2:v2
}
//good
const a={k1:v1,k2:v2}
const b={
    k1:v1,
    k2:v2
}
```
  对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法：
```javascript
//bad
const a={}
a.x=3;
//如果添加属性不可避免了
const a={};
Object.assign(a,{x:3})
//good
const a={x:null}
a.x=3
```
  如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义：
```javascript
//bad
const obj={
    id:5,
    name:'San Francisco'
}
Object[getKey('enabled')]=true
//good
const obj={
    id:5,
    name:'San Francisco',
    [getKey('enabled')]:true
}
//对象obj的最后一个属性名，需要计算得到，这时最好采用属性表达式，在新建obj的时候，将该属性与其它属性定义在一起。这样一来，所有属性就在一个地方定义了。
```
  另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写：
```javascript
var ref='some value'
//bad
const atom={
    ref:ref,
    value:1,
    addValue;function(value){
        return atom.value+value
    }
}
//good
const atom={
    ref,
    value:1,
    addValue(value){
        return atom.value+value
    }
}
```
### 5.数组
  使用扩展运算符(...)拷贝数组：
```javascript
//bad
const len=items.length
const itemsCopy=[]
let i;
for(i=0;i<len;i++){
    itemsCopy[i]=items[i]
}
//good
const itemsCopy=[...items]
```
  使用Array.from方法，将类似数组的对象转为数组：
```javascript
const foo=document.querySelectorAll('.foo')
const nodes=Array.from(foo)
```
### 6.函数
  立即执行函数可以写成箭头函数的形式：
```javascript
(()=>{
    console.log('hello world')
})()
```
  那些需要使用函数表达式的场合，尽量用箭头函数代替，因为更简单，还绑定了this：
```javascript
//bad
[1,2,3].map(function(x){
    return x*x
})
//good
[1,2,3].map((x)=>{
    return x*x
})
//best
[1,2,3].map(x=>x*x)
```
  箭头函数取代Function.prototype.bind，不应再用self/\_this/that绑定this：
```javascript
//bad
const self=this
const boundMethod=function(...params){
    return method.apply(self,params)
}
//acceptable
const boundMethod=method.bind(thhis)
//best
const boundMethod=(...params)=>method.apply(this,params)
```
  简单的、单行 的、不会复用的函数，建议采用箭头函数，如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数：
```javascript
//bad
function divide(a,b,option=false){}
//good
function divide(a,b,{option=false}={}){}
```
  不要在函数体内使用arguments变量，使用rest运算符(...)代替。因为rest运算符显示表明我想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组：
```javascript
//bad
function concatenateAll(){
    const args=Array.prototype.slice.call(arguments)
    return args.join('')
}
//good
function  concatenateAll(...args){
    return args.join('')
}
```
  使用默认值语法设置函数参数的默认值：
```javascript
//bad
function handleThings(opts){
    opts=opts||{}
}
//good
function handleThings(opts={}){....}
```
### 7.Map结构
  注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要区分key:value的数据结构，使用Map结构。因为Map有内建的遍历机制：
```javascript
leet map=new Map(arr)
for(let key of map.keys()){
    console.log(key)
}
for (let value of map.values()){
    console.log(value)
}
for (let item of map.entries()){
    console.log(item[0],item[1])
}
```
### 8.Class
  用Class取代需要prototype的操作。因为Class的写法更简洁，更易于理解：
```javascript
//bad
function Queue(contents =[]){
    this.__queue=[...contents]
}
Queue.prototype.pop=function(){
    const value=this._queue[0]
    this._queue.splice(0,1)
    return value
}
//good
class Queue{
    constructor(contents=[]){
        this._queue=[...contents]
    }
    pop(){
        const value=this._queue[0]
        this._queue.splice(0,1)
        return value
    }
}
```
  使用extends实现继承，这样更简单，不会破坏instanceof运算的危险：
```javascript
//bad
const inherits=require('inherits')
function PeekableQueue(contents){
    Queue.apply(this,contents)
}
inherits(PeekableQueue,Queue);
PeekableQueue.prototype.peek=function(){
    return this._queue[0]
}
//good
class PeekableQueu extends Queue{
    peek(){
        return this._queue[0]
    }
}
```
### 9.模块
  首先Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。
```javascript
//bad
const moduleA=require('moduleA')
const func1=module!.func1;
const func2=moduleA.func2
//good
import {func1,func2} from 'moduleA'
```
  使用export取代module.exports：
```javascript
//CommonJS的写法
var React=require('react')
var Breadcrumbs=React.createClass({
    render(){
        return <nav/>
    }
})
module.exports=Breadcrumbs
//es6的写法
import React from 'react'
class Breadcrumbs extends React.Component{
    render(){
        return <nav/>
    }
}
export default Breadcrumbs
```
  如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export 不要同时使用。
  不要在模块输入中使用通配符。因为这样可以确保模块之中，有一个默认输出：
```javascript
//bad
import * as myObject from './importModule'
//good
import myObject from './importModule'
```
  如果模块默认输出一个函数，函数名的首字母应该小写：
```javascript
function makeSttyleGuide(){....}
export default makeStyleGuide
```
  如果模块默认输出一个对象，对象的首字母应该大写：
```javascript
const StyleGuide={
    es6:{}
}
export default StyleGuide;
```
### 10.ESLint的使用
  ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。
  首先，安装ESLint：
  	npm i -g eslint
  然后，安装Airbnb语法规则，以及import、a11y、react插件：
  	npm i -g eslint-config-airbnb
  	npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
  最后，在项目的根目录下新建一个.eslinttrc文件，配置ESLint：
```json
{
    'extends':'eslint-config-airbnb'
}
```
  现在就可以检查，当前项目代码是否符合预设的规则。index.js文件代码如下：
```javascript
var unusued='lueluelue'
function greet(){
    var msg='hello world'
    alrt(msg)
}
greet()
```
  使用ESLint检查这个文件就会报错：
  	$ eslint index.js
    index.js
      1:1  error  Unexpected var, use let or const instead         no-var
      1:5  error  unusued is defined but never used        no-unused-vars
      4:5  error  Expected indentation of 2 characters but found 4 indent
      4:5  error  Unexpected var, use let or const instead         no-var
      5:5  error  Expected indentation of 2 characters but found 4 indent
      ✖ 5 problems (5 errors, 0 warnings)
  这里就说明了，原文件有五个错误，其中两个是不应该使用var命令，而要用let或者const；一个是定义了变量但是没有用过；另外两个是行首缩进为4个空格，而不是2个
## 二十四、读懂ECMAScript规格
### 1.术语
  查看规格是解决语法问题的最可靠、最权威的终极方法，是解决问题的最后一招。有一些术语，帮助理解规格：
#### 1.1 抽象操作
  是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。比如，Boolean(value)的算法，第一步是这样的：
	1.let b be ToBoolean(value)
  这里的ToBoolean就是一个抽象操作，是引擎内部求出布尔值的算法。许多函数的算法都会多次用到同样的步骤，所以es6规格将它们抽出来，定义成 抽象操作， 方便描述。
#### 1.2 Record和field
  es6规格将键值对的数据结构称为Record，其中的每一组键值对称为field。这就是说，一个Record由多个field组成，而每个field都包含一个键名和一个键值对。
#### 1.3 [[Notation]]
  ES6规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代field的键名。举例来说，obj是一个Record，它有一个Prototype属性。es6规格不会写obj.Prorotype，而是写obj.[[Prototype]]，一般来说，使用[[Notation]]这种书写法的属性 ，都是对象的内部属性。
  所有的JavaScript函数都有一个内部属性[[Call]]，用来运行该函数：
```javascript
  	F.[[Call]](V,argumentsList)
  	//F是一个函数对象，[[Call]]是它的内部方法，F.[[Call]]()表示运行该函数，V表示[[Call]]运行时this的值，argumentsList则是调用时传入函数的参数。
```
#### 1.4 Completion Record
  每一个语句都会返回一个Completion Record，表示运行结果，每个Completion Record有一个[[Type]]属性，表示运行结果的类型。
  [[Type]]属性有五种可能的值：
  - normal
  - return
  - throw
  - break
  - continue
  如果[[Type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[Type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。
### 2.抽象操作的标准流程
  抽象操作的运行流程，一般是这样：
	1.Let resultCompletionRecord be AbstractOp().
	2.If resultCompletionRecord is an abrupt completion, return resultCompletionRecord.
	3.Let result be resultCompletionRecord.[[Value]].
	4.return result.
  上面的第一步是调用抽象操作AbstractOp()，得到resultCompletionRecord，这是一个 Completion Record。第二步，如果这个 Record 属于 abrupt completion，就将resultCompletionRecord返回给用户。如果此处没有返回，就表示运行结果正常，所得的值存放在resultCompletionRecord.[[Value]]属性。第三步，将这个值记为result。第四步，将result返回给用户。
  es6规格将这个标准流程，使用简写的方式表达
	1.Let result be AbstractOp().
	2.ReturnIfAbrupt(result).
	3.return result.
  这个简写方式里面的ReturnIfAbrupt(result)，就代表了上面的第二步和第三步，即如果有报错，就返回错误，否则取出值。甚至还有进一步简写格式：
	1.let result be ? AbstractOp()
	2.return result
  上面流程的?，就代表AbstractOp()。一旦报错，就返回错误，否则取出值。
  除了?，es6规格还使用另一个简写符号!：
	1.Let result be ! AbstractOp()
	2.return result
  上面流程的!，代表AbstractOp()不会报错，返回的一定是 normal completion，总是可以取出值。
### 3.相等运算符
  ==运算符是一个语法行为多变，不符合直觉的运算符。看一下规则是如何规定它的行为的：
```javascript
	0 == null// false，那么问题来了，为什么是false
```
  规格对于每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。算法细节，总共12步：
	1.如果x不是正常值（比如抛出一个错误），中断执行。
	2.如果y不是正常值，中断执行。
	3.如果Type(x)与Type(y)相同，执行严格相等运算x === y。
	4.如果x是null，y是undefined，返回true。
	5.如果x是undefined，y是null，返回true。
	6.如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。
	7.如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。
	8.如果Type(x)是布尔值，返回ToNumber(x) == y的结果。
	9.如果Type(y)是布尔值，返回x == ToNumber(y)的结果。
	10.如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。
	11.如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。
	12.返回false。
  由于0的类型是数值，null的类型是Null，所以上面的11步都得不到结果，要到第12步才能得到false。所以 0==null是false
### 4.数组的空位





















