# Day29
## 十九、Class的继承
### 1.简介
  Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多：
```javascript
class Point {
}
class ColorPoint extends Point {
}
//ColorPoint类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。然后在ColorPoint内部加上代码。
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
//constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
```
  子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
```javascript
class Point {....}
class ColorPoint extends Point {
  constructor() {
  }
}
let cp = new ColorPoint(); // ReferenceError
//ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。
```
  ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。
```javascript
class ColorPoint extends Point {
}
//相当于
class ColorPoint extends Point {
  constructor(...args) {
    super(...args);
  }
}
```
  另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。
```javascript
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError,super之前报错
    super(x, y);
    this.color = color; // 正确，super之后正确
  }
}
```
  下面是生成子类实例的代码。
```javascript
let cp = new ColorPoint(25, 8, 'green');//实例对象cp同时是ColorPoint和Point两个类的实例
cp instanceof ColorPoint // true
cp instanceof Point // true

//最后，父类的静态方法，也会被子类继承:
class A {
  static hello() {
    console.log('hello world');
  }
}
class B extends A {
}
B.hello()  // hello world,上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。
```
###  2.Object.getPrototypeOf()
这个方法可以用来从子类上获取父类：
```javascript
Object.getPropertyOf(ColorPoint)===Point//true，因此可以使用这个方法判断，一个类是否继承了另一个类
```
### 3.super关键字
  super这个关键字，既可以当做函数使用，也可以当做对象使用，在这两种情况下，用法完全不同。第一种情况，super作为函数调用时，代表父类的构造函数，es6要求，子类的构造函数必须执行一次super函数:
```javascript
class A{}
class B extends A{
    constructor(){
        super()
    }
}
//子类B的构造函数之中的super(),代表调用父类的构造函数，这是必须的，否则JavaScript引擎会报错，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constrcutor.call(this)
class A{
    constructor(){
        console.log(new.target.name)
    }
}
class B extends A{
    constructor(){
        super()
    }
}
new A()//A
new B()//B
//new,target指向当前正在执行的函数，在super执行的时候，它指向的是子类B的构造函数，而不是父类A的构造函数，也就是说，super()内部的this指向的是B
```
  作为函数时，super()只能用在子类的构造函数之中，用在其它地方就会报错：
```javascript
class A{}
class B extends A{
    m(){
        super()//报错，super()不能用在这里
    }
}
```
  第二种情况，super作为对象中，在普通方法中，指向父类的原型对象；在静态方法中，指向父类：
```javascript
class A{
    p(){
        return 2
    }
}
class B extends A{
    get m(){
        return super.p
    }
}
let b=new B()
b.m//undefined,p是父类A实例的属性，super.p就引用不到它

//如果属性定义在父类的原型对象上，super就可以取到
class A{}
A.prototype.x=2
clas B extends A{
    constructor(){
        super();
        console.log(super.x)//2，属性x是定义在A.prototype上面的，所以super.可以取到它的值
    }
}
let b=new B()
```
  es6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前子类实例：
```javascript
class A{
    constructor(){
        this.x=1;
    }
    print(){
        console.log(this.x)
    }
}
class B extends A{
    constructor(){
        super();
        this.x=2
    }
    m(){
        super.print()
    }
}
let b=new B();
b.m()//2
//这里面，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1，也就是说，实际上执行的是super.print.call(this)
```
  由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性：
```javascript
class A{
    constructor(){
        this.x=1
    }
}
class B extends A{
    constructor(){
        super();
        this.x=2;
        super.x=3;
        console.log(super.x)//undefined、
        console.log(this.x)//3
    }
}
let b=new B()
//super.x被赋值为3，这时等同于对this.x赋值为3，而当读取super.x的时候，读的是A.prototype.x，所以返回undefined
```
  如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象：
```javascript
class Parent{
    static myMethod(msg){
        console.log('static',msg)
    }
    myMethod(msg){
        console.log('instance',msg)
    }
}
class Child extends Parent{
    static myMethod(msg){
        super.myMethod(msg)
    }
    myMethod(msg){
        super.myMethod(msg)
    }
}
Child.myMethod(1)//static 1
var child=new Child()
child.myMethod(2)//instance 2
//super在静态啊之中指向父类，在普通方法之中指向父类的原型对象
```
  另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例：
```javascript
class A{
    constructor(){
        this.x=1;
    }
    static print(){
        console.log(this.x)
    }
}
class B extends A{
    constructor(){
        super();
        this.x=2;
    }
    static m(){
        super.print()
    }
}
B.x=3
B.m()//3，B.m里面，super.print指向父类的静态方法，这个方法里面的thhis指向的是B，而不是B的实例
```
  使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错：
```javascript
class A{}
class B extends A{
    constructor(){
        super()
        console.log(super)//报错
    }
}
//console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以JavaScript引擎解析代码的时候就会报错，这时，如果能清晰地表明super的数据类型，就不会报错

class A{}
class B extends A{
    constructor(){
        super()
        console.log(super.valueOf() instanceof B)//true
    }
}
let b=new B()
//super.valueOf()表明super是一个对象，因此就不会报错，同时由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例
```
  最后，由于对象总是继承其它对象的，所以可以在任意一个对象中，使用super关键字：
```javascript
var obj={
    toString(){
        return 'MyObject:'+super.toString()
    }
}
obj.toString()//MyObject:[object Object]
```
### 4.类的prototype属性和__proto__属性



























