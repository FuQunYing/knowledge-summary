# ⼀、HTML部分
## 1. script标签为什么放在body下⾯？
- 避免阻塞渲染：”script 默认会阻塞 HTML 解析，放在顶部会导致页面白屏时间变长。
- 提高页面加载速度：让 HTML 结构优先渲染出来，提升用户体验。
- 保证 DOM 已加载：某些脚本依赖页面元素，放在 body 底部能避免 document.getElementById找不到元素的问题。
- 总结： script 放底部是为了 性能优化 + 避免阻塞 + DOM 可用性。
## 2. HTML5语义化标签
- 常见的语义化标签：
> \<header>：头部区域
> \<nav>：导航部分
> \<section>：页面章节内容
> \<article>：独立的文章内容
> \<aside>：侧边栏
> \<footer>：尾部内容
> \<main>：页面主要内容
> \<figure> / \<figcaption>：带标注的媒体内容
> \<mark>：标记高亮
> \<time>：时间

- 好处：
> 结构更清晰，便于维护
> 有利于 SEO（搜索引擎更易理解结构）
> 有利于无障碍阅读（屏幕阅读器可识别语义）

## 3. ⾃定义属性 data-*
- data-* 是 HTML5 提供的用于存储自定义数据的方式，如：
```html
<div data-id="123" data-role="admin"></div>
```
- 特点
> 1. 可通过 JS 获取：element.dataset.id
> 2. 不会污染标准属性
> 3. 常用于组件初始化、业务标记

- 应用场景
> 存储业务数据
> 存储 UI 组件配置
> 在 HTML 与 JS 之间传递信息

## 4. 块级元素、⾏内元素
- 块级元素（block）
> 特点：独占一行，可以设置宽高、margin、padding，宽度默认 100%
> 常见：div, p, ul, li, h1~h6, section, article, header, footer

- 行内元素（inline）
> 特点：不独占一行，不能设置宽高（默认内容撑开），padding、margin 只有左右生效
> 常见：span, a, img（特殊，可替换）, strong, em

- 行内块元素 inline-block
> 可设置宽高，但不独占一行。

## 5. BFC
- BFC 是浏览器布局的一种渲染区域，有一套自己的布局规则。
- 如何触发 BFC？
> overflow: hidden | auto | scroll
> float: left/right
> display: inline-block
> position: absolute/fixed
> display: flow-root

- BFC 能解决什么？
> 清除浮动：父元素形成 BFC 就能包住子元素浮动高度。
> 避免 margin 重叠（外边距折叠）
> 避免浮动元素遮挡内容
> 自适应多列布局
> 一句话总结：BFC = 独立布局环境，用来解决浮动、margin 重叠等问题。

## 6. 可替换元素
- 浏览器根据其标签属性或外部资源来决定具体内容和尺寸。
- 常见可替换元素：
> img，input，textarea，button，select，iframe，video，embed

- 特点
> 1. 宽高可以设置
> 2. 内容由浏览器替换渲染
> 3. 默认行为一般不可用 CSS 完全控制

## 7. 脚本异步加载，三种常见方式（script标签中的defer和async）：
### 1. async
```html
<script src="a.js" async></script>
```
> 下载与解析 HTML 并行
> 下载完立即执行（可能会阻塞）
> 多个 script 执行顺序不保证

### 2. defer
```html
<script src="a.js" defer></script>
```
> 下载与解析 HTML 并行
> 等 DOM 全部解析完后按顺序执行
> 一般用于依赖 DOM 的代码
> 案例应⽤：若脚本有依赖关系且需在⽂档解析完后执⾏，⽤ defer ；若脚本⽆依赖且不影响⻚⾯渲染，⽤ async 。例如在加载第三⽅统计脚本时可⽤ async ，加载依赖于⽂档结构的脚本时⽤ defer 。

### 3. 动态创建 script
```JavaScript
const s = document.createElement('script');
s.src = 'xxx.js';
document.body.appendChild(s);
```
> 默认异步加载，等价于 async

## 8. a 标签 noopener 是什么？
```html
<!--当你使用-->
<a href="xxx" target="_blank" rel="noopener">
```
- 作用
> 防止新窗口通过 window.opener 控制原页面（安全）
> 防止恶意页面修改原窗口 Location（钓鱼攻击）
> 提升性能： 新页面不会与当前页面共享进程（Chrome），提升隔离性。
> 延伸：rel="noopener noreferrer" 中 noreferrer 还会隐藏 referer。
> 
## 9. 解析 html 标签时哪些是异步的？哪些是同步的？
> HTML 解析时， \<script> 标签默认同步加载执⾏，会阻塞⽂档解析。加defer 或 async 属性的 \<script> 异步。 \<link rel="stylesheet"> 同步加载，不阻塞⽂档解析，但阻塞 DOMContentLoaded 事件。 \<img> 异步加载，不影响⽂档解析。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <!-- 同步加载样式 -->
        <link rel="stylesheet" href="styles.css">
        <!-- 默认同步脚本 -->
        <script src="sync.js"></script>
        <!-- 异步脚本 -->
        <script async src="async.js"></script>
    </head>
    <body>
        <!-- 异步加载图⽚ -->
        <img src="example.jpg" alt="Example">
    </body>
</html>
<!--案例应⽤：合理安排标签的同步异步加载，可优化⻚⾯性能。如将不影响⻚⾯渲染的脚本设为异步，避免阻塞⽂档解析；将样式⽂件放在头部同步加载，确保⻚⾯样式正常显示。-->
```

# 二、CSS部分
## 1. 盒子模型（Box Model）
- CSS 有 标准盒模型 和 IE 盒模型。
- 标准盒模型（content-box）
> 盒子总宽度 = width + padding + border + margin

- IE 盒模型（border-box）,width 包含了 padding 和 border：
> 盒子总宽度 = width + margin
> border-box 优点：布局更好算、不容易超出容器。

```css
box-sizing: content-box;   /* 默认 */
box-sizing: border-box;    /* 更常用 */
```
## 2. GPU 渲染（硬件加速）
- 浏览器渲染一般分为：
> CPU：负责布局、绘制
> GPU：负责合成、加速动画

- 哪些 CSS 会触发 GPU 加速？
> transform（translate、scale），opacity，filter，will-change，translateZ(0)、translate3d(0,0,0)

- 优点
> 更流畅的动画（不会反复重排/重绘）
> 避免页面抖动（减少 layout）

- 缺点
> 占用 GPU 内存（图层过多会卡）
> 滥用可能导致耗电、掉帧

- 一句话：使用 transform + opacity 做动画，会进入 GPU 合成层，性能最好。
## 3. flex布局、grid布局
### 3.1 Flex（弹性布局）
- 一维布局：主轴 + 交叉轴
- 常用属性：
> 容器：display:flex
> 主轴方向：flex-direction
> 子项自动分配空间：flex: 1
> 主轴对齐：justify-content
> 交叉轴对齐：align-items
> 换行：flex-wrap

- 适用场景：
> 水平垂直居中
> 响应式导航栏
> 不定宽高布局

### 3.2 Grid（网格布局）
- 二维布局：可以同时控制行 + 列
- 常用属性：
> 行列大小：grid-template-rows / grid-template-columns
> 格子间距：gap
> 子项定位：grid-row / grid-column
> 自动填充：repeat(auto-fill, minmax())

- 适用场景：
> 桌面级布局
> 瀑布流
> 仿 Excel 栅格

- 总结区别
| 布局方式 | Flex | Grid |
| - | - | - |
| 维度 | 一维 | 二维 |
| 场景 | 内容自适应 | 更像先规划版面 |
| 控制 | 子项之间关系 | 行列网格精确布局 |

## 4. 百分比（%）的计算规则
- 关键点：百分比的参考对象，取决于属性本身。
| 属性                                         | 百分比相对于                   |
| ------------------------------------------ | ------------------------ |
| width                                      | 父元素 width                |
| height                                     | **不一定能生效**，取决于父元素是否有明确高度 |
| padding                                    | 父元素 **width**            |
| margin                                     | 父元素 width                |
| transform                                  | 自身大小                     |
| position: absolute 的 left/right/top/bottom | 包含块（一般为最近的定位父元素）         |
- 最容易考的点：padding 百分比是相对父元素的宽度，而不是高度，例如保持正方形常用：
```css
.box {
  width: 50%;
  padding-top: 50%; /* 相对父元素宽度 */
}
```

## 5. 如何实现随窗⼝⼤⼩变化的正⽅形？
- 使用 padding-top
```css
.square {
  width: 30%;
  padding-top: 30%;
  background: #1677ff;
}
```
- 使用 aspect-ratio，最常用，最现代
```css
.square {
  width: 200px;
  aspect-ratio: 1 / 1;
  background: #1677ff;
}
```
- 使用 vw（相对视口）
```css
.square {
  width: 20vw;
  height: 20vw;
}
```
- JS 动态设置（不推荐）
> 监听 window 大小然后设置 height=width。

- 总结最优解：
> aspect-ratio: 1; 是最简洁最现代的写法。

## 6. 了解重排和重绘吗？
- 重排（回流）是指当 DOM 的变化影响了元素的布局信息（元素的宽⾼、边距、位置等），浏览器需要重新计算元素在视⼝内的位置和⼤⼩。
- 重绘是指当⼀个元素的外观发⽣改变，但没有影响到布局信息时，浏览器将新样式绘制到屏幕上。 
- 重排的代价⽐重绘⼤，因为重排可能会触发后续⼀系列元素的重排和重绘。
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #box {
                width: 100px;
                height: 100px;
                background-color: red;
            }
        </style>
    </head>
<body>
    <div id="box"></div>
    <button onclick="changeWidth()">Change Width</button>
    <button onclick="changeColor()">Change Color</button>
    <script>
    function changeWidth() {
        const box = document.getElementById('box');
        box.style.width = '200px'; // 触发重排和重绘
    }
    function changeColor() {
        document.getElementById('box');
        const box = box.style.backgroundColor = 'blue'; // 触发重绘
    }
    </script>
</body>
</html>
<!--案例应⽤：在开发中，应尽量减少重排和重绘的次数。⽐如批量修改 DOM 样式时，可先将元素从⽂档流中移除，修改完后再添加回去；避免频繁读取会触发重排的属性，如 offsetWidth 、 scrollTop 等。-->
```
## 7. CSS 和 JS 动画会导致重排吗？
- CSS 动画和 JS 动画是否导致重排取决于动画改变的属性。如果改变的是影响布局信息的属性（如宽度、⾼度、边距等），则会触发重排；如果改变的是只影响外观的属性（如颜⾊、透明度等），则只会触发重绘。⼀般来说，CSS 的 transform 和 opacity 属性在动画中不会触发重排，性能较好。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    #box {
    width: 100px;
    height: 100px;
    background-color: red;
    transition: all 1s;
    transform: translateX(100px); /* 不会触发重排 */
    width: 200px; /* 会触发重排 */
    }
    .move {
    }
    .resize {
    }
    </style>
</head>
<body>
    <div id="box"></div>
    <button onclick="moveBox()">Move Box</button>
    <button onclick="resizeBox()">Resize Box</button>
    <script>
        function moveBox() {
            const box = document.getElementById('box');
            box.classList.add('move');
        }
        function resizeBox() {
            const box = document.getElementById('box');
            box.classList.add('resize');
        }
    </script>
</body>
</html>
<!--案例应⽤：在实现动画效果时，优先使⽤ transform 和 opacity 属性来创建动画，以提⾼性能。例如制作元素的移动、旋转、缩放等动画时，使⽤transform属性；制作淡⼊淡出效果时，使⽤ opacity 属性。-->
```

# 三、JS部分
## 1. 事件——冒泡、捕获、委托、⾃定义事件
### 1.1 事件流：捕获 → 目标 → 冒泡
- 事件流分三阶段：
> 捕获阶段（从 window → 根节点 → 目标父层级）
> 目标阶段
> 冒泡阶段（从目标 → 向上冒到 window）

```JavaScript
// 绑定事件时：
element.addEventListener('click', handler, true);  // 捕获
element.addEventListener('click', handler, false); // 冒泡（默认）
```
### 1.2 事件委托（Event Delegation）
- 利用事件冒泡，将子元素事件统一绑定到父元素上。
- 优点：
> 减少事件绑定数量，提高性能
> 动态元素也能响应事件
> 便于管理事件

```JavaScript
// 例子：
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log(e.target.innerText);
  }
});
```
### 1.3 自定义事件（CustomEvent）
```JavaScript
// 创建一个事件：
const event = new CustomEvent('myEvent', { detail: { id: 1 } });
element.dispatchEvent(event);
// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.id);
});
```
- 用途：组件通信，状态通知，解耦代码

## 2. DOM API
- 常用 DOM 操作：
```JavaScript
// 查找元素：
document.getElementById()
document.querySelector()
document.querySelectorAll()
document.getElementsByClassName()
document.getElementsByTagName()
// 创建与插入
document.createElement()
parent.appendChild()
parent.insertBefore()
parent.append()
element.innerHTML
// 删除
element.remove()
parent.removeChild()
// 属性
element.getAttribute()
element.setAttribute()
element.dataset
// 样式
element.style
window.getComputedStyle()
// 节点关系
element.parentNode
element.children
element.nextElementSibling
// 尺寸与位置
element.getBoundingClientRect()
element.offsetWidth / offsetHeight
element.scrollTop
```

## 3. this、原型链
### 3.1 this的绑定规则，this 由 调用方式 决定：

| 情况              | this 指向                  |
| --------------- | ------------------------ |
| 作为对象方法调用        | 该对象                      |
| 普通函数调用          | window / undefined（严格模式） |
| 构造函数            | 实例对象                     |
| bind/call/apply | 显式绑定的值                   |
| 箭头函数            | 外层作用域的 this（无法被修改）       |

- 一句话总结：箭头函数的 this = 定义时的外层作用域，不会变。

### 3.2 原型与原型链
> 每个对象都有一个隐藏属性：__proto__
> 每个函数都有一个属性：prototype

```JavaScript
// 关系图（最常问）
obj → __proto__ → Object.prototype → null
fn  → __proto__ → Function.prototype → Object.prototype
```

- 原型链查找规则，访问属性时：
> 先查对象自身
> 找不到往原型链上查
> 一直到 Object.prototype
> 再到 null 停止

## 4. 数据类型转换
- JS 有 显示转换 和 隐式转换。
```JavaScript
// 显示转换
String(123)  → "123"
Number("123") → 123
Boolean(0) → false
parseInt("12px") → 12
parseFloat("3.14") → 3.14
```
- 隐式转换：主要发生在 +, ==, 比较运算、if 判断中
```JavaScript
// + 运算符，若其中一项为字符串 → 转成字符串拼接，否则 → 转成数字
1 + '2' = '12'
'2' - 1 = 1

// ==（宽松等于）规则，最重要规则：
null == undefined   // true
但 null != 0
// 对象与原始类型比较时：对象先转成原始类型（valueOf → toString）,例如：
[1] == 1  // true
[] == 0   // true
[] == ''  // true
```
-  Boolean 真假值判断
```JavaScript
// 假值（6个）：
false
0
''//（空字符串）
null
undefined
NaN
// 其余都是真值，包括：[]、{}、"0"、"false"
```

## 5. 为什么通过getElementsByClassName获取的元素集合⽆法直接forEach
- 原因：getElementsByClassName 返回的是 HTMLCollection，不是数组。
- HTMLCollection 的特点：
> 是类数组，但 不是数组
> 没有 forEach 方法
> 是动态集合（会自动更新）

- 证明： typeof document.getElementsByClassName('xx')  // object
- 解决方式
```JavaScript
// 转成数组
Array.from(collection).forEach(...)
// 使用扩展运算符
[...collection].forEach(...)
// 直接使用for
for (let i = 0; i < collection.length; i++) { ... }
```
- 改用 querySelectorAll：因为它返回的是 NodeList，天然就有 forEach。

## 6. event loop
- Event Loop（事件循环）是 JavaScript 的执⾏机制，⽤于处理异步操作。JavaScript 是单线程的，为了处理异步任务（如定时器、⽹络请求等），引⼊了事件循环机制。它的核⼼包括调⽤栈（Call Stack）、任务队列（Task Queue，分为宏任务队列和微任务队列）。当调⽤栈中的同步任务执⾏完后，事件循环会不断从任务队列中取出任务放⼊调⽤栈执⾏。
```javascript
console.log('Start');
setTimeout(() => {console.log('Timeout')}, 0);
Promise.resolve().then(() => { console.log('Promise');});
console.log('End');
```
- 代码细节：⾸先， console.log('Start') 是同步任务，直接在调⽤栈执⾏并输出。 setTimeout 是宏任务，会在 0 毫秒后将回调函数放⼊宏任务队列。 Promise.resolve().then() 是微任务，会将回调函数放⼊微任务队列。 console.log('End') 也是同步任务，接着执⾏。当调⽤栈为空时，事件循环会先处理微任务队列中的任务，所以输出 Promise ，然后处理宏任务队列中的任务，输出 Timeout 。
- 案例应⽤：在处理异步操作时，如⽹络请求、定时器等，事件循环机制确保了代码的执⾏顺序和异步任务的处理。例如在前端开发中，使⽤ fetch 进⾏⽹络请求，请求完成后的回调函数会通过事件循环机制在合适的时机执⾏。

## 7. 事件循环代码输出
```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
    async function async2() {
        console.log('async2');
    }
}
console.log('setTimeout');
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve) => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});
console.log('script end');
```
- 同样基于事件循环机制，分析代码中同步任务、微任务和宏任务的执⾏顺序。 async/await 本质上是基于 Promise 的语法糖， await 会暂停当前函数的执⾏，等待后⾯的 Promise 完成。
- 代码细节：
  - i. ⾸先执⾏同步任务，输出 script start。 
  - ii. setTimeout 是宏任务，将回调函数放⼊宏任务队列。 
  - iii. 调⽤ async1 函数，输出 async1 start ，接着调⽤ async2 函数，输出async2。 await async2() 暂停 async1 函数的执⾏。 
  - iv. 执⾏ new Promise ，输出 promise1， resolve() 后将 then 回调放⼊微任务队列。 
  - v. 输出 script end ，此时调⽤栈为空。 
  - vi. 处理微任务队列，先执⾏ async1 函数中 await 后⾯的代码，输出 async1 end ，再执⾏ Promise 的 then 回调，输出 promise2。 
  - vii. 处理宏任务队列，输出 setTimeout 。
- 案例应⽤：理解事件循环代码输出顺序有助于调试和优化涉及异步操作的代码，避免出现意外的执⾏顺序问题。

## 8. 平时是怎么发异步请求的
- 在前端开发中，常⻅的发送异步请求的⽅式有 XMLHttpRequest、 fetchAPI 和第三⽅库如 axios 。这些⽅式都是基于浏览器的⽹络请求能⼒，通过异步操作获取服务器数据，避免阻塞主线程。
- 代码案例（使⽤ fetch ）：
```javascript
fetch('https://api.example.com/data').then(response => {
if (!response.ok) {
    throw new Error('Network response was not ok');
}
    return response.json();
}).then(data => {console.log('Data:', data);})
.catch(error => {console.error('Error:', error)})
```
- 代码细节： fetch 函数返回⼀个 Promise ，它接收⼀个 URL 作为参数。第⼀个 then ⽅法处理响应对象，检查响应状态是否正常，若正常则将响应数据解析为JSON。第⼆个 then ⽅法处理解析后的数据。 catch ⽅法捕获请求过程中出现的错误。
- 案例应⽤：在开发中，当需要从服务器获取数据时，如获取⽤户信息、商品列表等，可使⽤上述⽅法发送异步请求。

## 9. 事件循环你是怎么⽤的
- 事件循环主要⽤于处理异步任务，合理利⽤事件循环机制可以优化代码性能和实现复杂的异步逻辑。例如，将⼀些耗时的操作放在异步任务中，避免阻塞主线程。
```javascript
function longRunningTask() {
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += i;
}}
return sum;
// 使⽤ setTimeout 将耗时任务放⼊宏任务队列
setTimeout(() => {
    const result = longRunningTask();
    console.log('Task result:', result);
}, 0);
console.log('Main thread continues...');
```
- 代码细节： longRunningTask 是⼀个耗时的计算任务。使⽤ setTimeout 将其放⼊宏任务队列，主线程可以继续执⾏后续代码，输出 Main thread continues... 。当调⽤栈为空时，事件循环会从宏任务队列中取出longRunningTask 并执⾏。
- 案例应⽤：在前端开发中，对于⼀些复杂的计算、⼤数据处理等耗时操作，可利⽤事件循环将其异步化，避免⻚⾯卡顿。

## 10.防抖节流的作⽤
- 防抖（Debounce）和节流（Throttle）是两种优化⾼频触发事件的技术。防抖是指在⼀定时间内，只有最后⼀次触发事件才会执⾏回调函数；节流是指在⼀定时间内，只执⾏⼀次回调函数。
- 防抖是在⼀定时间内只有最后⼀次触发事件才执⾏回调，节流是在⼀定时间内只执⾏⼀次回调。
```javascript
// 防抖
function debounce(func, delay) {
    let timer = null;
return function () {
    const context = this;
    const args = arguments;
    if (timer) {clearTimeout(timer);}
    timer = setTimeout(() => {
        func.apply(context, args);
    }, delay);
};
}
function search() {console.log('Searching...'); }
const debouncedSearch = debounce(search, 300);
const input = document.getElementById('search-input');
input.addEventListener('input', debouncedSearch);
//节流
function throttle(func, delay) {
    let timer = null;
    return function () {
        if (!timer) {
            const context = this;
            const args = arguments;
            func.apply(context, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    };
}
function scrollHandler() {console.log('Scrolling...');}
const throttledScroll = throttle(scrollHandler, 500);
window.addEventListener('scroll', throttledScroll);
```
- 代码细节：防抖函数通过 setTimeout 和 clearTimeout 来控制回调函数的执⾏，每次触发事件时都会清除之前的定时器，重新计时。节流函数通过⼀个定时器来控制回调函数的执⾏频率，在定时器存在时不执⾏回调函数。
- 案例应⽤：防抖适⽤于搜索框输⼊联想、窗⼝⼤⼩调整等场景，避免频繁触发事件导致性能问题。节流适⽤于滚动加载、按钮点击等场景，控制事件的触发频率。
- 防抖使⽤场景分析：
  - 搜索框输⼊联想：当⽤户在搜索框输⼊内容时，不需要每次输⼊⼀个字符就发起请求，⽽是等⽤户停⽌输⼊⼀段时间后再发起请求，减少不必要的
    请求次数。 
  - 窗⼝⼤⼩调整：当窗⼝⼤⼩改变时，不需要每次⼤⼩变化都触发重新布局等操作，等⽤户停⽌调整⼀段时间后再进⾏处理。
- 节流
  - 滚动加载：在⻚⾯滚动时，不需要每次滚动都去检查是否需要加载更多数据，⽽是每隔⼀段时间检查⼀次，避免频繁触发加载操作。 
  - 按钮点击：对于⼀些防⽌⽤户重复点击的按钮，⽐如提交表单按钮，使⽤节流可以确保在⼀定时间内只响应⼀次点击事件。

## 11. js 写⼀下保留两位⼩数
- 在 JavaScript 中，可以使⽤ toFixed() ⽅法或数学计算来实现保留两位⼩数的功能。 toFixed() ⽅法会将数字转换为字符串，并按照指定的⼩数位数进⾏四舍五⼊。
```javascript
// 使⽤ toFixed() ⽅法
const num = 3.14159;
const result = num.toFixed(2);
console.log(result); // 输出: "3.14"
// 数学计算方法
const num = 3.14159;
const result = Math.round(num * 100) / 100;
console.log(result); // 输出: 3.14
```
- 代码细节： toFixed(2) 直接将数字转换为保留两位⼩数的字符串。数学计算⽅法先将数字乘以 100，然后使⽤ Math.round() 进⾏四舍五⼊，最后再除以 100 得到保留两位⼩数的结果。 
- 案例应⽤：在处理货币⾦额、统计数据等需要精确到⼩数点后两位的场景中使⽤。

## 12. 合并区间
- 合并区间问题通常是给定⼀个包含多个区间的数组，需要将重叠的区间合并为⼀个区间。可以先对区间数组按照区间的起始位置进⾏排序，然后遍历数组，合并重叠的区间。
```javascript
function merge(intervals) {
    if (intervals.length <= 1) return intervals;
    intervals.sort((a, b) => a[0] - b[0]);
    const result = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = result[result.length - 1];
        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            result.push(current);
        }
    }
    return result;
}
const intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
const mergedIntervals = merge(intervals);
console.log(mergedIntervals); // 输出: [[1, 6], [8, 10], [15, 18]]
```
- 代码细节：⾸先对区间数组进⾏排序，确保区间按起始位置从⼩到⼤排列。然后遍历数组，⽐较当前区间和结果数组中最后⼀个区间是否重叠，如果重叠则合并，否则将当前区间添加到结果数组中。 
- 案例应⽤：在⽇程安排、时间管理等场景中，合并重叠的时间区间可以更清晰地展示可⽤时间。

## 13. 常⻅的数据结构的特点
- 常⻅的数据结构包括数组、链表、栈、队列、树、图等，每种数据结构都有其独特的特点和适⽤场景。
```javascript
// 数组
const array = [1, 2, 3, 4, 5];
// 链表节点类
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}
const node1 = new ListNode(1);
const node2 = new ListNode(2);
node1.next = node2;
// 栈
class Stack {
    constructor() {
        this.items = [];
    }
    push(item) {
        this.items.push(item);
    }
    pop() {
        return this.items.pop();
    }
}
const stack = new Stack();
stack.push(1);
stack.push(2);
console.log(stack.pop()); // 输出: 2
// 队列
class Queue {
    constructor() {
        this.items 
    }
    enqueue(item) {
        this.items.push(item);
    }
    dequeue() {
        return this.items.shift();
    }
}
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
console.log(queue.dequeue()); // 输出: 1
```
- 代码细节：数组是⼀种线性数据结构，⽀持随机访问，通过下标可以快速访问元素。链表是由节点组成的线性数据结构，每个节点包含数据和指向下⼀个节点的指针，插⼊和删除操作效率⾼。栈是⼀种后进先出（LIFO）的数据结构，只能在栈顶进⾏插⼊和删除操作。队列是⼀种先进先出（FIFO）的数据结构，在队尾插⼊元素，在队头删除元素。
- 案例应⽤：数组适⽤于需要随机访问元素的场景，如排序算法。链表适⽤于频繁插⼊和删除元素的场景，如实现栈和队列。栈适⽤于函数调⽤栈、浏览器历史记录等场景。队列适⽤于任务调度、消息队列等场景。

## 14. 设计模式-单例模式
- 设计模式是指在软件开发过程中，针对反复出现的问题所总结归纳出的通⽤解决⽅案。常⻅的设计模式包括单例模式、⼯⼚模式、观察者模式、装饰器模式等。
```javascript
// 单例模式
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            this.data = [];
            Singleton.instance = this;
        }
        return Singleton.instance;
    }
    addItem(item) {
        this.data.push(item);
    }
    getData() {
        return this.data;
    }
}
const instance1 = new Singleton();
const instance2 = new Singleton();
instance1.addItem('Item 1');
console.log(instance2.getData()); // 输出: ['Item 1']
```
- 代码细节：单例模式确保⼀个类只有⼀个实例，并提供⼀个全局访问点。在Singleton 类的构造函数中，检查是否已经存在实例，如果不存在则创建⼀个新 实例，否则返回已有的实例。 
- 案例应⽤：单例模式适⽤于需要确保只有⼀个实例的场景，如数据库连接池、⽇志记录器等。⼯⼚模式适⽤于根据不同的条件创建不同类型的对象。观察者模式适⽤于对象之间的⼀对多依赖关系，当⼀个对象的状态发⽣变化时，所有依赖它的对象都会得到通知。

## 15. 观察者模式
- 观察者模式定义了⼀种⼀对多的依赖关系，当⼀个对象（主题）的状态发⽣变化时，所有依赖它的对象（观察者）都会得到通知并⾃动更新。
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }
    addObserver(observer) {
        this.observers.push(observer);
    }
    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index!== -1) {
            this.observers.splice(index, 1);
        }
        
    }
    notify() {
        this.observers.forEach(observer => observer.update());
    }
    setState(newState) {
        this.state = newState;
        this.notify();
    }
}
class Observer {
    constructor(subject) {
        this.subject = subject;
        this.subject.addObserver(this);
    }
    update() {
        console.log(`Observer updated with state:${this.subject.state}`);
    }
}
const subject = new Subject();
const observer1 = new Observer(subject);
const observer2 = new Observer(subject);
subject.setState('New state');
```
- 代码细节： Subject 类表示主题，包含⼀个观察者数组，提供添加、移除观察者和通知观察者的⽅法。 Observer 类表示观察者，在构造函数中注册到主题上，并实现 update ⽅法⽤于接收主题的通知。 
- 案例应⽤：在前端开发中，观察者模式常⽤于实现事件系统、状态管理库等。例如，当⼀个组件的状态发⽣变化时，通知其他依赖该组件的组件进⾏更新。

## 16. 【代码】实现⼀个 call 改变 this 指向
-  call ⽅法⽤于调⽤⼀个函数，并指定该函数内部的 this 值。可以通过将函数挂载到指定的对象上，然后调⽤该对象的⽅法来实现 this 指向的改变。
```javascript
Function.prototype.myCall = function (context = window, ...args) {
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;
    const result = context[fnSymbol](...args);
    delete context[fnSymbol];
    return result;
};
function greet(message) {
    console.log(`${message}, ${this.name}`);
}
const person = { name: 'John' };
greet.myCall(person, 'Hello'); // 输出: Hello, John
```
- 代码细节：在 Function.prototype 上添加 myCall ⽅法，将调⽤ myCall 的函数挂载到 context 对象上，使⽤ Symbol 作为属性名避免冲突。调⽤该属性并传⼊参数，最后删除该属性并返回结果。 
- 案例应⽤：在需要动态改变函数 this 指向的场景中使⽤，如在回调函数中使⽤特定对象的⽅法。

## 17. 【代码】实现⼀个 promise.all
-  Promise.all ⽅法接收⼀个可迭代对象（通常是数组），该数组中的每个元素都是⼀个 Promise 对象，返回⼀个新的 Promise 。当所有输⼊的 Promise都成功完成时，新的 Promise 会以⼀个包含所有结果的数组进⾏ resolve ；如果其中任何⼀个 Promise 被 reject ，新的 Promise 会⽴即以该错误进⾏reject。
```javascript
function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('Expected an array'));
        }
        const results = [];
        let completedCount = 0;
        if (promises.length === 0) {
            return resolve(results);
        }
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                results[index] = result;
                completedCount++;
                if (completedCount === promises.length) {
                    resolve(results);
                }
            
        }).catch(error => {
            reject(error);
            });
        });
    });
}
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

promiseAll([promise1, promise2, promise3]).then(results => {
    console.log(results); // 输出: [1, 2, 3]
}).catch(error => {
    console.error(error);
});
```
- 代码细节：⾸先检查传⼊的 promises 是否为数组，若不是则 reject 。创建⼀个结果数组和⼀个计数器，遍历 promises 数组，使⽤ Promise.resolve 确保每个元素都是 Promise 对象。当⼀个 Promise 成功完成时，将结果存⼊结果数组，计数器加 1，当计数器等于数组⻓度时， resolve 结果数组。若有⼀个Promise 被 reject ，则⽴即 reject 整个 Promise 。 
- 案例应⽤：在需要同时处理多个异步任务，并且需要等待所有任务都完成后再进⾏下⼀步操作的场景中使⽤，如批量请求数据。

## 18. 实现 promise any ⽅法 和 once ⽅法？
- Promise.any 实现：Promise.any 接收⼀个可迭代对象，返回⼀个新的 Promise 。当可迭代对象中的任何⼀个 Promise 成功完成时，新的 Promise 会以该 Promise的结果进⾏ resolve ；如果所有 Promise 都被 reject ，则新的 Promise会以⼀个包含所有错误的 AggregateError 进⾏ reject。
```javascript
Promise.myAny = function (promises) {
    return new Promise((resolve, reject) => {
        const errors = [];
        let rejectedCount = 0
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                resolve(result);
            }).catch(error => {
                errors[index] = error;
                rejectedCount++;
            if (rejectedCount === promises.length) {
                reject(new AggregateError(errors, 'All promises were rejected'));
            }
        });
    });
});
};
const promise1 = Promise.reject(new Error('Error 1'));
const promise2 = Promise.resolve('Success');
const promise3 = Promise.reject(new Error('Error 2'));
Promise.myAny([promise1, promise2, promise3]).then(result => {
    console.log(result); // 输出: Success
}).catch(error => {console.error(error);});
// 代码细节
// 1. 遍历 `promises` 数组，使⽤ `Promise.resolve` 确保每个元素都是`Promise` 对象。
// 2. 当有⼀个 `Promise` 成功时，⽴即 `resolve` 该结果。
// 3. 当所有 `Promise` 都被 `reject` 时，`reject` ⼀个包含所有错误的`AggregateError`。
```
- once ⽅法实现：once ⽅法⽤于确保⼀个函数只执⾏⼀次。可以通过闭包来实现，在函数内部记录函数是否已经执⾏过。
```javascript
function once(func) {
    let hasBeenCalled = false;
    let result;
    return function (...args) {
        if (!hasBeenCalled) {
            result = func.apply(this, args);
            hasBeenCalled = true;
        }
        return result;
    };
}
function greet() {console.log('Hello!');}
// 代码细节
// 1. 使⽤闭包变量 `hasBeenCalled` 记录函数是否已经执⾏过。
// 2. 第⼀次调⽤时执⾏函数并记录结果，将 `hasBeenCalled` 设为 `true`，后续调⽤直接返回第⼀次的结果。
```
- 案例应⽤： Promise.any 适⽤于多个异步任务，只要有⼀个成功就可以继续后续操作的场景； once ⽅法适⽤于只需要执⾏⼀次的初始化操作等场景。

# 四、HTTP部分
1. 常⻅状态码
- 2xx（成功）
> 200 OK：请求成功
> 201 Created：资源已创建（一般用于 POST）
> 3xx（重定向）

- 301 Moved Permanently：永久重定向
> 302 Found：临时重定向
> 304 Not Modified：使用缓存（协商缓存命中）

- 4xx（客户端错误）
> 400 Bad Request：请求参数问题
> 401 Unauthorized：未认证
> 403 Forbidden：已认证但权限不足
> 404 Not Found：资源不存在
> 429 Too Many Requests：请求太频繁（限流）

- 5xx（服务端错误）
> 500 Internal Server Error
> 502 Bad Gateway
> 503 Service Unavailable：服务不可用
> 504 Gateway Timeout

2. 301、302、304
- 301 永久重定向
> 告诉浏览器资源永久移动到新地址
> 浏览器会缓存重定向结果
> SEO 中会将权重转移到新地址

- 302 临时重定向
> 暂时跳到新地址
> 浏览器不会缓存
> 常用于登录跳转、临时调整

- 304 Not Modified
> 协商缓存生效
> 服务器告诉浏览器：你缓存的资源没变
> 浏览器直接读取本地缓存
> 触发条件：If-Modified-Since / If-None-Match

| 状态码 | 场景     | 是否重新下载资源   |
| --- | ------ | ---------- |
| 301 | 永久重定向  | 会          |
| 302 | 临时重定向  | 会          |
| 304 | 协商缓存命中 | **不会**下载资源 |

3. 常⻅的请求method
| Method  | 作用         | 是否安全 | 是否幂等 |
| ------- | ---------- | ---- | ---- |
| GET     | 获取数据       | ✔    | ✔    |
| POST    | 创建/提交数据    | ✘    | ✘    |
| PUT     | 更新资源（整体更新） | ✘    | ✔    |
| PATCH   | 局部更新       | ✘    | ✘    |
| DELETE  | 删除资源       | ✘    | ✔    |
| HEAD    | 获取响应头      | ✔    | ✔    |
| OPTIONS | 预检请求       | ✔    | ✔    |

4. 跨域问题：浏览器的 同源策略 导致：协议、域名、端口不同即跨域。
**解决跨域的方式**
- 1. 服务端 CORS（最常用）
```java
// 服务器设置：
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Access-Control-Allow-Methods: *
```
- 2. Nginx 反向代理：前端访问同域的 nginx，由 nginx 代理转发。
- 3. JSONP（只支持 GET）
- 4. WebSocket（不受同源策略限制）
- 5. 跨域资源共享 iframe 通信（postMessage）

5. session和cookie是如何⼯作的？
- Cookie
> 存储在浏览器
> 会自动随请求携带到同域服务器
> 一般用于：登录状态 token、偏好设置

- Session
> 存储在服务器
> 浏览器通过 cookie 中的 sessionId 来标识用户

- 工作流程：
> 用户第一次访问服务器
> 服务器创建 session，在 server 保存（如内存/Redis）
> 服务端返回 Set-Cookie: sessionId=xxxx
> 浏览器保存 cookie
> 下次请求自动带上 sessionId
> 服务器通过 sessionId 找到当前用户的数据

- 本质：
> Cookie 存 sessionId，Session 存用户数据
> 两者配合实现登录状态。

6. CDN
- 作用：
> 加速访问（就近节点返回资源）
> 减少源站压力
> 防止 DDoS
> 资源缓存提升加载速度

**补充DDos**
> **1. 什么是 DDoS？**
> > DDoS（Distributed Denial of Service）分布式拒绝服务攻击
> > 攻击者控制大量肉鸡设备（服务器、主机、IoT 设备等），向目标服务器同时发起大量无意义的请求，占满带宽、耗尽计算资源，使其：
> > 无法处理正常请求
> > CPU/带宽被打满
> > 服务瘫痪、宕机
> 一句话：
> > 用海量流量淹没目标，让它无法提供服务。
> **2. 常见 DDoS 攻击类型**
> ① 流量型攻击（最常见）
> > 用巨量带宽攻击目标，典型如：
> > UDP Flood
> > ICMP Flood（Ping Flood）
> > DNS Amplification（放大攻击）
> 目标：耗尽网络带宽
> ② 协议型攻击
> 利用协议缺陷，占用服务器资源：
> > SYN Flood（半连接攻击）
> > ACK Flood
> > TCP Slowloris
> 目标：耗尽服务器连接数、CPU
> ③ 应用层攻击
> 模拟真实请求，但大量消耗后端业务资源：
> > HTTP Flood（模拟真实浏览器访问）
> > CC 攻击
> 目标：耗尽应用服务器处理能力
> **3. DDoS 攻击的特点**
> 流量巨大（几十 G、几百 G、甚至 Tb 级别）
> 来源广泛（僵尸网络）
> 难以直接阻断
> 攻击成本低、防护成本高
> **4. 如何防御 DDoS？（面试高频）**
> ① CDN / 高防节点 / 云清洗
> > CDN 节点分担流量
> > 高防 IP 提供流量清洗
> > 将恶意流量在边缘拦截
> ② 限流、熔断、验证码
> > 限制同一 IP 请求次数
> > 出现异常访问就触发熔断
> > 验证码阻挡自动化请求
> ③ 防火墙 / WAF
> > 根据规则过滤恶意协议包
> > 阻挡常见攻击（SYN、UDP flood）
> ④ 隔离节点 / 分布式部署
> > 多区域部署，分散攻击压力
> ⑤ 黑洞路由（最后手段）
> > 直接丢弃所有到该 IP 的流量（服务暂时不可用）。
> 一句话总结（面试官爱听版）
> > DDoS 是利用大量设备并发向目标发起无意义请求，耗尽带宽和资源，使服务不可用。
> > 防御主要依赖 CDN + 高防清洗 + 限流 + WAF。

- 
> 用户访问资源 → DNS 将域名解析到 最近的 CDN 节点
> 如果节点有缓存 → 直接返回
> 如果没有 → 回源服务器获取并缓存

- 一句话总结：CDN = 离用户最近的服务器负责返回静态资源。

7. 强缓存与协商缓存
- 强缓存（不会发送请求）
```java
// 响应头中包含：
Cache-Control: max-age=3600
Expires: xxx
```
> 效果
> - 在有效期内，浏览器直接读本地缓存
> - 状态码：200（from cache）

- 协商缓存（会发送请求）
```java
// 请求头：
If-Modified-Since
If-None-Match
// 响应头
Last-Modified
ETag
```
- 流程：
> 浏览器带上条件请求
> 服务端判断资源是否更新
> 如果未更新 → 返回 304

- 区别总结
| 类型   | 是否发请求 | 典型状态码           |
| ---- | ----- | --------------- |
| 强缓存  | ❌ 不发  | 200（from cache） |
| 协商缓存 | ✔ 发   | 304             |

8. fetch和XMLHttpRequest的区别
- 1. API 设计现代
```javascript
// fetch 是 Promise 设计，更简洁：
fetch('/api').then()
// XHR
const xhr = new XMLHttpRequest();
xhr.open();
xhr.send();
```
- 2. 默认不带cookie
```javascript
// fetch
fetch(url, { credentials: 'include' })
// XHR同源时，默认带cookie
```
- 3. 不支持同步请求：XHR 支持同步（已被废弃），fetch 不支持同步。
- 4. 错误处理不同
```javascript
// fetch 只会对网络错误 reject，
// HTTP 错误不会抛错，需要自己判断：
if (!res.ok) { ... }
```
- 5. 支持流（stream）读取:fetch 可以分块读取大文件（如视频）。
- 总结一句话：
| 功能     | fetch       | XHR     |
| ------ | ----------- | ------- |
| 风格     | Promise，更现代 | 回调地狱    |
| Cookie | 默认不带        | 默认带     |
| 同步     | ❌           | ✔（但不推荐） |
| 流式处理   | ✔           | ✘       |
| 兼容性    | 中等          | 极好      |

# 五、Web安全
1. SQL注⼊（SQL Injection）
**是什么？**
> 攻击者通过向输入字段（URL、表单、Header）提交 恶意 SQL 语句，导致服务器拼接 SQL 时被篡改，最终可能：
> > 数据泄露
> > 数据篡改
> > 数据删除
> > 获取 root 权限

- 例子（典型注入）：
```sql
SELECT * FROM users WHERE username = '${input}'
```
- 攻击输入：
```vbnet
' OR 1=1 --
```
- 执行结果变成
```sql
SELECT * FROM users WHERE username = '' OR 1=1 --'
```
**如何防御？**
- 使用 预编译（Prepared Statement）（最有效）
```sql
SELECT * FROM users WHERE username = ?
```
- 严格参数化查询
> 框架 ORM（Sequelize、Hibernate）默认支持。

- 过滤/转义特殊字符
> 如 ', ", --, ;

- 最小权限原则
> 数据库用户只给必须的权限。

- WAF（Web Application Firewall）
> 自动拦截恶意 SQL 语句。

2. XSS攻击
**是什么？**
> 攻击者将恶意脚本注入页面，让浏览器执行，可能：
> > 盗取 cookie
> > 获取用户信息
> > 冒充用户操作
> > 页面篡改

**XSS 类型**
- ① 反射型 XSS（最常见）
> 恶意脚本通过URL注入

- 存储型 XSS（最危险）
> 恶意代码存到 DB，每次访问都会执行。

- ③ DOM 型 XSS
> 攻击点发生在前端 JS 内部。

**如何防御**
- 对输出内容做 HTML 转义（最关键）
```php
< → &lt;  
> → &gt;  
" → &quot;  
' → &#39;
```
- 架一般自带转义：React、Vue 默认是安全的。
-  CSP（Content-Security-Policy）,制脚本来源：
```php
Content-Security-Policy: default-src 'self'
```
- 禁止直接拼接 HTML,使用 innerHTML，改用：textContent
- 对用户输入进行过滤、校验
- HttpOnly Cookie（防止被读取）

3. 请求伪造（CSRF / XSRF）
**是什么**
> 击者诱导用户点击恶意链接，使浏览器在用户不知情的情况下发出请求（带 Cookie），从而完成敏感操作。
> 比如：转账、修改密码。
> 核心点：
> > CSRF 利用了浏览器会自动携带 Cookie 的机制。

**如何防御**
- ① Token（CSRF Token）—— 最有效
> 服务端生成 token，页面提交时必须携带。
> 攻击者无法获取 token。

- ② SameSite Cookie 设置
> 阻止跨站请求自动带上 cookie：

```javascript
Set-Cookie: sessionId=xxx; SameSite=Lax
```
> 选项：
> > Lax：大部分场景安全
> > Strict：最安全（完全不允许跨站）
> > None + Secure：允许跨站（要 HTTPS）

- ③ Referer / Origin 验证:服务器检查请求来源是否合法。
- 用户操作增加验证码 / 二次确认

4. jwt（JSON Web Token）
**是什么**
> 一种前后端分离中常用的 无状态身份认证方式。
> JWT 由三部分组成（用点分隔）：
> ```css
> header.payload.signature
> ```

- ① Header（头部）声明算法：
```json
{ "alg": "HS256", "typ": "JWT" }
```
- ② Payload（负载）:存用户信息、过期时间：
```json
{ "userId": 1, "exp": 1700000000 }
```
- ③ Signature（签名）使用密钥生成，防篡改：
```scss
HMACSHA256(header + payload, secret)
```
**JWT工作流程**
- 用户登录成功，服务器生成 JWT 返回给前端
- 前端保存 JWT（localStorage / cookie）
- 后续请求在 Header 中携带：Authorization: Bearer \<token>
- 服务器验证签名 → 解析用户信息
- 不需要 Session，不维护服务端状态（无状态）
**JWT的优点**
- 无状态，后端不需要存储 session（适合分布式）
- 前后端分离非常方便
- 可以跨服务验证（微服务常用）
**JWT的缺点**
- 不能主动失效（除非维护黑名单）
- token 一旦泄露，风险极高
- 不适合存放敏感信息（payload 只是 Base64，不加密）
- 较大（比 sessionId 更占带宽）
**JWT 的安全性注意事项**
- ✔ 设置 短过期时间
- ✔ 搭配 Refresh Token
- ✔ 使用 HTTPS
- ✔ 不要把 JWT 放在 localStorage（容易被 XSS 偷走）
- ✔ 可以放在 HttpOnly Cookie 中提高安全性

5. 浏览器从输⼊⽹址到⻚⾯呈现发⽣了什么？
- 1. 用户输入 URL / 按回车：浏览器拿到一个字符串（例如 https://example.com/path），开始解析成各部分（协议、主机、端口、路径、查询、fragment）。
- 2. 存 / 预连接：浏览器会先查本地缓存（DNS 缓存、HTTP 缓存、HSTS、Service Worker、connection pool）。如果资源可用且命中强缓存，可能直接从本地返回并跳过网络请求。
- 3. DNS 解析（把域名解析为 IP）
> 浏览器先查本地 DNS 缓存 → OS 缓存 → hosts 文件 → 发起 DNS 请求到 DNS 服务器。
> 这一步可能被 CDN 或 DNS 负载均衡影响（返回最近节点 IP）。
> （优化点：DNS 缓存、DNS over HTTPS、prefetch）

- 4. 建立 TCP 连接（如果没有现成连接）
> 三次握手：SYN → SYN-ACK → ACK。
> HTTP/1.1 + keep-alive 会复用连接；HTTP/2 在一个连接上多路复用多个请求。

- 5. TLS 握手（如果是 HTTPS）
> 客户端/服务器协商加密算法、交换证书、验证证书、生成对称密钥（包括可能的会话复用 / 0-RTT 优化）。
> TLS 完成后数据加密传输。
> （优化点：TLS session resumption、OCSP stapling、HTTP/2、QUIC/HTTP3）

- 6. 发起 HTTP 请求：浏览器发送 HTTP 请求（包含 headers：Host、User-Agent、Accept、Cookie、If-Modified-Since/If-None-Match 等）。如果有 Service Worker，Service Worker 可以拦截请求并返回响应（缓存或自定义响应）。
- 7. 服务器处理并返回响应：服务器接收请求，处理（路由、后端逻辑、读取 DB、调用微服务等），返回响应头和响应体（HTML、或 301/302 重定向等）。（CDN、高防或缓存层可在此处命中并直接返回缓存内容）
- 8. 浏览器开始接收字节 —— HTML 开始解析（关键渲染路径开始）
> 当浏览器接收到 HTML 字节流时，会 边下载边解析（streaming parsing）：
> a. HTML 解析器：生成 Token → 构建 DOM 树（DOM）
> 浏览器把 HTML token 化，生成 DOM 节点并链接成 DOM 树。
> b. CSS 解析：下载 CSS（遇到 <link>）并构建 CSSOM（CSS Object Model）
> 遇到外部 CSS，会触发额外的请求（可并行下载）。CSSOM 与 DOM 共同用于后续渲染树构建。
> c. JavaScript 的影响（关键）
> 同步阻塞脚本（普通 <script>）：解析到 <script> 会暂停 HTML 解析 —— 浏览器必须先下载并执行脚本，脚本可能修改 DOM/CSSOM，因此解析被阻塞。
> defer：脚本并行下载，但在 HTML 解析完成后按顺序执行（不会阻塞解析）。
> async：并行下载，下载完成就执行（可能在解析中断），执行顺序不保证。
> 动态创建 <script>（appendChild）：默认 async 行为（不会阻塞）。
> Service Worker 可以拦截并直接提供内容，影响是否请求网络。
> （重点：JS 能修改 DOM/CSSOM，因此会阻塞渲染）

- 9. 构建 Render Tree（渲染树）：浏览器把 DOM 和 CSSOM 合并，构建 Render Tree（渲染树）：只包含需要被绘制的可见节点（例如 display:none 会被忽略），并计算每个节点的样式（resolved style）。
- 10. 布局（Reflow / Layout）：浏览器根据渲染树计算每个可见节点的几何尺寸和位置（即各元素的宽高、x/y）。这是一个代价较高的过程。（触发重排的操作：改 width/height、添加/移除 DOM、改变字体、改变 box-model 等）
- 11. 绘制（Paint）：将布局好的每个节点绘制成图层中的绘制命令（绘制文本、颜色、边框、阴影、图片等）。这一步称为 paint。
- 12. 合成（Compositing）现代浏览器会把页面拆成多个图层（layer），并交给 GPU 合成（特别是使用 transform, opacity, will-change 等会创建图层的属性）。合成阶段把图层合并到最终帧并呈现到屏幕。（涉及 GPU rasterization、合成顺序优化、图层缓存）
- 13. 首次绘制指标（可观测点）
> 浏览器在这过程中会记录关键性能指标（供 DevTools / 报表使用）：
> > FP（First Paint）：浏览器开始绘制的时间点。
> > FCP（First Contentful Paint）：首次绘制任何有意义内容（文本、图片等）。
> > LCP（Largest Contentful Paint）：最大可视内容绘制完成时间（用户感知重要指标）。
> > DOMContentLoaded：DOM 构建完成并解析完所有脚本（不等待样式/图片）。
> > load：页面所有资源（包括图片、iframe）加载完成。

- 14. JavaScript 执行与事件循环
> 页面渲染与 JS 执行并行但又相互影响：
> > 主线程负责解析 HTML/CSS、执行 JS、布局和绘制。长时间 JS 会阻塞渲染。
> > JS 的执行遵循事件循环（macrotasks、microtasks）。微任务（Promise.then）会在当前 macrotask 完结前执行，可能导致长时间锁主线程。
> > （优化点：避免主线程长任务、使用 Web Worker 做计算密集型任务）

- 15. 后续资源加载与渲染更新：图片、字体、视频等资源可能在初次布局后异步加载并触发 repaint 或 reflow（例如图片加载改变元素尺寸会触发 reflow）。浏览器会增量地重绘或合成受影响区域。
- 16. 浏览器缓存与条件请求：在后续访问中，浏览器会使用缓存策略（强缓存 / 协商缓存）。若使用协商缓存，会发送 If-Modified-Since / If-None-Match，服务端可返回 304 以节省带宽。
- 17. 交互阶段与生命周期事件
> DOMContentLoaded：DOM 构建完（同步脚本已执行完）。
> load：所有资源加载完。
> 可以监听 requestAnimationFrame 做动画，在下一帧渲染前执行回调。

- 额外补充：常见优化点（面试高频）
> 减少阻塞资源：把脚本放底部 / 使用 defer / async。
> Critical CSS：内联关键 CSS，延迟非关键 CSS。
> 预加载/预取：<link rel="preload">、prefetch、preconnect。
> 使用 CDN、启用 gzip/brotli、HTTP/2 或 HTTP/3（QUIC）。
> 开启缓存策略、合理使用 ETag/Last-Modified。
> 减少重排/重绘：合并 DOM 操作、使用 transform 代替 top/left、避免频繁读写 layout 属性。
> 使用 Service Worker 做离线缓存与路由拦截。
> 避免主线程阻塞：分割任务、使用 Web Worker。
> 按需创建合成图层，避免过多图层占用 GPU 内存。

- 短答题模版（面试时可念）
> “用户输入 URL 后，浏览器先做 DNS 解析、建立 TCP/TLS 连接，然后发 HTTP 请求。服务器返回 HTML，浏览器边下载边解析：构建 DOM、下载并解析 CSS（生成 CSSOM）、执行阻塞或非阻塞的 JS（影响解析），将 DOM+CSSOM 合并成渲染树，进行布局（reflow）、绘制（paint）、合成（composite）并把帧交给 GPU 呈现。期间还涉及缓存、CDN、Service Worker、HTTP/2 多路复用等优化点，最终触发 DOMContentLoaded/load 等事件。”


# 六、算法
## 1. 红绿灯
```javascript
function trafficLight() {
  const light = async (color, duration) => {
    console.log(color);
    await new Promise(resolve => setTimeout(resolve, duration));
  };
  
  const run = async () => {
    while (true) {
      await light('红灯', 3000);
      await light('绿灯', 2000);
      await light('黄灯', 1000);
    }
  };
  run();
}
```
## 2. 暂停函数
```javascript
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function run() {
  console.log(1);
  await sleep(1000);
  console.log(2);
}

```
## 3. 实现forEach
```javascript
Array.prototype.myForEach = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    callback.call(thisArg, this[i], i, this);
  }
};
```
## 4. 千位分隔符
```javascript
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
// 或者
function formatNumber(num) {
    return num.toLocaleString();
}
```
## 5. 扁平化数组
```javascript
// 方法1: 递归
function flatten(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
}
// 方法2: flat
const flatten = arr => arr.flat(Infinity);// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```
## 6. 斐波那契数列
```javascript
// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```
## 7. 分块数组
```javascript
function chunk(arr, size) {
  const result = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}
```
## 8. 数组分组
```javascript
function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const group = typeof key === 'function' ? key(item) : item[key];
    (acc[group] = acc[group] || []).push(item);
    return acc;
  }, {});
}
```
## 9. compose 复合函数
```javascript
// 从右到左执行
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 从左到右执行（pipe）
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
```
## 10. 根据id 合并2个数组
```javascript
function mergeById(arr1, arr2) {
  const map = new Map(arr1.map(item => [item.id, item]));
  arr2.forEach(item => {
    if (map.has(item.id)) {
      Object.assign(map.get(item.id), item);
    } else {
      map.set(item.id, item);
    }
  });
  return Array.from(map.values());
}
```
## 11. 归约reduce
```javascript
Array.prototype.myReduce = function(callback, initialValue) {
  let acc = initialValue !== undefined ? initialValue : this[0];
  let startIndex = initialValue !== undefined ? 0 : 1;
  
  for (let i = startIndex; i < this.length; i++) {
    acc = callback(acc, this[i], i, this);
  }
  return acc;
};
```
## 12. 记忆函数
```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}
```
## 13. 精简对象（移除假值）
```javascript
function compact(obj) {
  const result = {};
  for (let key in obj) {
    if (obj[key]) result[key] = obj[key];
  }
  return result;
}
```
## 14. 实现map
```javascript
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback.call(thisArg, this[i], i, this));
  }
  return result;
};
```
## 15. ⼿动实现 call
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};
```
## 16. 数组出现2次的数字（找重复项）
```javascript
function findDuplicates(arr) {
  const count = {};
  return arr.filter(item => {
    count[item] = (count[item] || 0) + 1;
    return count[item] === 2;
  });
}
```
## 17. 数组去重
```javascript
// 方法1: Set
const unique = arr => [...new Set(arr)];

// 方法2: filter
const unique = arr => arr.filter((item, index) => arr.indexOf(item) === index);
```
## 18. 蜗⽜排序（螺旋矩阵）
```javascript
// 输出 n×n 的螺旋矩阵：
function snail(n) {
  const res = Array.from({ length: n }, () => Array(n).fill(0));
  let num = 1, left = 0, right = n-1, top = 0, bottom = n-1;

  while (left <= right && top <= bottom) {
    for (let i = left; i <= right; i++) res[top][i] = num++;
    top++;
    for (let i = top; i <= bottom; i++) res[i][right] = num++;
    right--;
    for (let i = right; i >= left; i--) res[bottom][i] = num++;
    bottom--;
    for (let i = bottom; i >= top; i--) res[i][left] = num++;
    left++;
  }

  return res;
}

```
## 19. 冒泡排序
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```
## 20. 原型链继承
```javascript
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype); // 继承方法
Child.prototype.constructor = Child;
```
## 21. deepClone 深拷⻉
```javascript
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (map.has(obj)) return map.get(obj); // 处理循环引用
  
  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  return clone;
}
```
## 22. promise.all()
```javascript
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('参数必须是数组'));
    }
    
    const results = [];
    let count = 0;
    
    if (promises.length === 0) return resolve(results);
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        count++;
        if (count === promises.length) resolve(results);
      }).catch(reject);
    });
  });
};
```
## 23. 数组去重(有排序)：
```javascript
unique(arr, key)
{
  if (!arr) return arr
  if (key === undefined) return [...new Set(arr)]
  const map = {
    'string': e => e[key],
    'function': e => key(e),
  }
  const fn = map[typeof key]
  const obj = arr.reduce((o,e) => (o[fn(e)]=e, o), {})
  return Object.values(obj)
}
```
## 24. 数组元素偏移
- 实现数组元素偏移可以通过将数组的后 k 个元素移动到数组的前⾯。可以使⽤三次反转数组的⽅法来实现，先反转整个数组，再反转前 k 个元素，最后反转剩下的元素。
```javascript
function rotate(nums, k) {
    const n = nums.length;
    k = k % n
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
    [nums[start], nums[end]] = [nums[end], nums[start]];
    start++;
    end--;
}}

function rotate(nums, k) {
    const n = nums.length;
    k = k % n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
        [nums[start], nums[end]] = [nums[end], nums[start]];
        start++;
        end--;
    }
}
const nums = [1, 2, 3, 4, 5, 6, 7];
const k = 3;
const rotatedNums = rotate(nums, k);
console.log(rotatedNums); // 输出: [5, 6, 7, 1, 2, 3, 4]
```
- 代码细节
  - ⾸先计算 k 对数组⻓度 n 取模，避免 k ⼤于数组⻓度的情况。 
  - 第⼀次调⽤ reverse 函数反转整个数组。 
  - 第⼆次调⽤ reverse 函数反转数组的前 k 个元素。 
  - 第三次调⽤ reverse 函数反转数组中剩余的元素。 
- 案例应⽤：在处理循环数组、周期性数据等场景中会⽤到，⽐如实现⼀个时钟表盘上数字的循环滚动效果。

## 25. 数组拉平（flatten）
- 数组拉平是将嵌套数组转换为⼀维数组。可以使⽤递归的⽅式遍历数组，若元素是数组则继续递归处理，若元素是基本类型则添加到结果数组中。
```javascript
function flatten(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
            result.push(...flatten(arr[i]));
        } else {
            result.push(arr[i]);
        }
    }
    return result;
}
const nestedArray = [1, [2, [3, 4], 5], 6];
const flattenedArray = flatten(nestedArray);
console.log(flattenedArray); // 输出: [1, 2, 3, 4, 5, 6]
```
- 代码细节：
  - 创建⼀个空数组 result ⽤于存储拉平后的元素。
  - 遍历输⼊数组 arr ，若元素是数组，则递归调⽤ flatten 函数并将结果展开添加到 result 中；若元素不是数组，则直接添加到 result 中。
- 案例应⽤：在处理树形结构数据、多维矩阵转换等场景中会⽤到，⽐如将⼀个多级菜单的数据结构转换为⼀维列表。
# 七、移动端适配
1. 传统rem适配⽅案
- 核心原理
```JavaScript
// flexible.js 核心代码片段
document.documentElement.style.fontSize =
document.documentElement.clientWidth / 10 + 'px';
```
> rem：根元素字体⼤⼩的倍数单位（1rem = 根字体⼤⼩）
> 动态计算：通过JS实时计算屏幕宽度，设置 <html> 的 font-size
> 设计稿换算：使⽤PostCSS插件将设计稿像素转换为rem单位（如750px设计稿
1rem=75px）

- 实现流程
	1. 引⼊ lib-flexible 或⾃研动态计算脚本
	2. 使⽤PostCSS插件 postcss-pxtorem ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 75, // 设计稿宽度/10（750/10）
      propList: ['*'] // 转换所有属性
    }
  }
}
```
- 优势分析
> 兼容性好：⽀持到Android 4.4+ / iOS 6.1+
> 精细控制：通过JS可实现复杂逻辑（如区分横竖屏）
> 历史惯性：⽼项⽬维护⽅便

- 主要缺陷
> JS依赖：需要等待JS执⾏才能完成布局计算
> 缩放失真：某些Android机型存在rem计算精度问题
> 维护成本：需要维护两套单位系统（rem + px）

2. 现代vw/vh适配⽅案
- 核心原理
```css
/* 直接使⽤视⼝单位 */
.box {
  width: 50vw; /* 视⼝宽度的50% */
  height: 30vh; /* 视⼝⾼度的30% */
}
```
> vw：视⼝宽度百分⽐（1vw = 1%视⼝宽度）
> vh：视⼝⾼度百分⽐（1vh = 1%视⼝⾼度）
> ⽆需JS：纯CSS原⽣⽀持

- 实现流程
	1. 使⽤PostCSS插件 postcss-px-to-viewport ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 750, // 设计稿宽度
      unitPrecision: 5, // 转换精度
      viewportUnit: 'vw', // ⽬标单位
      selectorBlackList: ['.no-vw'], // 忽略类名
      minPixelValue: 1 // 最⼩转换像素
    }
  }
}
```
- 优势分析
> 原⽣⽀持：现代浏览器100%⽀持（包括iOS 8+/Android 4.4+）
> 渲染性能：避免JS计算导致的布局抖动
> 开发友好：设计稿直转vw，⽆需⼿动计算
> 响应灵敏：⾃动响应窗⼝⼤⼩变化

- 注意事项
> ⾼度适配：建议使⽤ vh 时配合 calc 计算安全区域
> 字体控制：可混合使⽤rem控制字体⼤⼩

```css
/* 混合⽅案示例 */
.title {
  font-size: 1.2rem; /* 使⽤rem保持⽂字可读性 */
  margin: 0 4vw; /* 使⽤vw保持间距响应 */
}
```
3. 方案对比决策
| 维度 | rem方案 | vw/vh方案 |
| - | - | - |
| 实现复杂度 | 需要JS + 构建工具 | 仅需构建工具 |
| 布局精度 | 存在0.01rem误差 | 精确到小数点后5位 |
| 渲染性能 | 存在JS执行延误 | 首屏渲染更快 |
| 维护成本 | 需维护动态计算逻辑 | 纯CSS配置 |
| 未来兼容性 | 逐渐淘汰 | CSS标准持续支持 |
4. 现在最佳实践
- 推荐方案：vw为主 + rem辅助
```css
/* 根元素设置（可选） */
:root {
	--base-font-size: calc(16px+ 0.5vw); /* 基础字体响应式 */
}
/* 混合使⽤示例 */
.container {
  width: 90vw;
  max-width: 750px; /* 桌⾯端限制最⼤宽度 */
}
.text {
	font-size: 1.2rem; /* 保持⽂字可读性 */
}
```

- 关键配置技巧
```css
/*安全区域适配：使⽤ env(safe-area-inset-*) */
body {
	padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* 1px边框解决⽅案：结合 transform + viewport */
.border-1px {
  position: relative;
  &::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #ddd;
    transform: scaleY(0.5);
    transform-origin: 0 0;
  }
}
```

- 构建工具配置
```JavaScript
// 现代工程化配置示例（Vue/React通用）
module.exports = {
  plugins: [
    require('postcss-px-to-viewport')({
    viewportWidth: 750 ,
    viewportUnit: 'vw',
    fontViewportUnit: 'rem', // 字体单独使用rem
    require('postcss-flexbugs-fixes'),
		require('postcss-viewport-units') // ⾃动添加兼容前缀
  ]
},
```
5. 升级迁移策略
- 渐进式迁移
```css
/*新⻚⾯直接使⽤vw⽅案*/
/*旧⻚⾯通过 @media 逐步替换*/
/* 兼容代码示例 */
.old-box {
  width: 10rem;
  @media (min-width: 320px) {
  	width: 50vw;
  }
}
```
- 降级处理
```css
.modern-box {
  width: 50vw;
  width: 10rem; /* 旧浏览器回退 */
}
```
- 监控覆盖：
```JavaScript
/*使⽤ Modernizr 检测浏览器⽀持*/
if (!Modernizr.cssvwunit) {
	loadScript('legacy-rem-polyfill.js');
}
```
6. 总结建议
- 新项⽬⾸选： vw/vh + postcss-px-to-viewport ⽅案
- ⽼项⽬维护：继续使⽤rem⽅案保持稳定
- 混合场景：核⼼布局⽤vw，字体/间距⽤rem
- 特殊需求：结合CSS容器查询（ @container ）实现更智能响应
> 现代浏览器对viewport单位的⽀持已⾮常成熟，拥抱CSS原⽣⽅案能获得更好的性能表
现和开发体验。对于需要兼容极旧浏览器的特殊项⽬（如政府/银⾏系统），可考虑保留rem⽅案作为兜底。

# 八、框架部分
## 1. usestate 和 useref 区别？- React
-  useState 和 useRef 是 React Hooks 中的两个钩⼦。 useState ⽤于在函数组件中添加状态，当状态更新时，组件会重新渲染。 useRef 创建⼀个可变的对象，它的值在组件的整个⽣命周期内保持不变，并且修改它不会触发组件重新渲染。
```javascript
import React, { useState, useRef } from 'react';
function Example() {
    const [count, setCount] = useState(0);
    const refCount = useRef(0);
};
const incrementState = () => {
setCount(count + 1);
const incrementRef = () => {
    refCount.current++;
    console.log('Ref count:', refCount.current);
};
return (
    <div>
        <p>State count: {count}</p>
        <button onClick={incrementState}>Increment State</button>
        <button onClick={incrementRef}>Increment Ref</button>
    </div>
    );
}
export default Example;
```
- 代码细节： useState 返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染。 useRef 返回⼀个对象，通过 current 属性访问和修改其值。
- 案例应⽤： useState 适⽤于需要触发组件重新渲染的状态管理，如表单输⼊值、 计数器等。 useRef 适⽤于保存不需要触发重新渲染的值，如 DOM 节点引⽤、定时器 ID 等。

## 2. 为什么有 hooks？hooks 是⼲什么⽤的？
- 在 React 中，Hooks 是 React 16.8 引⼊的新特性，主要是为了解决类组件的⼀些问题，如代码复⽤困难、逻辑复杂时难以拆分等。Hooks 可以让你在不编写class 的情况下使⽤ state 以及其他 React 特性。
```javascript
import React, { useState } from'react';
function Counter() {
const [count, setCount] = useState(0);
return (
    <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
            Click me
        </button>
    </div>
);
}
export default Counter;
```
- 代码细节： useState 是⼀个 Hook，它返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染并更新count 的显示值。 
- 案例应⽤：Hooks 使得函数组件可以有状态，并且可以将复杂的逻辑拆分成多个⼩的 Hook，提⾼代码的复⽤性和可维护性。例如在多个组件中复⽤表单验证逻辑、数据获取逻辑等。

## 3. 常⻅的 hooks？
- React 提供了多个内置的 Hooks，还有很多社区⾃定义的 Hooks，常⻅的内置 Hooks 可以帮助开发者在函数组件中使⽤不同的 React 特性。
```javascript
// useState ：⽤于在函数组件中添加状态。
import React, { useState } from'react';
function Example() {
    const [count, setCount] = useState(0);
    return (
        <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count +
        1)}>Increment</button>
        </div>
    );
}
// useEffect：⽤于处理副作⽤，如数据获取、订阅、DOM 操作等。
import React, { useState, useEffect } from'react';
function DataFetching() {
    const [data, setData] = useState(null);
    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []);
    return (
        <div>
            {data? 
                <p>{data.message}</p> : <p>Loading...</p>}
        </div>
    );
}
// useContext：⽤于在组件之间共享数据，避免层层传递 `props`。
import React, { createContext, useContext } from'react';
const ThemeContext = createContext();
function ThemeProvider({ children }) {
    const theme= 'dark';
    return (
        <ThemeContext.Provider value={theme}>
            {children}
        </ThemeContext.Provider>
            
    );
}
function ChildComponent() {
    const theme = useContext(ThemeContext);
    return <p>Current theme: {theme}</p>;
}
function App() {
    return (
        <ThemeProvider>
            <ChildComponent />
        </ThemeProvider>
    );
}
```
- 案例应⽤：不同的 Hooks 适⽤于不同的场景， useState ⽤于状态管理， useEffect ⽤于处理异步操作和副作⽤， useContext ⽤于组件间数据共享。

## 4. 原生的hooks
- 原⽣的 Hooks 指的是 React 官⽅提供的内置 Hooks，它们是 React 核⼼库的⼀部分，可以直接在 React 项⽬中使⽤。
- 常⻅原⽣ Hooks 总结：
  - useState ：管理组件的状态，允许函数组件有状态变化。 
  - useEffect ：处理副作⽤，如数据获取、订阅、DOM 操作等。在组件渲染后或依赖项变化时执⾏回调函数。 
  - useContext ：获取上下⽂对象，⽤于在组件树中共享数据。 
  - useReducer ：类似于 Redux 的 reducer 模式，⽤于管理复杂的状态逻辑。 
  - useCallback ：返回⼀个记忆化的回调函数，⽤于优化性能，避免不必要的函数重新创建。 
  - useMemo ：返回⼀个记忆化的值，⽤于优化性能，避免不必要的计算。 
  - useRef ：创建⼀个可变的引⽤对象，通常⽤于保存 DOM 节点或在组件的整个⽣命周期内保持值不变。 
  - useImperativeHandle ：⽤于⾃定义使⽤ ref 时暴露给⽗组件的实例值。 
  - useLayoutEffect ：与 useEffect 类似，但会在 DOM 更新后同步执⾏，常⽤于需要测量 DOM 布局的场景。 
  - useDebugValue ：⽤于在 React DevTools 中显示⾃定义 Hook 的调试信息。 
- 案例应⽤：在不同的开发场景中选择合适的原⽣ Hooks 可以提⾼开发效率和组件性能，例如在性能敏感的组件中使⽤ useCallback 和 useMemo 进⾏优化。

## 5. useContext 如何进⾏组件之间的传输？
- useContext 结合 createContext 和 Context.Provider 实现组件间的数据传输。 createContext 创建⼀个上下⽂对象， Context.Provider ⽤于提供数据， useContext ⽤于在组件中获取上下⽂对象中的数据。
```javascript
import React, { createContext, useContext } from'react';
// 创建上下⽂对象
const UserContext = createContext();
// 提供数据的组件
function UserProvider({ children }) {
    const user = { name: 'John', age: 30 };
    return (
        <UserContext.Provider value={user}>
            {children}
        </UserContext.Provider>
    );
}
// 接收数据的组件
function DisplayUser() {
    const user = useContext(UserContext);
    return (
        <div>
            <p>Name: {user.name}</p>
            <p>Age: {user.age}</p>
        </div>
    );
}
function App() {
    return (
        <UserProvider>
            <DisplayUser />
        </UserProvider>
    );
}
export default App;
```
- 代码细节：
  - 使⽤ createContext 创建 UserContext 。 
  - UserProvider 组件使⽤ UserContext.Provider 包裹⼦组件，并通过 value 属性提供数据。 
  - DisplayUser 组件使⽤ useContext(UserContext) 获取上下⽂对象中的数据并显示。
- 案例应⽤：在多层嵌套的组件结构中，当多个组件需要访问相同的数据时，使⽤useContext 可以避免通过 props 层层传递数据，提⾼代码的简洁性和可维护性。

## 6. 虚拟 DOM 的理解
- 虚拟 DOM（Virtual DOM）是⼀种轻量级的 JavaScript 对象，它是真实DOM 的抽象表示。当组件状态发⽣变化时，React 等框架会先计算虚拟 DOM 的差异（Diffing 算法），然后将差异批量更新到真实 DOM 上，这样可以减少直接操作真实 DOM 的次数，提⾼性能。
- 代码案例（简单模拟虚拟 DOM 更新）：
```javascript
// 虚拟 DOM 节点类
class VNode {
    constructor(tag, props, children) {
        this.tag = tag;
        this.props = props;
        this.children = children;
    }
}
// 创建虚拟 DOM
const oldVNode = new VNode('div', { id: 'old' }, ['Old content']);
const newVNode = new VNode('div', { id: 'new' }, ['New content']);
// 简单的 Diff 算法和更新函数
function diff(oldVNode, newVNode) {
    if (oldVNode.tag!== newVNode.tag || oldVNode.props.id!==newVNode.props.id) {
        // 这⾥简单模拟更新操作
        console.log('Update DOM');
    }
}
diff(oldVNode, newVNode);
```
- 代码细节：定义了⼀个 VNode 类来表示虚拟 DOM 节点。创建了旧的和新的虚拟DOM 节点，通过 diff 函数⽐较它们的差异，若有差异则进⾏更新操作。
- 案例应⽤：在 React、Vue 等前端框架中⼴泛使⽤虚拟 DOM 来优化 DOM 操作。例如在⼀个列表组件中，当列表数据更新时，框架会通过虚拟 DOM 计算差异，只更新需要更新的部分，⽽不是重新渲染整个列表。

## 7. Vue3，有哪些改进
- Vue3 在性能、开发体验、代码组织等⽅⾯进⾏了诸多改进。采⽤了 Proxy 实现响应式系统，提⾼了响应式的性能和功能；引⼊了组合式 API，使代码更易于复⽤和维护；重构了虚拟 DOM 实现，优化了渲染性能。
```vue
<template>
    <div>
      <p>{{ count }}</p>
      <button @click="increment">Increment</button>
    </div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(0);
const increment = () => {
    count.value++;
};
</script>
```
- 代码细节：使⽤ script setup 语法和组合式 API， ref 函数创建响应式数据 count ，通过 count.value 访问和修改其值。点击按钮时调⽤ increment 函数 更新 count 的值。
- 案例应⽤：组合式 API 使得代码逻辑可以按照功能进⾏分组，提⾼了代码的可读性和可维护性。例如在⼤型项⽬中，不同的功能模块可以独⽴封装和复⽤。

## 8. vue双向绑定原理
- Vue 的双向绑定是通过数据劫持结合发布 - 订阅模式实现的。在 Vue2 中，使⽤ Object.defineProperty() 对数据对象的属性进⾏劫持，当属性值发⽣变化时，触发 setter ⽅法通知所有订阅者更新视图；在 Vue3 中，使⽤ Proxy 对象进⾏数据劫持。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2 Two - way Binding</title>
</head>
<body>
<input type="text" id="input">
<p id="output"></p>
<script>
    const data = {message: ''};
    // 数据劫持
    Object.defineProperty(data, 'message', {
        get() {
            return this._message;
        },
        set(newValue) {
            this._message = newValue;
            document.getElementById('output').textContent = newValue;
        }})
    const input = document.getElementById('input');
    input.addEventListener('input', function () {
        data.message = this.value;
    });
    // 初始化输出
    document.getElementById('output').textContent = data.message;
</script>
</body>
</html>
```
- 代码细节：使⽤ Object.defineProperty 对 data 对象的 message 属性进⾏劫持，当 message 属性被赋值时， setter ⽅法会被触发，更新⻚⾯上的 p 元素内容。同时，给输⼊框添加 input 事件监听器，当输⼊框内容变化时，更新data.message 的值，从⽽实现双向绑定。
- 案例应⽤：在表单输⼊场景中，如⽤户登录、注册表单，通过双向绑定可以⽅便地将⽤户输⼊的数据同步到数据对象中，同时将数据对象的变化反映到⻚⾯上。

## 9.  在什么阶段进⾏ DOM 操作
- 在前端开发中，不同的框架和场景有不同的适合进⾏ DOM 操作的阶段。在原⽣ JavaScript 中，通常在 DOMContentLoaded 事件触发后进⾏ DOM 操作，确保⽂档已经解析完成。在 Vue 中，可以在 mounted ⽣命周期钩⼦中进⾏ DOM 操作，此时组件已经挂载到 DOM 上。在 React 中，可以使⽤ useEffect 钩⼦在组件渲染后进⾏ DOM 操作。
```vue
<template>
    <div>
      <p ref="myParagraph">This is a paragraph.</p>
    </div>
</template>
<script>
export default {
    mounted() {
        const paragraph = this.$refs.myParagraph;
        paragraph.style.color ='red';
    }
};
</script>
```
- 代码细节：在 Vue 组件的 mounted 钩⼦中，通过 this.$refs 获取到 p 元素的 引⽤，然后修改其样式。
- 案例应⽤：当需要对⻚⾯上的元素进⾏样式修改、添加事件监听器等操作时，选择合适的阶段进⾏ DOM 操作可以避免出现元素未加载完成的错误。

## 10. hash 模式和 history 模式有什么区别？
- 在前端路由中，hash 模式和 history 模式是两种不同的实现⽅式，主要区别在于 URL 的表现形式和浏览器历史记录的管理。
- URL 表现形式：
  - hash 模式：URL 中使⽤ # 符号来分隔路径，例如http://example.com/#/home。 # 后⾯的内容不会发送到服务器，浏览器只会根据 # 后⾯的路径进⾏前端路由匹配。 
  - history 模式：URL 看起来像正常的路径，例如http://example.com/home 。它使⽤ HTML5 的 History API 来管理浏 览器历史记录，路径会发送到服务器。
- 浏览器历史记录管理：
  - hash 模式：每次 # 后⾯的路径变化都会添加⼀条新的历史记录，通过浏览器的前进后退按钮可以在这些历史记录之间切换。 
  - history 模式：使⽤ pushState 和 replaceState ⽅法来操作浏览器历史记录，也可以实现前进后退功能，但需要服务器端的⽀持，因为服务器需要对不同的路径返回相同的 HTML ⽂件。
```javascript
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
Vue.use(VueRouter);
const routes = [
    {
        path: '/home',
        name: 'Home',
        component: Home
    },
    {
        path: '/about',
        name: 'About',
        component: About
    }
];
// hash 模式
const routerHash = new VueRouter({
    mode: 'hash',
    routes
});
// history 模式
const routerHistory = new VueRouter({
    mode: 'history',
    routes
});
```
- 案例应⽤：hash 模式适合简单的单⻚应⽤，不需要服务器端额外配置；history 模式适合对 URL 美观性有要求的应⽤，但需要服务器端进⾏相应的配置，如在Node.js 中使⽤ Express 框架时需要配置中间件来处理不同路径的请求。
