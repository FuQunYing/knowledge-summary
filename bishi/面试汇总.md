# ⼀、HTML部分
## 1. script标签为什么放在body下⾯？
- 避免阻塞渲染：”script 默认会阻塞 HTML 解析，放在顶部会导致页面白屏时间变长。
- 提高页面加载速度：让 HTML 结构优先渲染出来，提升用户体验。
- 保证 DOM 已加载：某些脚本依赖页面元素，放在 body 底部能避免 document.getElementById找不到元素的问题。
- 总结： script 放底部是为了 性能优化 + 避免阻塞 + DOM 可用性。

## 2. HTML5语义化标签
- 常见的语义化标签：
> \<header>：头部区域
> \<nav>：导航部分
> \<section>：页面章节内容
> \<article>：独立的文章内容
> \<aside>：侧边栏
> \<footer>：尾部内容
> \<main>：页面主要内容
> \<figure> / \<figcaption>：带标注的媒体内容
> \<mark>：标记高亮
> \<time>：时间

- 好处：
> 结构更清晰，便于维护
> 有利于 SEO（搜索引擎更易理解结构）
> 有利于无障碍阅读（屏幕阅读器可识别语义）

## 3. ⾃定义属性 data-*
- data-* 是 HTML5 提供的用于存储自定义数据的方式，如：
```html
<div data-id="123" data-role="admin"></div>
```
- 特点
> 1. 可通过 JS 获取：element.dataset.id
> 2. 不会污染标准属性
> 3. 常用于组件初始化、业务标记

- 应用场景
> 存储业务数据
> 存储 UI 组件配置
> 在 HTML 与 JS 之间传递信息

## 4. 块级元素、⾏内元素
- 块级元素（block）
> 特点：独占一行，可以设置宽高、margin、padding，宽度默认 100%
> 常见：div, p, ul, li, h1~h6, section, article, header, footer

- 行内元素（inline）
> 特点：不独占一行，不能设置宽高（默认内容撑开），padding、margin 只有左右生效
> 常见：span, a, img（特殊，可替换）, strong, em

- 行内块元素 inline-block
> 可设置宽高，但不独占一行。

## 5. BFC
- BFC 是浏览器布局的一种渲染区域，有一套自己的布局规则。
- 如何触发 BFC？
> overflow: hidden | auto | scroll
> float: left/right
> display: inline-block
> position: absolute/fixed
> display: flow-root

- BFC 能解决什么？
> 清除浮动：父元素形成 BFC 就能包住子元素浮动高度。
> 避免 margin 重叠（外边距折叠）
> 避免浮动元素遮挡内容
> 自适应多列布局
> 一句话总结：BFC = 独立布局环境，用来解决浮动、margin 重叠等问题。

## 6. 可替换元素
- 浏览器根据其标签属性或外部资源来决定具体内容和尺寸。
- 常见可替换元素：
> img，input，textarea，button，select，iframe，video，embed

- 特点
> 1. 宽高可以设置
> 2. 内容由浏览器替换渲染
> 3. 默认行为一般不可用 CSS 完全控制

## 7. 脚本异步加载，三种常见方式（script标签中的defer和async）：
### 1. async
```html
<script src="a.js" async></script>
```
> 下载与解析 HTML 并行
> 下载完立即执行（可能会阻塞）
> 多个 script 执行顺序不保证

### 2. defer
```html
<script src="a.js" defer></script>
```
> 下载与解析 HTML 并行
> 等 DOM 全部解析完后按顺序执行
> 一般用于依赖 DOM 的代码
> 案例应⽤：若脚本有依赖关系且需在⽂档解析完后执⾏，⽤ defer ；若脚本⽆依赖且不影响⻚⾯渲染，⽤ async 。例如在加载第三⽅统计脚本时可⽤ async ，加载依赖于⽂档结构的脚本时⽤ defer 。

### 3. 动态创建 script
```JavaScript
const s = document.createElement('script');
s.src = 'xxx.js';
document.body.appendChild(s);
```
> 默认异步加载，等价于 async

## 8. a 标签 noopener 是什么？
```html
<!--当你使用-->
<a href="xxx" target="_blank" rel="noopener">
```
- 作用
> 防止新窗口通过 window.opener 控制原页面（安全）
> 防止恶意页面修改原窗口 Location（钓鱼攻击）
> 提升性能： 新页面不会与当前页面共享进程（Chrome），提升隔离性。
> 延伸：rel="noopener noreferrer" 中 noreferrer 还会隐藏 referer。
> 

## 9. 解析 html 标签时哪些是异步的？哪些是同步的？
> HTML 解析时， \<script> 标签默认同步加载执⾏，会阻塞⽂档解析。加defer 或 async 属性的 \<script> 异步。 \<link rel="stylesheet"> 同步加载，不阻塞⽂档解析，但阻塞 DOMContentLoaded 事件。 \<img> 异步加载，不影响⽂档解析。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <!-- 同步加载样式 -->
        <link rel="stylesheet" href="styles.css">
        <!-- 默认同步脚本 -->
        <script src="sync.js"></script>
        <!-- 异步脚本 -->
        <script async src="async.js"></script>
    </head>
    <body>
        <!-- 异步加载图⽚ -->
        <img src="example.jpg" alt="Example">
    </body>
</html>
<!--案例应⽤：合理安排标签的同步异步加载，可优化⻚⾯性能。如将不影响⻚⾯渲染的脚本设为异步，避免阻塞⽂档解析；将样式⽂件放在头部同步加载，确保⻚⾯样式正常显示。-->
```

# 二、CSS部分
## 1. 盒子模型（Box Model）
- CSS 有 标准盒模型 和 IE 盒模型。
- 标准盒模型（content-box）
> 盒子总宽度 = width + padding + border + margin

- IE 盒模型（border-box）,width 包含了 padding 和 border：
> 盒子总宽度 = width + margin
> border-box 优点：布局更好算、不容易超出容器。

```css
box-sizing: content-box;   /* 默认 */
box-sizing: border-box;    /* 更常用 */
```

## 2. GPU 渲染（硬件加速）
- 浏览器渲染一般分为：
> CPU：负责布局、绘制
> GPU：负责合成、加速动画

- 哪些 CSS 会触发 GPU 加速？
> transform（translate、scale），opacity，filter，will-change，translateZ(0)、translate3d(0,0,0)

- 优点
> 更流畅的动画（不会反复重排/重绘）
> 避免页面抖动（减少 layout）

- 缺点
> 占用 GPU 内存（图层过多会卡）
> 滥用可能导致耗电、掉帧

- 一句话：使用 transform + opacity 做动画，会进入 GPU 合成层，性能最好。

## 3. flex布局、grid布局
### 3.1 Flex（弹性布局）
- 一维布局：主轴 + 交叉轴
- 常用属性：
> 容器：display:flex
> 主轴方向：flex-direction
> 子项自动分配空间：flex: 1
> 主轴对齐：justify-content
> 交叉轴对齐：align-items
> 换行：flex-wrap

- 适用场景：
> 水平垂直居中
> 响应式导航栏
> 不定宽高布局

### 3.2 Grid（网格布局）
- 二维布局：可以同时控制行 + 列
- 常用属性：
> 行列大小：grid-template-rows / grid-template-columns
> 格子间距：gap
> 子项定位：grid-row / grid-column
> 自动填充：repeat(auto-fill, minmax())

- 适用场景：
> 桌面级布局
> 瀑布流
> 仿 Excel 栅格

- 总结区别
| 布局方式 | Flex | Grid |
| - | - | - |
| 维度 | 一维 | 二维 |
| 场景 | 内容自适应 | 更像先规划版面 |
| 控制 | 子项之间关系 | 行列网格精确布局 |

## 4. 百分比（%）的计算规则
- 关键点：百分比的参考对象，取决于属性本身。
| 属性                                         | 百分比相对于                   |
| ------------------------------------------ | ------------------------ |
| width                                      | 父元素 width                |
| height                                     | **不一定能生效**，取决于父元素是否有明确高度 |
| padding                                    | 父元素 **width**            |
| margin                                     | 父元素 width                |
| transform                                  | 自身大小                     |
| position: absolute 的 left/right/top/bottom | 包含块（一般为最近的定位父元素）         |
- 最容易考的点：padding 百分比是相对父元素的宽度，而不是高度，例如保持正方形常用：
```css
.box {
  width: 50%;
  padding-top: 50%; /* 相对父元素宽度 */
}
```

## 5. 如何实现随窗⼝⼤⼩变化的正⽅形？
- 使用 padding-top
```css
.square {
  width: 30%;
  padding-top: 30%;
  background: #1677ff;
}
```
- 使用 aspect-ratio，最常用，最现代
```css
.square {
  width: 200px;
  aspect-ratio: 1 / 1;
  background: #1677ff;
}
```
- 使用 vw（相对视口）
```css
.square {
  width: 20vw;
  height: 20vw;
}
```
- JS 动态设置（不推荐）
> 监听 window 大小然后设置 height=width。

- 总结最优解：
> aspect-ratio: 1; 是最简洁最现代的写法。

## 6. 了解重排和重绘吗？
- 重排（回流）是指当 DOM 的变化影响了元素的布局信息（元素的宽⾼、边距、位置等），浏览器需要重新计算元素在视⼝内的位置和⼤⼩。
- 重绘是指当⼀个元素的外观发⽣改变，但没有影响到布局信息时，浏览器将新样式绘制到屏幕上。 
- 重排的代价⽐重绘⼤，因为重排可能会触发后续⼀系列元素的重排和重绘。
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #box {
                width: 100px;
                height: 100px;
                background-color: red;
            }
        </style>
    </head>
<body>
    <div id="box"></div>
    <button onclick="changeWidth()">Change Width</button>
    <button onclick="changeColor()">Change Color</button>
    <script>
    function changeWidth() {
        const box = document.getElementById('box');
        box.style.width = '200px'; // 触发重排和重绘
    }
    function changeColor() {
        document.getElementById('box');
        const box = box.style.backgroundColor = 'blue'; // 触发重绘
    }
    </script>
</body>
</html>
<!--案例应⽤：在开发中，应尽量减少重排和重绘的次数。⽐如批量修改 DOM 样式时，可先将元素从⽂档流中移除，修改完后再添加回去；避免频繁读取会触发重排的属性，如 offsetWidth 、 scrollTop 等。-->
```

## 7. CSS 和 JS 动画会导致重排吗？
- CSS 动画和 JS 动画是否导致重排取决于动画改变的属性。如果改变的是影响布局信息的属性（如宽度、⾼度、边距等），则会触发重排；如果改变的是只影响外观的属性（如颜⾊、透明度等），则只会触发重绘。⼀般来说，CSS 的 transform 和 opacity 属性在动画中不会触发重排，性能较好。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    #box {
    width: 100px;
    height: 100px;
    background-color: red;
    transition: all 1s;
    transform: translateX(100px); /* 不会触发重排 */
    width: 200px; /* 会触发重排 */
    }
    .move {
    }
    .resize {
    }
    </style>
</head>
<body>
    <div id="box"></div>
    <button onclick="moveBox()">Move Box</button>
    <button onclick="resizeBox()">Resize Box</button>
    <script>
        function moveBox() {
            const box = document.getElementById('box');
            box.classList.add('move');
        }
        function resizeBox() {
            const box = document.getElementById('box');
            box.classList.add('resize');
        }
    </script>
</body>
</html>
<!--案例应⽤：在实现动画效果时，优先使⽤ transform 和 opacity 属性来创建动画，以提⾼性能。例如制作元素的移动、旋转、缩放等动画时，使⽤transform属性；制作淡⼊淡出效果时，使⽤ opacity 属性。-->
```

# 三、JS部分
## 1. 事件——冒泡、捕获、委托、⾃定义事件
### 1.1 事件流：捕获 → 目标 → 冒泡
- 事件流分三阶段：
> 捕获阶段（从 window → 根节点 → 目标父层级）
> 目标阶段
> 冒泡阶段（从目标 → 向上冒到 window）

```JavaScript
// 绑定事件时：
element.addEventListener('click', handler, true);  // 捕获
element.addEventListener('click', handler, false); // 冒泡（默认）
```
### 1.2 事件委托（Event Delegation）
- 利用事件冒泡，将子元素事件统一绑定到父元素上。
- 优点：
> 减少事件绑定数量，提高性能
> 动态元素也能响应事件
> 便于管理事件

```JavaScript
// 例子：
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log(e.target.innerText);
  }
});
```
### 1.3 自定义事件（CustomEvent）
```JavaScript
// 创建一个事件：
const event = new CustomEvent('myEvent', { detail: { id: 1 } });
element.dispatchEvent(event);
// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.id);
});
```
- 用途：组件通信，状态通知，解耦代码

## 2. DOM API
- 常用 DOM 操作：
```JavaScript
// 查找元素：
document.getElementById()
document.querySelector()
document.querySelectorAll()
document.getElementsByClassName()
document.getElementsByTagName()
// 创建与插入
document.createElement()
parent.appendChild()
parent.insertBefore()
parent.append()
element.innerHTML
// 删除
element.remove()
parent.removeChild()
// 属性
element.getAttribute()
element.setAttribute()
element.dataset
// 样式
element.style
window.getComputedStyle()
// 节点关系
element.parentNode
element.children
element.nextElementSibling
// 尺寸与位置
element.getBoundingClientRect()
element.offsetWidth / offsetHeight
element.scrollTop
```

## 3. this、原型链
### 3.1 this的绑定规则，this 由 调用方式 决定：

| 情况              | this 指向                  |
| --------------- | ------------------------ |
| 作为对象方法调用        | 该对象                      |
| 普通函数调用          | window / undefined（严格模式） |
| 构造函数            | 实例对象                     |
| bind/call/apply | 显式绑定的值                   |
| 箭头函数            | 外层作用域的 this（无法被修改）       |

- 一句话总结：箭头函数的 this = 定义时的外层作用域，不会变。

### 3.2 原型与原型链
> 每个对象都有一个隐藏属性：__proto__
> 每个函数都有一个属性：prototype

```JavaScript
// 关系图（最常问）
obj → __proto__ → Object.prototype → null
fn  → __proto__ → Function.prototype → Object.prototype
```

- 原型链查找规则，访问属性时：
> 先查对象自身
> 找不到往原型链上查
> 一直到 Object.prototype
> 再到 null 停止

## 4. 数据类型转换
- JS 有 显示转换 和 隐式转换。
```JavaScript
// 显示转换
String(123)  → "123"
Number("123") → 123
Boolean(0) → false
parseInt("12px") → 12
parseFloat("3.14") → 3.14
```
- 隐式转换：主要发生在 +, ==, 比较运算、if 判断中
```JavaScript
// + 运算符，若其中一项为字符串 → 转成字符串拼接，否则 → 转成数字
1 + '2' = '12'
'2' - 1 = 1

// ==（宽松等于）规则，最重要规则：
null == undefined   // true
但 null != 0
// 对象与原始类型比较时：对象先转成原始类型（valueOf → toString）,例如：
[1] == 1  // true
[] == 0   // true
[] == ''  // true
```
-  Boolean 真假值判断
```JavaScript
// 假值（6个）：
false
0
''//（空字符串）
null
undefined
NaN
// 其余都是真值，包括：[]、{}、"0"、"false"
```

## 5. 为什么通过getElementsByClassName获取的元素集合⽆法直接forEach
- 原因：getElementsByClassName 返回的是 HTMLCollection，不是数组。
- HTMLCollection 的特点：
> 是类数组，但 不是数组
> 没有 forEach 方法
> 是动态集合（会自动更新）

- 证明： typeof document.getElementsByClassName('xx')  // object
- 解决方式
```JavaScript
// 转成数组
Array.from(collection).forEach(...)
// 使用扩展运算符
[...collection].forEach(...)
// 直接使用for
for (let i = 0; i < collection.length; i++) { ... }
```
- 改用 querySelectorAll：因为它返回的是 NodeList，天然就有 forEach。

## 6. event loop
- Event Loop（事件循环）是 JavaScript 的执⾏机制，⽤于处理异步操作。JavaScript 是单线程的，为了处理异步任务（如定时器、⽹络请求等），引⼊了事件循环机制。它的核⼼包括调⽤栈（Call Stack）、任务队列（Task Queue，分为宏任务队列和微任务队列）。当调⽤栈中的同步任务执⾏完后，事件循环会不断从任务队列中取出任务放⼊调⽤栈执⾏。
```javascript
console.log('Start');
setTimeout(() => {console.log('Timeout')}, 0);
Promise.resolve().then(() => { console.log('Promise');});
console.log('End');
```
- 代码细节：⾸先， console.log('Start') 是同步任务，直接在调⽤栈执⾏并输出。 setTimeout 是宏任务，会在 0 毫秒后将回调函数放⼊宏任务队列。 Promise.resolve().then() 是微任务，会将回调函数放⼊微任务队列。 console.log('End') 也是同步任务，接着执⾏。当调⽤栈为空时，事件循环会先处理微任务队列中的任务，所以输出 Promise ，然后处理宏任务队列中的任务，输出 Timeout 。
- 案例应⽤：在处理异步操作时，如⽹络请求、定时器等，事件循环机制确保了代码的执⾏顺序和异步任务的处理。例如在前端开发中，使⽤ fetch 进⾏⽹络请求，请求完成后的回调函数会通过事件循环机制在合适的时机执⾏。

## 7. 事件循环代码输出
```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
    async function async2() {
        console.log('async2');
    }
}
console.log('setTimeout');
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve) => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});
console.log('script end');
```
- 同样基于事件循环机制，分析代码中同步任务、微任务和宏任务的执⾏顺序。 async/await 本质上是基于 Promise 的语法糖， await 会暂停当前函数的执⾏，等待后⾯的 Promise 完成。
- 代码细节：
  - i. ⾸先执⾏同步任务，输出 script start。 
  - ii. setTimeout 是宏任务，将回调函数放⼊宏任务队列。 
  - iii. 调⽤ async1 函数，输出 async1 start ，接着调⽤ async2 函数，输出async2。 await async2() 暂停 async1 函数的执⾏。 
  - iv. 执⾏ new Promise ，输出 promise1， resolve() 后将 then 回调放⼊微任务队列。 
  - v. 输出 script end ，此时调⽤栈为空。 
  - vi. 处理微任务队列，先执⾏ async1 函数中 await 后⾯的代码，输出 async1 end ，再执⾏ Promise 的 then 回调，输出 promise2。 
  - vii. 处理宏任务队列，输出 setTimeout 。
- 案例应⽤：理解事件循环代码输出顺序有助于调试和优化涉及异步操作的代码，避免出现意外的执⾏顺序问题。

## 8. 平时是怎么发异步请求的
- 在前端开发中，常⻅的发送异步请求的⽅式有 XMLHttpRequest、 fetchAPI 和第三⽅库如 axios 。这些⽅式都是基于浏览器的⽹络请求能⼒，通过异步操作获取服务器数据，避免阻塞主线程。
- 代码案例（使⽤ fetch ）：
```javascript
fetch('https://api.example.com/data').then(response => {
if (!response.ok) {
    throw new Error('Network response was not ok');
}
    return response.json();
}).then(data => {console.log('Data:', data);})
.catch(error => {console.error('Error:', error)})
```
- 代码细节： fetch 函数返回⼀个 Promise ，它接收⼀个 URL 作为参数。第⼀个 then ⽅法处理响应对象，检查响应状态是否正常，若正常则将响应数据解析为JSON。第⼆个 then ⽅法处理解析后的数据。 catch ⽅法捕获请求过程中出现的错误。
- 案例应⽤：在开发中，当需要从服务器获取数据时，如获取⽤户信息、商品列表等，可使⽤上述⽅法发送异步请求。

## 9. 事件循环你是怎么⽤的
- 事件循环主要⽤于处理异步任务，合理利⽤事件循环机制可以优化代码性能和实现复杂的异步逻辑。例如，将⼀些耗时的操作放在异步任务中，避免阻塞主线程。
```javascript
function longRunningTask() {
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += i;
}}
return sum;
// 使⽤ setTimeout 将耗时任务放⼊宏任务队列
setTimeout(() => {
    const result = longRunningTask();
    console.log('Task result:', result);
}, 0);
console.log('Main thread continues...');
```
- 代码细节： longRunningTask 是⼀个耗时的计算任务。使⽤ setTimeout 将其放⼊宏任务队列，主线程可以继续执⾏后续代码，输出 Main thread continues... 。当调⽤栈为空时，事件循环会从宏任务队列中取出longRunningTask 并执⾏。
- 案例应⽤：在前端开发中，对于⼀些复杂的计算、⼤数据处理等耗时操作，可利⽤事件循环将其异步化，避免⻚⾯卡顿。

## 10.防抖节流的作⽤
- 防抖（Debounce）和节流（Throttle）是两种优化⾼频触发事件的技术。防抖是指在⼀定时间内，只有最后⼀次触发事件才会执⾏回调函数；节流是指在⼀定时间内，只执⾏⼀次回调函数。
- 防抖是在⼀定时间内只有最后⼀次触发事件才执⾏回调，节流是在⼀定时间内只执⾏⼀次回调。
```javascript
// 防抖
function debounce(func, delay) {
    let timer = null;
return function () {
    const context = this;
    const args = arguments;
    if (timer) {clearTimeout(timer);}
    timer = setTimeout(() => {
        func.apply(context, args);
    }, delay);
};
}
function search() {console.log('Searching...'); }
const debouncedSearch = debounce(search, 300);
const input = document.getElementById('search-input');
input.addEventListener('input', debouncedSearch);
//节流
function throttle(func, delay) {
    let timer = null;
    return function () {
        if (!timer) {
            const context = this;
            const args = arguments;
            func.apply(context, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    };
}
function scrollHandler() {console.log('Scrolling...');}
const throttledScroll = throttle(scrollHandler, 500);
window.addEventListener('scroll', throttledScroll);
```
- 代码细节：防抖函数通过 setTimeout 和 clearTimeout 来控制回调函数的执⾏，每次触发事件时都会清除之前的定时器，重新计时。节流函数通过⼀个定时器来控制回调函数的执⾏频率，在定时器存在时不执⾏回调函数。
- 案例应⽤：防抖适⽤于搜索框输⼊联想、窗⼝⼤⼩调整等场景，避免频繁触发事件导致性能问题。节流适⽤于滚动加载、按钮点击等场景，控制事件的触发频率。
- 防抖使⽤场景分析：
  - 搜索框输⼊联想：当⽤户在搜索框输⼊内容时，不需要每次输⼊⼀个字符就发起请求，⽽是等⽤户停⽌输⼊⼀段时间后再发起请求，减少不必要的
    请求次数。 
  - 窗⼝⼤⼩调整：当窗⼝⼤⼩改变时，不需要每次⼤⼩变化都触发重新布局等操作，等⽤户停⽌调整⼀段时间后再进⾏处理。
- 节流
  - 滚动加载：在⻚⾯滚动时，不需要每次滚动都去检查是否需要加载更多数据，⽽是每隔⼀段时间检查⼀次，避免频繁触发加载操作。 
  - 按钮点击：对于⼀些防⽌⽤户重复点击的按钮，⽐如提交表单按钮，使⽤节流可以确保在⼀定时间内只响应⼀次点击事件。

## 11. js 写⼀下保留两位⼩数
- 在 JavaScript 中，可以使⽤ toFixed() ⽅法或数学计算来实现保留两位⼩数的功能。 toFixed() ⽅法会将数字转换为字符串，并按照指定的⼩数位数进⾏四舍五⼊。
```javascript
// 使⽤ toFixed() ⽅法
const num = 3.14159;
const result = num.toFixed(2);
console.log(result); // 输出: "3.14"
// 数学计算方法
const num = 3.14159;
const result = Math.round(num * 100) / 100;
console.log(result); // 输出: 3.14
```
- 代码细节： toFixed(2) 直接将数字转换为保留两位⼩数的字符串。数学计算⽅法先将数字乘以 100，然后使⽤ Math.round() 进⾏四舍五⼊，最后再除以 100 得到保留两位⼩数的结果。 
- 案例应⽤：在处理货币⾦额、统计数据等需要精确到⼩数点后两位的场景中使⽤。

## 12. 合并区间
- 合并区间问题通常是给定⼀个包含多个区间的数组，需要将重叠的区间合并为⼀个区间。可以先对区间数组按照区间的起始位置进⾏排序，然后遍历数组，合并重叠的区间。
```javascript
function merge(intervals) {
    if (intervals.length <= 1) return intervals;
    intervals.sort((a, b) => a[0] - b[0]);
    const result = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = result[result.length - 1];
        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            result.push(current);
        }
    }
    return result;
}
const intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
const mergedIntervals = merge(intervals);
console.log(mergedIntervals); // 输出: [[1, 6], [8, 10], [15, 18]]
```
- 代码细节：⾸先对区间数组进⾏排序，确保区间按起始位置从⼩到⼤排列。然后遍历数组，⽐较当前区间和结果数组中最后⼀个区间是否重叠，如果重叠则合并，否则将当前区间添加到结果数组中。 
- 案例应⽤：在⽇程安排、时间管理等场景中，合并重叠的时间区间可以更清晰地展示可⽤时间。

## 13. 常⻅的数据结构的特点
- 常⻅的数据结构包括数组、链表、栈、队列、树、图等，每种数据结构都有其独特的特点和适⽤场景。
```javascript
// 数组
const array = [1, 2, 3, 4, 5];
// 链表节点类
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}
const node1 = new ListNode(1);
const node2 = new ListNode(2);
node1.next = node2;
// 栈
class Stack {
    constructor() {
        this.items = [];
    }
    push(item) {
        this.items.push(item);
    }
    pop() {
        return this.items.pop();
    }
}
const stack = new Stack();
stack.push(1);
stack.push(2);
console.log(stack.pop()); // 输出: 2
// 队列
class Queue {
    constructor() {
        this.items 
    }
    enqueue(item) {
        this.items.push(item);
    }
    dequeue() {
        return this.items.shift();
    }
}
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
console.log(queue.dequeue()); // 输出: 1
```
- 代码细节：数组是⼀种线性数据结构，⽀持随机访问，通过下标可以快速访问元素。链表是由节点组成的线性数据结构，每个节点包含数据和指向下⼀个节点的指针，插⼊和删除操作效率⾼。栈是⼀种后进先出（LIFO）的数据结构，只能在栈顶进⾏插⼊和删除操作。队列是⼀种先进先出（FIFO）的数据结构，在队尾插⼊元素，在队头删除元素。
- 案例应⽤：数组适⽤于需要随机访问元素的场景，如排序算法。链表适⽤于频繁插⼊和删除元素的场景，如实现栈和队列。栈适⽤于函数调⽤栈、浏览器历史记录等场景。队列适⽤于任务调度、消息队列等场景。

## 14. 设计模式-单例模式
- 设计模式是指在软件开发过程中，针对反复出现的问题所总结归纳出的通⽤解决⽅案。常⻅的设计模式包括单例模式、⼯⼚模式、观察者模式、装饰器模式等。
```javascript
// 单例模式
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            this.data = [];
            Singleton.instance = this;
        }
        return Singleton.instance;
    }
    addItem(item) {
        this.data.push(item);
    }
    getData() {
        return this.data;
    }
}
const instance1 = new Singleton();
const instance2 = new Singleton();
instance1.addItem('Item 1');
console.log(instance2.getData()); // 输出: ['Item 1']
```
- 代码细节：单例模式确保⼀个类只有⼀个实例，并提供⼀个全局访问点。在Singleton 类的构造函数中，检查是否已经存在实例，如果不存在则创建⼀个新 实例，否则返回已有的实例。 
- 案例应⽤：单例模式适⽤于需要确保只有⼀个实例的场景，如数据库连接池、⽇志记录器等。⼯⼚模式适⽤于根据不同的条件创建不同类型的对象。观察者模式适⽤于对象之间的⼀对多依赖关系，当⼀个对象的状态发⽣变化时，所有依赖它的对象都会得到通知。

## 15. 观察者模式
- 观察者模式定义了⼀种⼀对多的依赖关系，当⼀个对象（主题）的状态发⽣变化时，所有依赖它的对象（观察者）都会得到通知并⾃动更新。
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }
    addObserver(observer) {
        this.observers.push(observer);
    }
    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index!== -1) {
            this.observers.splice(index, 1);
        }
        
    }
    notify() {
        this.observers.forEach(observer => observer.update());
    }
    setState(newState) {
        this.state = newState;
        this.notify();
    }
}
class Observer {
    constructor(subject) {
        this.subject = subject;
        this.subject.addObserver(this);
    }
    update() {
        console.log(`Observer updated with state:${this.subject.state}`);
    }
}
const subject = new Subject();
const observer1 = new Observer(subject);
const observer2 = new Observer(subject);
subject.setState('New state');
```
- 代码细节： Subject 类表示主题，包含⼀个观察者数组，提供添加、移除观察者和通知观察者的⽅法。 Observer 类表示观察者，在构造函数中注册到主题上，并实现 update ⽅法⽤于接收主题的通知。 
- 案例应⽤：在前端开发中，观察者模式常⽤于实现事件系统、状态管理库等。例如，当⼀个组件的状态发⽣变化时，通知其他依赖该组件的组件进⾏更新。

## 16. 【代码】实现⼀个 call 改变 this 指向
-  call ⽅法⽤于调⽤⼀个函数，并指定该函数内部的 this 值。可以通过将函数挂载到指定的对象上，然后调⽤该对象的⽅法来实现 this 指向的改变。
```javascript
Function.prototype.myCall = function (context = window, ...args) {
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;
    const result = context[fnSymbol](...args);
    delete context[fnSymbol];
    return result;
};
function greet(message) {
    console.log(`${message}, ${this.name}`);
}
const person = { name: 'John' };
greet.myCall(person, 'Hello'); // 输出: Hello, John
```
- 代码细节：在 Function.prototype 上添加 myCall ⽅法，将调⽤ myCall 的函数挂载到 context 对象上，使⽤ Symbol 作为属性名避免冲突。调⽤该属性并传⼊参数，最后删除该属性并返回结果。 
- 案例应⽤：在需要动态改变函数 this 指向的场景中使⽤，如在回调函数中使⽤特定对象的⽅法。

## 17. 【代码】实现⼀个 promise.all
-  Promise.all ⽅法接收⼀个可迭代对象（通常是数组），该数组中的每个元素都是⼀个 Promise 对象，返回⼀个新的 Promise 。当所有输⼊的 Promise都成功完成时，新的 Promise 会以⼀个包含所有结果的数组进⾏ resolve ；如果其中任何⼀个 Promise 被 reject ，新的 Promise 会⽴即以该错误进⾏reject。
```javascript
function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('Expected an array'));
        }
        const results = [];
        let completedCount = 0;
        if (promises.length === 0) {
            return resolve(results);
        }
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                results[index] = result;
                completedCount++;
                if (completedCount === promises.length) {
                    resolve(results);
                }
            
        }).catch(error => {
            reject(error);
            });
        });
    });
}
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

promiseAll([promise1, promise2, promise3]).then(results => {
    console.log(results); // 输出: [1, 2, 3]
}).catch(error => {
    console.error(error);
});
```
- 代码细节：⾸先检查传⼊的 promises 是否为数组，若不是则 reject 。创建⼀个结果数组和⼀个计数器，遍历 promises 数组，使⽤ Promise.resolve 确保每个元素都是 Promise 对象。当⼀个 Promise 成功完成时，将结果存⼊结果数组，计数器加 1，当计数器等于数组⻓度时， resolve 结果数组。若有⼀个Promise 被 reject ，则⽴即 reject 整个 Promise 。 
- 案例应⽤：在需要同时处理多个异步任务，并且需要等待所有任务都完成后再进⾏下⼀步操作的场景中使⽤，如批量请求数据。

## 18. 实现 promise any ⽅法 和 once ⽅法？
- Promise.any 实现：Promise.any 接收⼀个可迭代对象，返回⼀个新的 Promise 。当可迭代对象中的任何⼀个 Promise 成功完成时，新的 Promise 会以该 Promise的结果进⾏ resolve ；如果所有 Promise 都被 reject ，则新的 Promise会以⼀个包含所有错误的 AggregateError 进⾏ reject。
```javascript
Promise.myAny = function (promises) {
    return new Promise((resolve, reject) => {
        const errors = [];
        let rejectedCount = 0
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                resolve(result);
            }).catch(error => {
                errors[index] = error;
                rejectedCount++;
            if (rejectedCount === promises.length) {
                reject(new AggregateError(errors, 'All promises were rejected'));
            }
        });
    });
});
};
const promise1 = Promise.reject(new Error('Error 1'));
const promise2 = Promise.resolve('Success');
const promise3 = Promise.reject(new Error('Error 2'));
Promise.myAny([promise1, promise2, promise3]).then(result => {
    console.log(result); // 输出: Success
}).catch(error => {console.error(error);});
// 代码细节
// 1. 遍历 `promises` 数组，使⽤ `Promise.resolve` 确保每个元素都是`Promise` 对象。
// 2. 当有⼀个 `Promise` 成功时，⽴即 `resolve` 该结果。
// 3. 当所有 `Promise` 都被 `reject` 时，`reject` ⼀个包含所有错误的`AggregateError`。
```
- once ⽅法实现：once ⽅法⽤于确保⼀个函数只执⾏⼀次。可以通过闭包来实现，在函数内部记录函数是否已经执⾏过。
```javascript
function once(func) {
    let hasBeenCalled = false;
    let result;
    return function (...args) {
        if (!hasBeenCalled) {
            result = func.apply(this, args);
            hasBeenCalled = true;
        }
        return result;
    };
}
function greet() {console.log('Hello!');}
// 代码细节
// 1. 使⽤闭包变量 `hasBeenCalled` 记录函数是否已经执⾏过。
// 2. 第⼀次调⽤时执⾏函数并记录结果，将 `hasBeenCalled` 设为 `true`，后续调⽤直接返回第⼀次的结果。
```
- 案例应⽤： Promise.any 适⽤于多个异步任务，只要有⼀个成功就可以继续后续操作的场景； once ⽅法适⽤于只需要执⾏⼀次的初始化操作等场景。

# 四、HTTP部分
## 1. 常⻅状态码
- 1xx（信息性状态码）：表示临时响应，通常⽤于表示请求已接收，继续处理。例如， 100 Continue 表示客户端可以继续发送请求的其余部分。
- 2xx（成功）
> 200 OK：请求成功，最常⻅的成功状态码，当客户端请求资源成功时，服务器返回此状态 码。例如，浏览器请求⼀个 HTML ⻚⾯，服务器成功返回⻚⾯内容时，状态码为 200。
> 201 Created：资源已创建（一般用于 POST）

- 3xx（重定向）
> 301 Moved Permanently：永久重定向，表示请求的资源已永久移动到新的 URL。常⽤于⽹站域名变更或⻚⾯结构调整时，告诉搜索引擎和浏览器该⻚⾯已永久转移到新地址。
> 302 Found：临时重定向
> 304 Not Modified：使用缓存（协商缓存命中）

- 4xx（客户端错误）
> 400 Bad Request：请求参数问题
> 401 Unauthorized：未认证
> 403 Forbidden：已认证但权限不足
> 404 Not Found：资源不存在，表示请求的资源不存在。当⽤户访问⼀个不存在的⻚⾯时，服务器会返回此状态码。
> 429 Too Many Requests：请求太频繁（限流）

- 5xx（服务端错误）
> 500 Internal Server Error，表示服务器内部发⽣了错误，⽆法完成请求。可能是服务器代码出现异常、数据库连接失败等原因导致。
> 502 Bad Gateway
> 503 Service Unavailable：服务不可用
> 504 Gateway Timeout

- 代码案例（使⽤ Node.js 实现简单的 HTTP 服务器并返回不同状态码）
```javascript
const http = require('http');
const server = http.createServer((req, res) => {
    if (req.url === '/') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Welcome to the home page!');
    } else if (req.url === '/about') {
        res.statusCode = 301;
        res.setHeader('Location', '/new - about');
        res.end();
    } else if (req.url === '/new - about') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('This is the new about page!');
    } else {
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Page not found!');
    }
});

server.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```
- 代码解析：上述代码创建了⼀个简单的 HTTP 服务器，根据不同的请求 URL 返回不同的状态码和响应内容。当请求根路径 / 时，返回状态码 200 和欢迎信息；当请求 /about 时，返回状态码 301 并设置重定向到 /new - about ；当请求 /new - about 时，返回状态码 200 和新的关于⻚⾯信息；当请求其他不存在的路径时，返回状态码 404 和⻚⾯未找到信息。

## 2. 301、302、304
- 301 永久重定向
> 告诉浏览器资源永久移动到新地址
> 浏览器会缓存重定向结果
> SEO 中会将权重转移到新地址

- 302 临时重定向
> 暂时跳到新地址
> 浏览器不会缓存
> 常用于登录跳转、临时调整

- 304 Not Modified
> 协商缓存生效
> 服务器告诉浏览器：你缓存的资源没变
> 浏览器直接读取本地缓存
> 触发条件：If-Modified-Since / If-None-Match

| 状态码 | 场景     | 是否重新下载资源   |
| --- | ------ | ---------- |
| 301 | 永久重定向  | 会          |
| 302 | 临时重定向  | 会          |
| 304 | 协商缓存命中 | **不会**下载资源 |

## 3. 常⻅的请求method
| Method  | 作用         | 是否安全 | 是否幂等 |
| ------- | ---------- | ---- | ---- |
| GET     | 获取数据       | ✔    | ✔    |
| POST    | 创建/提交数据    | ✘    | ✘    |
| PUT     | 更新资源（整体更新） | ✘    | ✔    |
| PATCH   | 局部更新       | ✘    | ✘    |
| DELETE  | 删除资源       | ✘    | ✔    |
| HEAD    | 获取响应头      | ✔    | ✔    |
| OPTIONS | 预检请求       | ✔    | ✔    |

## 4. 跨域问题：浏览器的 同源策略 导致：协议、域名、端口不同即跨域。
**解决跨域的方式**
- 1. 服务端 CORS（最常用）
```java
// 服务器设置：
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Access-Control-Allow-Methods: *
```
- 2. Nginx 反向代理：前端访问同域的 nginx，由 nginx 代理转发。
- 3. JSONP（只支持 GET）
- 4. WebSocket（不受同源策略限制）
- 5. 跨域资源共享 iframe 通信（postMessage）

## 5. session和cookie是如何⼯作的？
- Cookie
> 存储在浏览器
> 会自动随请求携带到同域服务器
> 一般用于：登录状态 token、偏好设置

- Session
> 存储在服务器
> 浏览器通过 cookie 中的 sessionId 来标识用户

- 工作流程：
> 用户第一次访问服务器
> 服务器创建 session，在 server 保存（如内存/Redis）
> 服务端返回 Set-Cookie: sessionId=xxxx
> 浏览器保存 cookie
> 下次请求自动带上 sessionId
> 服务器通过 sessionId 找到当前用户的数据

- 本质：
> Cookie 存 sessionId，Session 存用户数据
> 两者配合实现登录状态。

## 6. CDN
- 作用：
> 加速访问（就近节点返回资源）
> 减少源站压力
> 防止 DDoS
> 资源缓存提升加载速度

## 7. 补充DDos
### 1. 什么是 DDoS？
> > DDoS（Distributed Denial of Service）分布式拒绝服务攻击
> > 攻击者控制大量肉鸡设备（服务器、主机、IoT 设备等），向目标服务器同时发起大量无意义的请求，占满带宽、耗尽计算资源，使其：
> > 无法处理正常请求
> > CPU/带宽被打满
> > 服务瘫痪、宕机
> 一句话： 用海量流量淹没目标，让它无法提供服务。

### 2. 常见 DDoS 攻击类型
> ① 流量型攻击（最常见）
> > 用巨量带宽攻击目标，典型如：
> > UDP Flood
> > ICMP Flood（Ping Flood）
> > DNS Amplification（放大攻击）
> 目标：耗尽网络带宽
> ② 协议型攻击
> 利用协议缺陷，占用服务器资源：
> > SYN Flood（半连接攻击）
> > ACK Flood
> > TCP Slowloris
> 目标：耗尽服务器连接数、CPU
> ③ 应用层攻击
> 模拟真实请求，但大量消耗后端业务资源：
> > HTTP Flood（模拟真实浏览器访问）
> > CC 攻击
> 目标：耗尽应用服务器处理能力

### 3. DDoS 攻击的特点
> 流量巨大（几十 G、几百 G、甚至 Tb 级别）
> 来源广泛（僵尸网络）
> 难以直接阻断
> 攻击成本低、防护成本高

### 4. 如何防御 DDoS？（面试高频）
> ① CDN / 高防节点 / 云清洗
> > CDN 节点分担流量
> > 高防 IP 提供流量清洗
> > 将恶意流量在边缘拦截
> ② 限流、熔断、验证码
> > 限制同一 IP 请求次数
> > 出现异常访问就触发熔断
> > 验证码阻挡自动化请求
> ③ 防火墙 / WAF
> > 根据规则过滤恶意协议包
> > 阻挡常见攻击（SYN、UDP flood）
> ④ 隔离节点 / 分布式部署
> > 多区域部署，分散攻击压力
> ⑤ 黑洞路由（最后手段）
> > 直接丢弃所有到该 IP 的流量（服务暂时不可用）。
> 一句话总结（面试官爱听版）
> > DDoS 是利用大量设备并发向目标发起无意义请求，耗尽带宽和资源，使服务不可用。
> > 防御主要依赖 CDN + 高防清洗 + 限流 + WAF。

> 用户访问资源 → DNS 将域名解析到 最近的 CDN 节点
> 如果节点有缓存 → 直接返回
> 如果没有 → 回源服务器获取并缓存

- 一句话总结：CDN = 离用户最近的服务器负责返回静态资源。

## 8. 强缓存与协商缓存
- 强缓存（不会发送请求）
```java
// 响应头中包含：
Cache-Control: max-age=3600
Expires: xxx
```
> 效果
> - 在有效期内，浏览器直接读本地缓存
> - 状态码：200（from cache）

- 协商缓存（会发送请求）
```java
// 请求头：
If-Modified-Since
If-None-Match
// 响应头
Last-Modified
ETag
```
- 流程：
> 浏览器带上条件请求
> 服务端判断资源是否更新
> 如果未更新 → 返回 304

- 区别总结
| 类型   | 是否发请求 | 典型状态码           |
| ---- | ----- | --------------- |
| 强缓存  | ❌ 不发  | 200（from cache） |
| 协商缓存 | ✔ 发   | 304             |

## 9. fetch和XMLHttpRequest的区别
### 1. API 设计现代
```javascript
// fetch 是 Promise 设计，更简洁：
fetch('/api').then()
// XHR
const xhr = new XMLHttpRequest();
xhr.open();
xhr.send();
```
### 2. 默认不带cookie
```javascript
// fetch
fetch(url, { credentials: 'include' })
// XHR同源时，默认带cookie
```
### 3. 不支持同步请求：XHR 支持同步（已被废弃），fetch 不支持同步。
### 4. 错误处理不同
```javascript
// fetch 只会对网络错误 reject，
// HTTP 错误不会抛错，需要自己判断：
if (!res.ok) { }
```
### 5. 支持流（stream）读取:fetch 可以分块读取大文件（如视频）。
- 总结一句话：
| 功能     | fetch       | XHR     |
| ------ | ----------- | ------- |
| 风格     | Promise，更现代 | 回调地狱    |
| Cookie | 默认不带        | 默认带     |
| 同步     | ❌           | ✔（但不推荐） |
| 流式处理   | ✔           | ✘       |
| 兼容性    | 中等          | 极好      |

## 10. http 和 https 的区别？
- HTTP （超⽂本传输协议）是明⽂传输协议，数据在传输过程中容易被截取和篡改，存在安全⻛险。 HTTPS （超⽂本传输安全协议）是在 HTTP 的基础上加⼊了 SSL/TLS 协议进⾏加密，保证了数据传输的安全性。
- 区别分析
  - 安全性：HTTP ：数据以明⽂形式传输，容易被中间⼈窃取和篡改，如⽤户的账号密码、敏感信息等可能会泄露。 HTTPS ：使⽤ SSL/TLS 协议对数据进⾏加密，即使数据被截取，攻击者也⽆法获取其中的敏感信息。
  - 端口号：HTTP ：默认使⽤端⼝号 80。HTTPS ：默认使⽤端⼝号 443。
  - 证书：HTTP ：不需要证书。 HTTPS ：需要向认证机构申请 SSL 证书，⽤于验证服务器的身份和加密数据传输。
- 案例应⽤：在涉及⽤户敏感信息交互的场景，如⽹上银⾏、电⼦商务平台等，必须使⽤ HTTPS 协议来保障⽤户数据的安全。⽽对于⼀些对安全性要求不⾼的静态⻚⾯，如新闻资讯⽹站的部分⻚⾯，可使⽤ HTTP 协议。

## 11.  开发过程中有没有⽤过抓包或者代理⼯具？类似 charles？
- 抓包⼯具（如 Charles、Fiddler 等）和代理⼯具可以拦截、监控和修改⽹络请求和响应。其原理是在客户端和服务器之间充当中间代理，捕获经过的数据，⽅便开发者分析请求和响应的详细信息，如请求头、请求体、响应状态码、响应内容等。
- 使⽤场景及案例：
  - 接⼝调试：在开发前后端分离的项⽬时，通过抓包⼯具可以查看前端发送的请求是否符合预期，后端返回的数据格式和内容是否正确。例如，前端发送⼀个登录请求，通过抓包⼯具可以查看请求的 URL 、请求⽅法、请求参数以及后端返回的状态码和响应数据，帮助定位接⼝调⽤过程中出现的问题。
  - 性能分析：分析请求和响应的时间，找出性能瓶颈。⽐如，查看某个⻚⾯加载时各个请求的耗时情况，判断是哪个请求导致⻚⾯加载缓慢，进⽽进⾏优化。
  - 数据篡改：在测试过程中，可以使⽤抓包⼯具修改请求或响应的数据，模拟不同的场景进⾏测试。例如，修改请求中的参数，测试后端接⼝对异常数据的处理能⼒。

## 12. url 链接每⼀部分代表什么含义
- ⼀个完整的 URL （统⼀资源定位符）由多个部分组成，每个部分都有特定的含义，⽤于定位互联⽹上的资源。
- 示例及各部分含义：
  - 示例 URL ： https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section
  - 协议（Protocol）： https 表示使⽤的是超⽂本传输安全协议，规定了客户端和服务器之间通信的规则和⽅式。 
  - 域名（Domain Name）： www.example.com 是⽹站的域名，⽤于标识服务器 的位置。域名会通过 DNS（域名系统）解析为对应的 IP 地址。 
  - 端⼝号（Port）： 8080 是服务器监听的端⼝号，⽤于区分不同的服务。默认情况下， HTTP 使⽤ 80 端⼝， HTTPS 使⽤ 443 端⼝。 
  - 路径（Path）： /path/to/resource 表示服务器上资源的具体位置，类似于⽂件系统中的⽂件路径。 
  - 查询参数（Query Parameters）： param1=value1&param2=value2 是传递给服务器的额外参数，⽤于向服务器传递数据或进⾏条件筛选等操作。 
  - ⽚段标识符（Fragment Identifier）： #section ⽤于定位⻚⾯内的特定部分，当⻚⾯加载完成后，浏览器会⾃动滚动到该部分。

## 13. 跨域与同源
- 同源策略是浏览器的⼀个重要安全机制，它规定浏览器只允许访问同源（协议、域名、端⼝都相同）的资源。如果⼀个请求的源（协议、域名、端⼝）与当前
  ⻚⾯的源不同，就会产⽣跨域问题。
- 同源示例及⾮同源示例：
  - 同源： ⻚⾯ https://www.example.com/page1.html 和请求https://www.example.com/api/data 是同源的，因为协议都是https ，域名都是 www.example.com ，端⼝默认都是 443。
  - ⾮同源（跨域）： ⻚⾯ https://www.example.com/page1.html 和请求http://anotherdomain.com/api/data 存在跨域问题，因为协议不同 （⼀个是 https ，⼀个是 http ），域名也不同。
- 跨域解决⽅案：
  - JSONP（JSON with Padding）：利⽤ <script> 标签的 src 属性不受同源策略限制的特点，通过动态创建 <script> 标签来实现跨域数据请求。 
  - CORS（跨域资源共享）：是⼀种现代的跨域解决⽅案，服务器端设置响应头（如 Access-Control-Allow-Origin ）来允许特定源的请求访问资源。 
  - 代理服务器：在同源的服务器上设置代理，将客户端的请求转发到⽬标服务器，再将响应返回给客户端。

## 14. http 链接创建的过程
- HTTP 是基于 TCP 协议的应⽤层协议， HTTP 链接的创建依赖于 TCP 连接的建⽴。
- 详细过程：
  - 客户端发起连接请求：客户端（浏览器）根据输⼊的 URL 解析出服务器的 IP地址和端⼝号，然后向服务器发送 TCP 连接请求（SYN 包），该包包含客户端的初始序列号等信息。
  - 服务器响应连接请求：服务器接收到客户端的 SYN 包后，向客户端发送⼀个SYN + ACK 包，表示同意建⽴连接，并包含服务器的初始序列号和对客户端序列号的确认信息。
  - 客户端确认连接：客户端接收到服务器的 SYN + ACK 包后，向服务器发送⼀个ACK 包，表示确认连接。⾄此， TCP 连接建⽴完成。
  - 发送 HTTP 请求：在 TCP 连接建⽴后，客户端向服务器发送 HTTP 请求，包括请求⾏、请求头和请求体（如果有）。
  - 服务器处理请求并返回响应：服务器接收到 HTTP 请求后，进⾏相应的处理，然后返回 HTTP 响应，包括响应⾏、响应头和响应体。
  - 关闭连接：当请求和响应完成后，客户端和服务器可以选择关闭 TCP 连接，通过四次挥⼿的过程释放连接资源。

## 15. ⻓链接和短链接的区别是什么
- ⻓链接和短链接是指客户端和服务器之间连接的保持⽅式，主要区别在于连接的持续时间和使⽤场景。区别分析如下：
- 连接持续时间：
  - 短链接：每次请求时建⽴连接，请求完成后⽴即关闭连接。例如，在传统的 HTTP 1.0 协议中，每个请求都需要重新建⽴ TCP 连接，请求结束后连接关闭。
  - ⻓链接：在⼀次连接建⽴后，会保持⼀段时间不关闭，客户端和服务器可以在这个连接上多次发送请求和响应。例如，在 HTTP 1.1 及以后的版本中，默认⽀持⻓连接（ Connection: keep - alive ）。
- 性能开销：
  - 短链接：每次建⽴和关闭连接都需要⼀定的时间和资源开销，如 TCP 连接的三次握⼿和四次挥⼿过程。在频繁请求的场景下，会增加性能开销。
  - ⻓链接：避免了频繁建⽴和关闭连接的开销，提⾼了性能。但⻓连接会占⽤服务器的资源，如果⻓时间不使⽤，也需要进⾏管理和清理。
- 使⽤场景：
  - 短链接：适⽤于请求频率较低、对连接实时性要求不⾼的场景，如静态⻚⾯的请求。 
  - ⻓链接：适⽤于需要频繁交互、对实时性要求较⾼的场景，如即时通讯、游戏服务器等。

## 16. 浏览器从输⼊⽹址到⻚⾯呈现发⽣了什么？
- 1. 用户输入 URL / 按回车：浏览器拿到一个字符串（例如 https://example.com/path），开始解析成各部分（协议、主机、端口、路径、查询、fragment）。
- 2. 存 / 预连接：浏览器会先查本地缓存（DNS 缓存、HTTP 缓存、HSTS、Service Worker、connection pool）。如果资源可用且命中强缓存，可能直接从本地返回并跳过网络请求。
- 3. DNS 解析（把域名解析为 IP）
> 浏览器先查本地 DNS 缓存 → OS 缓存 → hosts 文件 → 发起 DNS 请求到 DNS 服务器。
> 这一步可能被 CDN 或 DNS 负载均衡影响（返回最近节点 IP）。
> （优化点：DNS 缓存、DNS over HTTPS、prefetch）

- 4. 建立 TCP 连接（如果没有现成连接）
> 三次握手：SYN → SYN-ACK → ACK。
> HTTP/1.1 + keep-alive 会复用连接；HTTP/2 在一个连接上多路复用多个请求。

- 5. TLS 握手（如果是 HTTPS）
> 客户端/服务器协商加密算法、交换证书、验证证书、生成对称密钥（包括可能的会话复用 / 0-RTT 优化）。
> TLS 完成后数据加密传输。
> （优化点：TLS session resumption、OCSP stapling、HTTP/2、QUIC/HTTP3）

- 6. 发起 HTTP 请求：浏览器发送 HTTP 请求（包含 headers：Host、User-Agent、Accept、Cookie、If-Modified-Since/If-None-Match 等）。如果有 Service Worker，Service Worker 可以拦截请求并返回响应（缓存或自定义响应）。
- 7. 服务器处理并返回响应：服务器接收请求，处理（路由、后端逻辑、读取 DB、调用微服务等），返回响应头和响应体（HTML、或 301/302 重定向等）。（CDN、高防或缓存层可在此处命中并直接返回缓存内容）
- 8. 浏览器开始接收字节 —— HTML 开始解析（关键渲染路径开始）
> 当浏览器接收到 HTML 字节流时，会 边下载边解析（streaming parsing）：
> a. HTML 解析器：生成 Token → 构建 DOM 树（DOM）
> 浏览器把 HTML token 化，生成 DOM 节点并链接成 DOM 树。
> b. CSS 解析：下载 CSS（遇到 <link>）并构建 CSSOM（CSS Object Model）
> 遇到外部 CSS，会触发额外的请求（可并行下载）。CSSOM 与 DOM 共同用于后续渲染树构建。
> c. JavaScript 的影响（关键）
> 同步阻塞脚本（普通 <script>）：解析到 <script> 会暂停 HTML 解析 —— 浏览器必须先下载并执行脚本，脚本可能修改 DOM/CSSOM，因此解析被阻塞。
> defer：脚本并行下载，但在 HTML 解析完成后按顺序执行（不会阻塞解析）。
> async：并行下载，下载完成就执行（可能在解析中断），执行顺序不保证。
> 动态创建 <script>（appendChild）：默认 async 行为（不会阻塞）。
> Service Worker 可以拦截并直接提供内容，影响是否请求网络。
> （重点：JS 能修改 DOM/CSSOM，因此会阻塞渲染）

- 9. 构建 Render Tree（渲染树）：浏览器把 DOM 和 CSSOM 合并，构建 Render Tree（渲染树）：只包含需要被绘制的可见节点（例如 display:none 会被忽略），并计算每个节点的样式（resolved style）。
- 10. 布局（Reflow / Layout）：浏览器根据渲染树计算每个可见节点的几何尺寸和位置（即各元素的宽高、x/y）。这是一个代价较高的过程。（触发重排的操作：改 width/height、添加/移除 DOM、改变字体、改变 box-model 等）
- 11. 绘制（Paint）：将布局好的每个节点绘制成图层中的绘制命令（绘制文本、颜色、边框、阴影、图片等）。这一步称为 paint。
- 12. 合成（Compositing）现代浏览器会把页面拆成多个图层（layer），并交给 GPU 合成（特别是使用 transform, opacity, will-change 等会创建图层的属性）。合成阶段把图层合并到最终帧并呈现到屏幕。（涉及 GPU rasterization、合成顺序优化、图层缓存）
- 13. 首次绘制指标（可观测点）
> 浏览器在这过程中会记录关键性能指标（供 DevTools / 报表使用）：
> > FP（First Paint）：浏览器开始绘制的时间点。
> > FCP（First Contentful Paint）：首次绘制任何有意义内容（文本、图片等）。
> > LCP（Largest Contentful Paint）：最大可视内容绘制完成时间（用户感知重要指标）。
> > DOMContentLoaded：DOM 构建完成并解析完所有脚本（不等待样式/图片）。
> > load：页面所有资源（包括图片、iframe）加载完成。

- 14. JavaScript 执行与事件循环
> 页面渲染与 JS 执行并行但又相互影响：
> > 主线程负责解析 HTML/CSS、执行 JS、布局和绘制。长时间 JS 会阻塞渲染。
> > JS 的执行遵循事件循环（macrotasks、microtasks）。微任务（Promise.then）会在当前 macrotask 完结前执行，可能导致长时间锁主线程。
> > （优化点：避免主线程长任务、使用 Web Worker 做计算密集型任务）

- 15. 后续资源加载与渲染更新：图片、字体、视频等资源可能在初次布局后异步加载并触发 repaint 或 reflow（例如图片加载改变元素尺寸会触发 reflow）。浏览器会增量地重绘或合成受影响区域。
- 16. 浏览器缓存与条件请求：在后续访问中，浏览器会使用缓存策略（强缓存 / 协商缓存）。若使用协商缓存，会发送 If-Modified-Since / If-None-Match，服务端可返回 304 以节省带宽。
- 17. 交互阶段与生命周期事件
> DOMContentLoaded：DOM 构建完（同步脚本已执行完）。
> load：所有资源加载完。
> 可以监听 requestAnimationFrame 做动画，在下一帧渲染前执行回调。

- 额外补充：常见优化点（面试高频）
> 减少阻塞资源：把脚本放底部 / 使用 defer / async。
> Critical CSS：内联关键 CSS，延迟非关键 CSS。
> 预加载/预取：<link rel="preload">、prefetch、preconnect。
> 使用 CDN、启用 gzip/brotli、HTTP/2 或 HTTP/3（QUIC）。
> 开启缓存策略、合理使用 ETag/Last-Modified。
> 减少重排/重绘：合并 DOM 操作、使用 transform 代替 top/left、避免频繁读写 layout 属性。
> 使用 Service Worker 做离线缓存与路由拦截。
> 避免主线程阻塞：分割任务、使用 Web Worker。
> 按需创建合成图层，避免过多图层占用 GPU 内存。

- 短答题模版（面试时可念）
> “用户输入 URL 后，浏览器先做 DNS 解析、建立 TCP/TLS 连接，然后发 HTTP 请求。服务器返回 HTML，浏览器边下载边解析：构建 DOM、下载并解析 CSS（生成 CSSOM）、执行阻塞或非阻塞的 JS（影响解析），将 DOM+CSSOM 合并成渲染树，进行布局（reflow）、绘制（paint）、合成（composite）并把帧交给 GPU 呈现。期间还涉及缓存、CDN、Service Worker、HTTP/2 多路复用等优化点，最终触发 DOMContentLoaded/load 等事件。”

## 17. 浏览器的组成
- 现代浏览器主要由多个组件组成，每个组件负责不同的功能，协同⼯作以实现⽹⻚的加载和渲染等功能。
- 主要组件：
  - ⽤户界⾯：包括地址栏、书签栏、标签⻚等，⽤于⽤户与浏览器进⾏交互。 
  - 浏览器引擎：负责协调和管理其他组件的⼯作，如解析 HTML、CSS 等资源，将渲染结果传递给渲染引擎。
  - 渲染引擎：负责解析 HTML 和 CSS，构建 DOM 树和 CSSOM 树，合并为渲染树，进⾏布局和绘制，将⻚⾯内容显示在屏幕上。不同的浏览器使⽤不同的渲染引擎，如 Chrome 使⽤ Blink 引擎，Firefox 使⽤ Gecko 引擎。
  - ⽹络模块：负责处理⽹络请求和响应，包括 DNS 解析、TCP 连接建⽴、HTTP请求发送和响应接收等。
  - JavaScript 引擎：负责执⾏ JavaScript 代码，如 Chrome 的 V8 引擎。它将JavaScript 代码编译为机器码，提⾼执⾏效率。 
  - 数据存储模块：负责管理浏览器的本地存储，如localStorage、 sessionStorage、 IndexedDB 等，⽤于保存⽤户的浏览数据、缓存等。 
  - 安全模块：负责保障浏览器的安全，如防⽌跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，对⽹⻚的内容和请求进⾏安全检查。
- 应用场景
  - ⽤户界⾯：⽅便⽤户输⼊ URL、管理书签、切换标签⻚等操作，提供良好的⽤户体验。 
  - 渲染引擎：确保⽹⻚能够正确地解析和显示，处理不同的 HTML 和 CSS 标准。 
  - ⽹络模块：实现⽹⻚资源的下载和更新，保证数据的传输稳定和⾼效。 
  - JavaScript 引擎：⽀持⽹⻚中的动态交互和复杂功能，如表单验证、动画效果等。 
  - 数据存储模块：⽤于保存⽤户的登录状态、个性化设置、离线缓存等信息，提⾼⽤户的使⽤便利性。 
  - 安全模块：保护⽤户的隐私和数据安全，防⽌恶意⽹站的攻击。
- 代码案例
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content=
            "width=device-width, initial-scale=1.0">
    <title>Browser Storage Example</title>
</head>
<body>
<input type=
               "text" id=
               "inputText">
<button id=
                "saveButton">Save to Local Storage</button>
<button id=
                "loadButton">Load from Local Storage</button>
<p id=
           "output"></p>
<script>
    const input = document.getElementById('inputText');
    const saveButton = document.getElementById('saveButton');
    const loadButton= document.getElementById('loadButton');
    const output = document.getElementById('output');
    saveButton.addEventListener('click', function () {
        const text = input.value;
        localStorage.setItem('savedText', text);
        output.textContent = 'Text saved to local storage.';
    });
    loadButton.addEventListener('click', function () {
        const savedText = localStorage.getItem('savedText');
        if (savedText) {
            output.textContent = 'Loaded text: ' + savedText;
        } else {
            output.textContent = 'No text found in local storage.';
        }
    });
</script>
</body>
</html>
```
- 代码解析：此代码示例主要展示了浏览器数据存储模块中 localStorage 的使⽤。具体如下：
  - ⾸先通过 document.getElementById 获取输⼊框、保存按钮、加载按钮和⽤于显示输出信息的段落元素。 
  - 给保存按钮添加点击事件监听器，当点击保存按钮时，获取输⼊框中的⽂本内容，使⽤ localStorage.setItem ⽅法将⽂本保存到 localStorage 中，并在输出段 落显示保存成功的信息。 
  - 给加载按钮添加点击事件监听器，当点击加载按钮时，使⽤localStorage.getItem ⽅法从 localStorage 中获取之前保存的⽂本。如果能获取到⽂本，则在输出段落显示加载的⽂本；如果没有找到保存的⽂本，则显示相应提示信息。这体现了浏览器数据存储模块对⽤户数据的存储和读取功能，⽅便在不同⻚⾯或会话间保留⽤户输⼊的信息。

## 18. DOM BOM 和 BOM 的 API
-  DOM （⽂档对象模型）和 BOM （浏览器对象模型）是浏览器编程中的重要概念。
  - DOM：是 HTML ⽂档的树形结构表示，将 HTML ⽂档解析为⼀个由节点组成的树，每个节点可以是元素节点、⽂本节点等。通过 DOM ，可以使⽤ JavaScript 动态地操作 HTML ⽂档的内容、结构和样式。
  - BOM：是浏览器窗⼝的对象模型，提供了与浏览器窗⼝相关的操作接⼝，如窗⼝⼤⼩调整、导航、弹出对话框等。
- DOM API：
  - document.getElementById() ：通过元素的 id 属性获取元素节点。
  - document.createElement() ：创建⼀个新的元素节点。
  - element.appendChild() ：将⼀个节点添加为另⼀个节点的⼦节点。
  - element.style ：⽤于操作元素的样式。
- BOM API：
  - window.alert() ：弹出⼀个警告对话框。
  - window.location ：⽤于获取和设置当前⻚⾯的 URL 。
  - window.history ：⽤于操作浏览器的历史记录，如前进、后退等。
  - window.innerWidth 和 window.innerHeight ：获取浏览器窗⼝的内部宽度和⾼度。

## 19. websocket 通信原理
- WebSocket 是⼀种在单个 TCP 连接上进⾏全双⼯通信的协议，它允许浏览器和服务器之间进⾏实时通信。
- 通信过程：
  - 握⼿阶段：客户端向服务器发送⼀个 HTTP 请求，请求头中包含 Upgrade:websocket 和 Connection: Upgrade 等信息，表示要升级为 WebSocket 连接。服务器收到请求后，如果⽀持 WebSocket 协议，会返回⼀个状态码为101 的响应，表示同意升级连接。
  - 建⽴连接：握⼿成功后， TCP 连接保持打开，客户端和服务器可以在这个连接上进⾏双向通信。
  - 数据传输：客户端和服务器可以随时向对⽅发送数据，数据以帧的形式传输。 WebSocket 协议定义了不同类型的帧，如⽂本帧、⼆进制帧等。
  - 关闭连接：当⼀⽅需要关闭连接时，会发送⼀个关闭帧给对⽅。对⽅收到关闭帧后，会发送⼀个确认关闭帧，然后双⽅关闭 TCP 连接。
- 代码案例
```javascript
// 服务器端（使⽤ Node.js 的 ws 库）：
const WebSocket = require('ws'); 
const wss = new WebSocket.Server({ port: 8080 }); 
wss.on('connection', function connection(ws) {
    ws.on('message', function incoming(message) {
        console.log('received: %s', message);
        ws.send('Server received: ' + message);
    });
});
```
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Example</title>
</head>
<body>
<button id="sendButton">Send Message</button>
<script>
    const socket = new WebSocket('ws://localhost:8080');
    socket.onopen = function () {console.log('Connected to the server')}
    socket.onmessage = function (event) {console.log('Received from server: ', event.data)}
    socket.onclose = function () {console.log('Disconnected from the server')}
    const sendButton = document.getElementById('sendButton');
    sendButton.addEventListener('click', function () {socket.send('Hello, server!')})
</script>
</body>
</html>
```
- 代码细节：
  - 服务器端使⽤ ws 库创建⼀个 WebSocket 服务器，监听 8080 端⼝。当有客户端连接时，监听客户端发送的消息，并将消息原样返回给客户端。 
  - 客户端使⽤ WebSocket 构造函数创建⼀个 WebSocket 实例，连接到服务器。监听 open、 message 和 close 事件，分别处理连接建⽴、接收消息 和连接关闭的情况。点击按钮时，向服务器发送消息。
- 案例应⽤：WebSocket 适⽤于需要实时通信的场景，如在线聊天、实时数据展示（股票⾏情、实时监控等）、多⼈游戏等。

# 五、Web安全
## 1. SQL注⼊（SQL Injection）
**是什么？**
> 攻击者通过向输入字段（URL、表单、Header）提交 恶意 SQL 语句，导致服务器拼接 SQL 时被篡改，最终可能：
> > 数据泄露
> > 数据篡改
> > 数据删除
> > 获取 root 权限

- 例子（典型注入）：
```sql
SELECT * FROM users WHERE username = '${input}'
```
- 攻击输入：
```vbnet
' OR 1=1 --
```
- 执行结果变成
```sql
SELECT * FROM users WHERE username = '' OR 1=1 --'
```
**如何防御？**
- 使用 预编译（Prepared Statement）（最有效）
```sql
SELECT * FROM users WHERE username = ?
```
- 严格参数化查询
> 框架 ORM（Sequelize、Hibernate）默认支持。

- 过滤/转义特殊字符
> 如 ', ", --, ;

- 最小权限原则
> 数据库用户只给必须的权限。

- WAF（Web Application Firewall）
> 自动拦截恶意 SQL 语句。

## 2. XSS攻击
**是什么？**
> 攻击者将恶意脚本注入页面，让浏览器执行，可能：
> > 盗取 cookie
> > 获取用户信息
> > 冒充用户操作
> > 页面篡改

**XSS 类型**
- ① 反射型 XSS（最常见）
> 恶意脚本通过URL注入

- 存储型 XSS（最危险）
> 恶意代码存到 DB，每次访问都会执行。

- ③ DOM 型 XSS
> 攻击点发生在前端 JS 内部。

**如何防御**
- 对输出内容做 HTML 转义（最关键）
```php
< → &lt;  
> → &gt;  
" → &quot;  
' → &#39;
```
- 架一般自带转义：React、Vue 默认是安全的。
-  CSP（Content-Security-Policy）,制脚本来源：
```php
Content-Security-Policy: default-src 'self'
```
- 禁止直接拼接 HTML,使用 innerHTML，改用：textContent
- 对用户输入进行过滤、校验
- HttpOnly Cookie（防止被读取）

## 3. 请求伪造（CSRF / XSRF）
**是什么**
> 击者诱导用户点击恶意链接，使浏览器在用户不知情的情况下发出请求（带 Cookie），从而完成敏感操作。
> 比如：转账、修改密码。
> 核心点：
> > CSRF 利用了浏览器会自动携带 Cookie 的机制。

**如何防御**
- ① Token（CSRF Token）—— 最有效
> 服务端生成 token，页面提交时必须携带。
> 攻击者无法获取 token。

- ② SameSite Cookie 设置
> 阻止跨站请求自动带上 cookie：

```javascript
Set-Cookie: sessionId=xxx; SameSite=Lax
```
> 选项：
> > Lax：大部分场景安全
> > Strict：最安全（完全不允许跨站）
> > None + Secure：允许跨站（要 HTTPS）

- ③ Referer / Origin 验证:服务器检查请求来源是否合法。
- 用户操作增加验证码 / 二次确认

## 4. jwt（JSON Web Token）
**是什么**
> 一种前后端分离中常用的 无状态身份认证方式。
> JWT 由三部分组成（用点分隔）：
> ```css
> header.payload.signature
> ```

- ① Header（头部）声明算法：
```json
{ "alg": "HS256", "typ": "JWT" }
```
- ② Payload（负载）:存用户信息、过期时间：
```json
{ "userId": 1, "exp": 1700000000 }
```
- ③ Signature（签名）使用密钥生成，防篡改：
```scss
HMACSHA256(header + payload, secret)
```
**JWT工作流程**
- 用户登录成功，服务器生成 JWT 返回给前端
- 前端保存 JWT（localStorage / cookie）
- 后续请求在 Header 中携带：Authorization: Bearer \<token>
- 服务器验证签名 → 解析用户信息
- 不需要 Session，不维护服务端状态（无状态）
**JWT的优点**
- 无状态，后端不需要存储 session（适合分布式）
- 前后端分离非常方便
- 可以跨服务验证（微服务常用）
**JWT的缺点**
- 不能主动失效（除非维护黑名单）
- token 一旦泄露，风险极高
- 不适合存放敏感信息（payload 只是 Base64，不加密）
- 较大（比 sessionId 更占带宽）
**JWT 的安全性注意事项**
- ✔ 设置 短过期时间
- ✔ 搭配 Refresh Token
- ✔ 使用 HTTPS
- ✔ 不要把 JWT 放在 localStorage（容易被 XSS 偷走）
- ✔ 可以放在 HttpOnly Cookie 中提高安全性

## 5. 加密的具体过程 、ssl 加密的细节 、 http2.0
- SSL/TLS 加密过程：
  - 客户端发起握⼿请求：客户端向服务器发送 ClientHello 消息，包含客户端⽀持的 SSL/TLS 版本、加密算法列表、随机数等信息。 
  - 服务器响应握⼿请求：服务器收到 ClientHello 消息后，发送ServerHello 消息，选择⼀个 SSL/TLS 版本和加密算法，并发送服务器的证书和另⼀个随机数。
  - 客户端验证证书：客户端验证服务器证书的有效性，包括证书的颁发机构、有效期等。如果证书有效，客户端会⽣成⼀个会话密钥，使⽤服务器证书中的公钥进⾏加密后发送给服务器。
  - 服务器解密会话密钥：服务器使⽤⾃⼰的私钥解密客户端发送的会话密钥。
  - 建⽴安全连接：客户端和服务器使⽤会话密钥进⾏对称加密通信，后续的请求和响应都使⽤该密钥进⾏加密和解密。
- HTTP/2.0 特性：
  - ⼆进制分帧： HTTP/2.0 将请求和响应数据分割成⼆进制帧，提⾼了传输效率。 
  - 多路复⽤：允许在⼀个连接上同时发送多个请求和响应，避免了 HTTP 1.x 中的队头阻塞问题。
  - 头部压缩：使⽤ HPACK 算法对请求和响应的头部进⾏压缩，减少了头部数据的传输量。
  - 服务器推送：服务器可以主动向客户端推送资源，提前将客户端可能需要的资源发送给客户端，提⾼⻚⾯加载速度。

## 6. JSONP 和 Cors 为什么可以解决同源问题
- JSONP（JSON with Padding）：
  - JSONP 利⽤了 <script> 标签的 src 属性不受同源策略限制的特点。前端⻚⾯动态创建 <script> 标签，将请求的 URL 作为 src 属性的值，并在 URL 中添加⼀个回调函数名作为参数。服务器收到请求后，将数据包装在回调函数中返回给客户端。客户端的 <script> 标签加载该响应后，会执⾏回调函数，从⽽获取到服务器返回的数据。
  - 解决同源问题的原因：由于 <script> 标签的 src 属性可以跨域请求资源，所以通过这种⽅式绕过了浏览器的同源策略限制。
- CORS（跨域资源共享）：
  - CORS 是⼀种现代的跨域解决⽅案，基于 HTTP 协议，通过服务器端设置响应头来允许特定源的请求访问资源。当客户端发起跨域请求时，浏览器会⾃动在请求头中添加 Origin 字段，标识请求的源。服务器收到请求后，检查Origin 字段，如果该源在允许的范围内，会在响应头中添加相应的跨域允许 信息（如 Access - Control - Allow - Origin ），浏览器根据这些信息判断是否允许该跨域请求。 
  - 解决同源问题的原因：通过服务器端的配置，明确允许哪些源可以访问资源，从⽽在保证安全的前提下解决了跨域问题。

## 7. 浏览器发请求时有个 options 请求，做什么的（跨域的预检请求）
- 当浏览器发起跨域请求时，如果请求是复杂请求（如使⽤ PUT 、 DELETE等⾮简单请求⽅法，或者包含⾃定义请求头、 Content - Type 不是简单类型等），浏览器会先发送⼀个 OPTIONS 请求，称为预检请求。
- 预检请求的作⽤：
  - 检查服务器⽀持情况：通过 OPTIONS 请求，浏览器询问服务器是否⽀持当前请求的⽅法、请求头和源。服务器会在响应头中返回允许的请求⽅法（如 Access - Control - Allow - Methods ）、允许的请求头（如 Access - Control - Allow - Headers ）和允许的源（如 Access - Control - Allow Origin ）等信息。 
  - 避免不必要的跨域请求：如果服务器不⽀持当前请求的⽅法、请求头或源，浏览器就不会发送真正的请求，从⽽避免了不必要的跨域请求和潜在的安全⻛ 险。

# 六、算法
## 1. 红绿灯
```javascript
function trafficLight() {
  const light = async (color, duration) => {
    console.log(color);
    await new Promise(resolve => setTimeout(resolve, duration));
  };
  
  const run = async () => {
    while (true) {
      await light('红灯', 3000);
      await light('绿灯', 2000);
      await light('黄灯', 1000);
    }
  };
  run();
}
```

## 2. 暂停函数
```javascript
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function run() {
  console.log(1);
  await sleep(1000);
  console.log(2);
}

```

## 3. 实现forEach
```javascript
Array.prototype.myForEach = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    callback.call(thisArg, this[i], i, this);
  }
};
```

## 4. 千位分隔符
```javascript
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
// 或者
function formatNumber(num) {
    return num.toLocaleString();
}
```

## 5. 扁平化数组
```javascript
// 方法1: 递归
function flatten(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
}
// 方法2: flat
const flatten = arr => arr.flat(Infinity);// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```

## 6. 斐波那契数列
```javascript
// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```

## 7. 分块数组
```javascript
function chunk(arr, size) {
  const result = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}
```

## 8. 数组分组
```javascript
function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const group = typeof key === 'function' ? key(item) : item[key];
    (acc[group] = acc[group] || []).push(item);
    return acc;
  }, {});
}
```

## 9. compose 复合函数
```javascript
// 从右到左执行
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 从左到右执行（pipe）
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
```

## 10. 根据id 合并2个数组
```javascript
function mergeById(arr1, arr2) {
  const map = new Map(arr1.map(item => [item.id, item]));
  arr2.forEach(item => {
    if (map.has(item.id)) {
      Object.assign(map.get(item.id), item);
    } else {
      map.set(item.id, item);
    }
  });
  return Array.from(map.values());
}
```

## 11. 归约reduce
```javascript
Array.prototype.myReduce = function(callback, initialValue) {
  let acc = initialValue !== undefined ? initialValue : this[0];
  let startIndex = initialValue !== undefined ? 0 : 1;
  
  for (let i = startIndex; i < this.length; i++) {
    acc = callback(acc, this[i], i, this);
  }
  return acc;
};
```

## 12. 记忆函数
```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}
```

## 13. 精简对象（移除假值）
```javascript
function compact(obj) {
  const result = {};
  for (let key in obj) {
    if (obj[key]) result[key] = obj[key];
  }
  return result;
}
```

## 14. 实现map
```javascript
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback.call(thisArg, this[i], i, this));
  }
  return result;
};
```

## 15. ⼿动实现 call
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};
```

## 16. 数组出现2次的数字（找重复项）
```javascript
function findDuplicates(arr) {
  const count = {};
  return arr.filter(item => {
    count[item] = (count[item] || 0) + 1;
    return count[item] === 2;
  });
}
```

## 17. 数组去重
```javascript
// 方法1: Set
const unique = arr => [...new Set(arr)];

// 方法2: filter
const unique = arr => arr.filter((item, index) => arr.indexOf(item) === index);
```

## 18. 蜗⽜排序（螺旋矩阵）
```javascript
// 输出 n×n 的螺旋矩阵：
function snail(n) {
  const res = Array.from({ length: n }, () => Array(n).fill(0));
  let num = 1, left = 0, right = n-1, top = 0, bottom = n-1;

  while (left <= right && top <= bottom) {
    for (let i = left; i <= right; i++) res[top][i] = num++;
    top++;
    for (let i = top; i <= bottom; i++) res[i][right] = num++;
    right--;
    for (let i = right; i >= left; i--) res[bottom][i] = num++;
    bottom--;
    for (let i = bottom; i >= top; i--) res[i][left] = num++;
    left++;
  }

  return res;
}

```

## 19. 冒泡排序
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

## 20. 原型链继承
```javascript
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype); // 继承方法
Child.prototype.constructor = Child;
```

## 21. deepClone 深拷⻉
```javascript
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (map.has(obj)) return map.get(obj); // 处理循环引用
  
  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  return clone;
}
```

## 22. promise.all()
```javascript
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('参数必须是数组'));
    }
    
    const results = [];
    let count = 0;
    
    if (promises.length === 0) return resolve(results);
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        count++;
        if (count === promises.length) resolve(results);
      }).catch(reject);
    });
  });
};
```

## 23. 数组去重(有排序)：
```javascript
unique(arr, key)
{
  if (!arr) return arr
  if (key === undefined) return [...new Set(arr)]
  const map = {
    'string': e => e[key],
    'function': e => key(e),
  }
  const fn = map[typeof key]
  const obj = arr.reduce((o,e) => (o[fn(e)]=e, o), {})
  return Object.values(obj)
}
```

## 24. 数组元素偏移
- 实现数组元素偏移可以通过将数组的后 k 个元素移动到数组的前⾯。可以使⽤三次反转数组的⽅法来实现，先反转整个数组，再反转前 k 个元素，最后反转剩下的元素。
```javascript
function rotate(nums, k) {
    const n = nums.length;
    k = k % n
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
    [nums[start], nums[end]] = [nums[end], nums[start]];
    start++;
    end--;
}}

function rotate(nums, k) {
    const n = nums.length;
    k = k % n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
        [nums[start], nums[end]] = [nums[end], nums[start]];
        start++;
        end--;
    }
}
const nums = [1, 2, 3, 4, 5, 6, 7];
const k = 3;
const rotatedNums = rotate(nums, k);
console.log(rotatedNums); // 输出: [5, 6, 7, 1, 2, 3, 4]
```
- 代码细节
  - ⾸先计算 k 对数组⻓度 n 取模，避免 k ⼤于数组⻓度的情况。 
  - 第⼀次调⽤ reverse 函数反转整个数组。 
  - 第⼆次调⽤ reverse 函数反转数组的前 k 个元素。 
  - 第三次调⽤ reverse 函数反转数组中剩余的元素。 
- 案例应⽤：在处理循环数组、周期性数据等场景中会⽤到，⽐如实现⼀个时钟表盘上数字的循环滚动效果。

## 25. 数组拉平（flatten）
- 数组拉平是将嵌套数组转换为⼀维数组。可以使⽤递归的⽅式遍历数组，若元素是数组则继续递归处理，若元素是基本类型则添加到结果数组中。
```javascript
function flatten(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
            result.push(...flatten(arr[i]));
        } else {
            result.push(arr[i]);
        }
    }
    return result;
}
const nestedArray = [1, [2, [3, 4], 5], 6];
const flattenedArray = flatten(nestedArray);
console.log(flattenedArray); // 输出: [1, 2, 3, 4, 5, 6]
```
- 代码细节：
  - 创建⼀个空数组 result ⽤于存储拉平后的元素。
  - 遍历输⼊数组 arr ，若元素是数组，则递归调⽤ flatten 函数并将结果展开添加到 result 中；若元素不是数组，则直接添加到 result 中。
- 案例应⽤：在处理树形结构数据、多维矩阵转换等场景中会⽤到，⽐如将⼀个多级菜单的数据结构转换为⼀维列表。

## 26. lc1026 ⼆叉树最⼤差值
- 题⽬描述：给定⼆叉树的根节点 root ，找出存在于不同节点 A 和 B 之间的最⼤值 V ，其中 V = |A.val - B.val| ，且 A 是 B 的祖先。
- 原理：可以使⽤深度优先搜索（DFS）遍历⼆叉树，在遍历过程中记录从根节点到当前节点路径上的最⼤值和最⼩值，然后计算当前节点值与最⼤值、最⼩值的差值，更新最⼤差值。
```javascript
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
function maxAncestorDiff(root) {
    let maxDiff = 0; 
    function dfs(node, minVal, maxVal) {
        if (!node) return;
        // 更新最⼤差值
        maxDiff = Math.max(maxDiff, Math.abs(node.val - minVal),Math.abs(node.val - maxVal));
        // 更新路径上的最⼤值和最⼩值
        minVal= Math.min(minVal, node.val);
        maxVal= Math.max(maxVal, node.val);
        // 递归遍历左⼦树和右⼦树
        dfs(node.left, minVal, maxVal);
        dfs(node.right, minVal, maxVal);
    }
    dfs(root, root.val, root.val);
    return maxDiff;
}
// 构建⼆叉树示例
const root = new TreeNode(8);
root.left = new TreeNode(3);
root.right = new TreeNode(10);
root.left.left = new TreeNode(1);
root.left.right = new TreeNode(6);
root.left.right.left = new TreeNode(4);
root.left.right.right = new TreeNode(7);
root.right.right = new TreeNode(14);
root.right.right.left = new TreeNode(13);
const result = maxAncestorDiff(root);
console.log(result);
```
- 代码细节：
  - 定义 TreeNode 类表示⼆叉树节点。 
  - maxAncestorDiff 函数中，使⽤ dfs 函数进⾏深度优先搜索。 dfs 函数接收当前节点、路径上的最⼩值和最⼤值作为参数。 
  - 在 dfs 函数中，计算当前节点值与最⼩值、最⼤值的差值，更新最⼤差值。 然后更新路径上的最⼩值和最⼤值，并递归遍历左⼦树和右⼦树。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是⼆叉树的节点数，需要遍历每个节点⼀次。 
  - 空间复杂度：$O(h)$，其中 $h$ 是⼆叉树的⾼度，递归调⽤栈的深度为树的⾼度。

## 27. 长文章加载优化相关算法实现（预加载、分页并发处理）
- 预加载是在⽤户当前操作之前提前加载可能会⽤到的资源，以提⾼后续操作的响应速度。对于⻓⽂章，可提前加载后续⻚⾯的内容。这⾥我们假设⽂章内容存储在⼀个数组中，每个元素代表⼀⻚的内容。预加载实现思路及代码示例：
```javascript
// 模拟⽂章数据
const articlePages = Array.from({ length: 100 }, (_, i) => `Page ${i +1} content`);
// 预加载函数
function preloadPages(currentPage, preloadCount) {
    const preloadedPages = [];
    for (let i = 1; i <= preloadCount; i++) {
        const nextPageIndex = currentPage + i;
        if (nextPageIndex < articlePages.length) {
            preloadedPages.push(articlePages[nextPageIndex]);
        }
    }
    return preloadedPages;
}
// 当前⻚⾯为第 1 ⻚，预加载 3 ⻚
const currentPage = 1;
const preloadCount = 3;
const preloaded = preloadPages(currentPage - 1, preloadCount);
console.log('Preloaded pages:', preloaded);
```
- 代码细节
  - articlePages 数组模拟了⽂章的所有⻚⾯内容。 
  - preloadPages 函数接收当前⻚⾯索引和预加载的⻚⾯数量作为参数。通过循环，从当前⻚⾯的下⼀⻚开始，将指定数量的⻚⾯内容添加到 
  - preloadedPages 数组中，若超出⽂章总⻚数则停⽌。
- 案例应⽤：在⻓⽂章阅读场景中，当⽤户阅读到当前⻚⾯时，提前加载后续⼏⻚的内容，当⽤户翻⻚时可以⽴即显示，减少等待时间。

- 分⻚并发处理是指同时加载多个⻚⾯的数据，提⾼数据加载的效率。可以使⽤ Promise.all 来实现多个⻚⾯数据的并发加载。分页并发处理实现思路及代码示例
```javascript
// 模拟异步加载⻚⾯数据
function loadPage(pageIndex) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(articlePages[pageIndex]);
        }, Math.random() * 1000); // 模拟不同的加载时间
    });
}
// 分⻚并发加载函数
async function loadPagesConcurrently(pageIndices) {
    const promises = pageIndices.map(index => loadPage(index));
    return Promise.all(promises);
}
// 并发加载第 2、3、4 ⻚
const pageIndicesToLoad = [1, 2, 3];
loadPagesConcurrently(pageIndicesToLoad).then(pages => {
    console.log('Concurrently loaded pages:', pages);
});
```
- 代码细节：
  - loadPage 函数模拟异步加载⻚⾯数据，返回⼀个 Promise ，在随机时间后解析为对应⻚⾯的内容。 
  - loadPagesConcurrently 函数接收⼀个⻚⾯索引数组，将每个索引对应的loadPage 函数调⽤封装成 Promise ，并使⽤ Promise.all 并发执⾏这些Promise 。
- 案例应⽤：在⻓⽂章列表展示中，需要同时加载多个⻚⾯的数据来填充列表，使⽤分⻚并发处理可以加快数据加载速度，提升⽤户体验。

## 28. ⼤⽂件断点续传实现（计算并记录切⽚的哈希值）
- ⼤⽂件断点续传的核⼼是将⼤⽂件分割成多个切⽚，分别上传这些切⽚，并记录每个切⽚的哈希值。在上传过程中，如果出现中断，下次上传时可以根据已上传切⽚的哈希值判断哪些切⽚需要重新上传。
```javascript
// 模拟⽂件
const largeFile = new Blob(['a'.repeat(1024 * 1024 * 10)], { type: 'text/plain' }); // 10MB ⽂件
const sliceSize = 1024 * 1024; // 每个切⽚ 1MB
const slices = [];
const hashMap = new Map();
// 分割⽂件并计算哈希值
async function splitFileAndCalculateHash() {
    for (let i = 0; i < largeFile.size; i += sliceSize) {
        const slice = largeFile.slice(i, i + sliceSize);
        slices.push(slice);
        const hash = await calculateHash(slice);
        hashMap.set(i, hash);
    }
    return hashMap;
}
// 计算⽂件切⽚的哈希值
async function calculateHash(slice) {
    const buffer = await slice.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2,
        '0')).join('');
    return hashHex;
}
// 模拟上传切⽚
async function uploadSlices() {
    const uploadedHashes = new Map(); // 模拟已上传切⽚的哈希值记录
    for (let i = 0; i < slices.length; i++) {
        const start = i * sliceSize;
        const hash = hashMap.get(start);
        if (!uploadedHashes.has(hash)) {
        // 模拟上传操作
            await new Promise(resolve => setTimeout(resolve,Math.random() * 1000));
            uploadedHashes.set(hash, true);
            console.log(`Uploaded slice starting at ${start} with hash${hash}`);
        }
    }
}
splitFileAndCalculateHash().then(() => {
    uploadSlices();
});
```
- 代码细节：
  - splitFileAndCalculateHash 函数将⼤⽂件分割成多个切⽚，并调⽤calculateHash 函数计算每个切⽚的哈希值，将哈希值存储在 hashMap中
  - calculateHash 函数使⽤ crypto.subtle.digest ⽅法计算切⽚的 SHA - 256 哈希值。 
  - uploadSlices 函数模拟上传切⽚的过程，通过 uploadedHashes 记录已上传切⽚的哈希值，避免重复上传。
- 案例应⽤：在上传⼤⽂件（如视频、⼤型⽂档）时，⽹络不稳定或其他原因可能导致上传中断，使⽤断点续传可以从上次中断的位置继续上传，节省时间和带宽。

## 29. 前端⽂件分⽚（input 接受⽂件，拿到⽂件指针，对它进⾏分⽚处理，计算哈希值）
- 前端通过 <input type="file"> 元素让⽤户选择⽂件，获取⽂件对象后，根据指定的切⽚⼤⼩对⽂件进⾏分割，同时计算每个切⽚的哈希值。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Slicing</title>
</head>
<body>
    <input type="file" id="fileInput">
    <button id="sliceButton">Slice File</button>
    <script>
        const fileInput = document.getElementById('fileInput');
        const sliceButton = document.getElementById('sliceButton');
        sliceButton.addEventListener('click', async () => {
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a file.');
                return;
            }
            const sliceSize = 1024 * 1024; // 每个切⽚ 1MB
            const slices = [];
            const hashMap = new Map();
            for (let i = 0; i < file.size; i += sliceSize) {
                const slice = file.slice(i, i + sliceSize);
                slices.push(slice);
                const hash = await calculateHash(slice);
                hashMap.set(i, hash);
                console.log(`Slice starting at ${i} with hash${hash}`);
            }
        });
        async function calculateHash(slice) {
            const buffer = await slice.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }
    </script>
</body>
</html>
```
- 代码细节：
  - 通过 \<input type="file"> 元素让⽤户选择⽂件，点击按钮时获取⽂件对象。 
  - 按照指定的切⽚⼤⼩对⽂件进⾏分割，调⽤ calculateHash 函数计算每个切⽚的哈希值，并将哈希值存储在 hashMap 中。 
  - calculateHash 函数使⽤ crypto.subtle.digest ⽅法计算切⽚的 SHA - 256 哈希值。
- 案例应⽤：在需要上传⼤⽂件的场景中，前端先对⽂件进⾏分⽚处理并计算哈希值，然后将切⽚和哈希值信息发送到服务器，服务器可以根据哈希值验证切⽚的完整性。

## 30. 数组去重
### 1.利⽤ Set 数据结构实现去重
- ES6 引⼊的 Set 对象是⼀种⽆序且唯⼀的数据结构，它不允许存储重复的值。因此，可以将数组转换为 Set ，再将 Set 转换回数组，从⽽实现数组去重。
```javascript
function uniqueArray(arr) {
    return [...new Set(arr)];
}
const arr = [1, 2, 2, 3, 4, 4, 5]; 
const uniqueArr = uniqueArray(arr);
console.log(uniqueArr); // 输出: [1, 2, 3, 4, 5]
```
- 代码细节：
  - new Set(arr) ：将数组 arr 转换为 Set 对象，在转换过程中会⾃动去除重复的值。
  - [...new Set(arr)] ：使⽤扩展运算符将 Set 对象展开到⼀个新数组中。
- 复杂度分析：
  - 时间复杂度：$O(n)$，其中 $n$ 是数组的⻓度。因为 Set 的插⼊和查找操作的平均时间复杂度都是 $O(1)$，所以整个去重操作的时间复杂度为 $O(n)$。 
  - 空间复杂度：$O(n)$，因为需要额外的 Set 对象来存储数组中的元素。

### 2. 利⽤双重循环实现去重
- 通过双重循环遍历数组，外层循环遍历每个元素，内层循环检查该元素是否已经在前⾯出现过，如果出现过则跳过，否则将其保留。
```javascript
function uniqueArrayLoop(arr) {
const result = [];
for (let i = 0; i < arr.length; i++) {
    let isDuplicate= false;
    for (let j = 0; j < result.length; j++) {
        if (arr[i] === result[j]) {
            isDuplicate = true;
            break;
        }
    }
    if (!isDuplicate) {
        result.push(arr[i]);
    }
    }
    return result;
}
const arrLoop = [1, 2, 2, 3, 4, 4, 5];
const uniqueArrLoop = uniqueArrayLoop(arrLoop);
console.log(uniqueArrLoop); // 输出: [1, 2, 3, 4, 5]
```
- 代码细节：
  - 外层循环遍历数组 arr 中的每个元素。 
  - 内层循环遍历结果数组 result ，检查当前元素是否已经存在于 result中。 
  - 如果不存在，则将该元素添加到 result 中。
- 复杂度分析
  - 时间复杂度：$O(n^2)$，因为需要使⽤双重循环遍历数组。 
  - 空间复杂度：$O(n)$，主要⽤于存储去重后的结果数组。

## 31. 字符串反转算法
### 1.利⽤数组的 reverse ⽅法实现字符串反转
- 将字符串转换为字符数组，使⽤数组的 reverse ⽅法反转数组元素的顺序，再将反转后的数组转换回字符串。
```javascript
function reverseString(str) {
    return str.split('').reverse().join('');
}
const str = 'hello'; const reversedStr = reverseString(str);
console.log(reversedStr); // 输出: 'olleh'
```
- 代码细节：
  - str.split('') ：将字符串 str 转换为字符数组。 
  - .reverse() ：调⽤数组的 reverse ⽅法反转数组元素的顺序。 
  - .join('') ：将反转后的数组转换回字符串。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是字符串的⻓度。因为 split、 reverse 和 join 操作的时间复杂度都是 $O(n)$。 
  - 空间复杂度：$O(n)$，主要⽤于存储字符数组。
### 2. 利⽤循环实现字符串反转
- 通过循环从字符串的末尾开始，依次将每个字符添加到⼀个新字符串中，从⽽实现字符串反转。
```javascript
function reverseStringLoop(str) {
    let reversed ='';
    for (let i = str.length - 1; i >= 0; i--) {
        reversed += str[i];
    }
    return reversed;
}

const strLoop  = 'hello';
const reversedStrLoop = reverseStringLoop(strLoop);
console.log(reversedStrLoop); // 输出: 'olleh'
```
- 代码细节：
  - 初始化⼀个空字符串 reversed ⽤于存储反转后的字符串。 
  - 从字符串的最后⼀个字符开始，依次将字符添加到 reversed 中。
- 复杂度分析：
  - 时间复杂度：$O(n)$，其中 $n$ 是字符串的⻓度。因为需要遍历字符串⼀次。 
  - 空间复杂度：$O(n)$，主要⽤于存储反转后的字符串。

## 32. 斐波那契数列⽣成算法
### 1.递归实现
- 斐波那契数列的定义是：$F(0) = 0$，$F(1) = 1$，$F(n) = F(n - 1) + F(n - 2)$（$n \geq 2$）。可以使⽤递归的⽅式根据这个定义来⽣成斐波那契数列。
```javascript
function fibonacciRecursive(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
const n = 6;
const resultRecursive = fibonacciRecursive(n);
console.log(resultRecursive); // 输出: 8
```
- 代码细节：
  - 当 $n$ 为 0 或 1 时，直接返回 $n$。 
  - 当 $n$ ⼤于 1 时，递归调⽤ fibonacciRecursive 函数计算 $F(n - 1)$ 和$F(n - 2)$ 的值，并将它们相加。
- 复杂度分析
  - 时间复杂度：$O(2^n)$，因为递归调⽤会产⽣⼤量的重复计算，时间复杂度呈指数级增⻓。 
  - 空间复杂度：$O(n)$，主要是递归调⽤栈的深度。
### 2. 迭代实现
- 使⽤迭代的⽅式，从 $F(0)$ 和 $F(1)$ 开始，依次计算后续的斐波那契数，避免了递归带来的重复计算问题。
```javascript
function fibonacciIterative(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
const nIterative = 6;
const resultIterative = fibonacciIterative(nIterative);
console.log(resultIterative); // 输出: 8
```
- 代码细节：
  - 初始化两个变量 a 和 b 分别为 0 和 1。 
  - 通过循环从 2 到 $n$，依次计算下⼀个斐波那契数，并更新 a 和 b 的值。
- 复杂度分析： 
  - 时间复杂度：$O(n)$，因为只需要遍历⼀次从 2 到 $n$ 的所有数。 
  - 空间复杂度：$O(1)$，只使⽤了常数级的额外空间。


# 七、移动端适配
## 1. 传统rem适配⽅案
- 核心原理
```JavaScript
// flexible.js 核心代码片段
document.documentElement.style.fontSize =
document.documentElement.clientWidth / 10 + 'px';
```
> rem：根元素字体⼤⼩的倍数单位（1rem = 根字体⼤⼩）
> 动态计算：通过JS实时计算屏幕宽度，设置 <html> 的 font-size
> 设计稿换算：使⽤PostCSS插件将设计稿像素转换为rem单位（如750px设计稿
1rem=75px）

- 实现流程
	1. 引⼊ lib-flexible 或⾃研动态计算脚本
	2. 使⽤PostCSS插件 postcss-pxtorem ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 16, // 根元素字体⼤⼩，这⾥设置为 16px，可根据实际情况调整
      propList: ['*'], // 转换所有属性
        selectorBlackList: [], // 需要忽略的选择器列表，可根据需求添加，如['body'] 表示 body 元素下的 px 不转换
        minPixelValue: 2, // 最⼩转换像素值，⼩于该值的 px 不转换
        exclude: /node_modules/i // 排除 node_modules ⽬录下的⽂件
    }
  }
}
```
- 配置解释
  - rootValue ：根元素的字体⼤⼩，这⾥设置为 16px，即 1rem 等于 16px。在实际开发中，你可以根据设计稿的尺⼨进⾏调整。 
  - propList ：指定哪些 CSS 属性需要进⾏ px 到 rem 的转换， ['*'] 表示所有属性都转换。 
  - selectorBlackList ：指定需要忽略的选择器，这些选择器下的 px 不会被转换。 
  - minPixelValue ：设置最⼩的转换像素值，⼩于该值的 px 不会被转换。 
  - exclude ：排除某些⽬录下的⽂件，通常会排除 node_modules ⽬录。
- 现在你可以在组件的 CSS 中正常使⽤ px 单位， postcss - pxtorem 会在构建过程中⾃动将其转换为 rem 单位

- 优势分析
> 兼容性好：⽀持到Android 4.4+ / iOS 6.1+
> 精细控制：通过JS可实现复杂逻辑（如区分横竖屏）
> 历史惯性：⽼项⽬维护⽅便

- 主要缺陷
> JS依赖：需要等待JS执⾏才能完成布局计算
> 缩放失真：某些Android机型存在rem计算精度问题
> 维护成本：需要维护两套单位系统（rem + px）

- 注意事项：
  - 设计稿与根字体⼤⼩的对应关系：在实际开发中，需要根据设计稿的尺⼨来确定rootValue 的值。例如，如果设计稿是 750px 宽度，通常可以将 rootValue 设置为 75，这样在设计稿上量取的 px 值可以直接写在 CSS 中，插件会⾃动转换为合适的 rem 值。
  - 虽然 rem 适配⽅案在⼤多数现代浏览器中都能正常⼯作，但在⼀些旧版本的浏览器中可能存在兼容性问题，需要进⾏适当的测试和处理。

## 2. 现代vw/vh适配⽅案
- vw是视窗宽度的百分⽐，vh是视窗⾼度的百分⽐。⽐如，1vw表示屏幕宽度的 1%，1vh表示屏幕⾼度的1%。使⽤vw/vh可以很⽅便地实现元素的宽度和⾼度根据屏幕尺⼨⾃适应。
- 优点是简单直观，能很好地适应不同屏幕宽度，缺点是在⼀些特殊布局或需要精确控制元素位置时可能不太⽅便，⽽且部分旧浏览器兼容性略差。

- 核心原理
```css
/* 直接使⽤视⼝单位 */
.box {
  width: 50vw; /* 视⼝宽度的50% */
  height: 30vh; /* 视⼝⾼度的30% */
}
```
> vw：视⼝宽度百分⽐（1vw = 1%视⼝宽度）
> vh：视⼝⾼度百分⽐（1vh = 1%视⼝⾼度）
> ⽆需JS：纯CSS原⽣⽀持

- 实现流程
	1. 使⽤PostCSS插件 postcss-px-to-viewport ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 750, // 设计稿宽度
      unitPrecision: 5, // 转换精度
      viewportUnit: 'vw', // ⽬标单位
      selectorBlackList: ['.no-vw'], // 忽略类名
      minPixelValue: 1 // 最⼩转换像素
    }
  }
}
```
- 优势分析
> 原⽣⽀持：现代浏览器100%⽀持（包括iOS 8+/Android 4.4+）
> 渲染性能：避免JS计算导致的布局抖动
> 开发友好：设计稿直转vw，⽆需⼿动计算
> 响应灵敏：⾃动响应窗⼝⼤⼩变化

- 注意事项
> ⾼度适配：建议使⽤ vh 时配合 calc 计算安全区域
> 字体控制：可混合使⽤rem控制字体⼤⼩

```css
/* 混合⽅案示例 */
.title {
  font-size: 1.2rem; /* 使⽤rem保持⽂字可读性 */
  margin: 0 4vw; /* 使⽤vw保持间距响应 */
}
```

## 3. 方案对比决策
| 维度 | rem方案 | vw/vh方案 |
| - | - | - |
| 实现复杂度 | 需要JS + 构建工具 | 仅需构建工具 |
| 布局精度 | 存在0.01rem误差 | 精确到小数点后5位 |
| 渲染性能 | 存在JS执行延误 | 首屏渲染更快 |
| 维护成本 | 需维护动态计算逻辑 | 纯CSS配置 |
| 未来兼容性 | 逐渐淘汰 | CSS标准持续支持 |

- 补充1：媒体查询
  - 可以根据不同的媒体类型（如屏幕、打印等）和媒体特性（如屏幕宽度、分辨率等）来应⽤不同的CSS样式。例如，可以针对不同的屏幕宽度区间设置不同
    的样式，以实现适配。 
  - 优点是可以针对特定的屏幕尺⼨范围进⾏精细的样式调整，缺点是需要编写⼤量的媒体查询代码，维护起来可能较复杂，⽽且如果屏幕尺⼨变化范围很⼴， 可能需要编写很多组媒体查询。
- 补充2：Flex布局
  - 是⼀种弹性布局模型，通过设置⽗元素为flex布局，可以⽅便地控制⼦元素的排列⽅式、对⻬⽅式和伸缩⽐例等，使⻚⾯在不同屏幕尺⼨下能⾃适应排列。 
  - 优点是强⼤且灵活，能轻松实现各种复杂的布局⾃适应，缺点是对⼀些旧浏览器的兼容性有限，⽽且在某些特殊布局需求下可能不够直观。

## 4. 现在最佳实践
- 推荐方案：vw为主 + rem辅助
```css
/* 根元素设置（可选） */
:root {
	--base-font-size: calc(16px+ 0.5vw); /* 基础字体响应式 */
}
/* 混合使⽤示例 */
.container {
  width: 90vw;
  max-width: 750px; /* 桌⾯端限制最⼤宽度 */
}
.text {
	font-size: 1.2rem; /* 保持⽂字可读性 */
}
```

- 关键配置技巧
```css
/*安全区域适配：使⽤ env(safe-area-inset-*) */
body {
	padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* 1px边框解决⽅案：结合 transform + viewport */
.border-1px {
  position: relative;
  &::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #ddd;
    transform: scaleY(0.5);
    transform-origin: 0 0;
  }
}
```

- 构建工具配置
```javascript
// 现代工程化配置示例（Vue/React通用）
module.exports = {
  plugins: [
    require('postcss-px-to-viewport')({
    viewportWidth: 750 ,
    viewportUnit: 'vw',
    fontViewportUnit: 'rem', // 字体单独使用rem
    require("postcss-flexbugs-fixes"),
    require('postcss-viewport-units') // ⾃动添加兼容前缀
  ]
},
```

## 5. 升级迁移策略
- 渐进式迁移
```css
/*新⻚⾯直接使⽤vw⽅案*/
/*旧⻚⾯通过 @media 逐步替换*/
/* 兼容代码示例 */
.old-box {
  width: 10rem;
  @media (min-width: 320px) {
  	width: 50vw;
  }
}
```
- 降级处理
```css
.modern-box {
  width: 50vw;
  width: 10rem; /* 旧浏览器回退 */
}
```
- 监控覆盖：
```JavaScript
/*使⽤ Modernizr 检测浏览器⽀持*/
if (!Modernizr.cssvwunit) {
	loadScript('legacy-rem-polyfill.js');
}
```

## 6. 总结建议
- 新项⽬⾸选： vw/vh + postcss-px-to-viewport ⽅案
- ⽼项⽬维护：继续使⽤rem⽅案保持稳定
- 混合场景：核⼼布局⽤vw，字体/间距⽤rem
- 特殊需求：结合CSS容器查询（ @container ）实现更智能响应
> 现代浏览器对viewport单位的⽀持已⾮常成熟，拥抱CSS原⽣⽅案能获得更好的性能表
现和开发体验。对于需要兼容极旧浏览器的特殊项⽬（如政府/银⾏系统），可考虑保留rem⽅案作为兜底。

## 7. 相关库和⼯具
- lib-flexible 
  - 是⼿淘团队开发的⼀个⽤于H5⻚⾯适配的库。它主要通过动态修改html元素的font-size来实现rem适配，并且能根据不同的屏幕宽度进⾏合理的计算和设置，简化了rem适配的开发过程。
- postcss-pxtorem 
  - 是⼀个PostCSS插件，它可以在构建过程中⾃动将CSS中的px单位转换为rem单位，⼤⼤提⾼了开发效率，减少了⼿动计算rem值的⼯作量。 
- Autoprefixer 
  - 是⼀个CSS⾃动添加浏览器前缀的⼯具。由于不同浏览器对CSS属性的⽀持和实现⽅式不同，有些CSS属性需要添加特定的浏览器前缀才能在不同浏览器中正常显示。Autoprefixer可以根据配置的浏览器兼容列表，⾃动为CSS属性添加相应的前缀，如-webkit-、-moz-、-ms-等，提⾼了CSS的兼容性。

# 八、框架部分
## 1. usestate 和 useref 区别？- React
-  useState 和 useRef 是 React Hooks 中的两个钩⼦。 useState ⽤于在函数组件中添加状态，当状态更新时，组件会重新渲染。 useRef 创建⼀个可变的对象，它的值在组件的整个⽣命周期内保持不变，并且修改它不会触发组件重新渲染。
```javascript
import React, { useState, useRef } from 'react';
function Example() {
    const [count, setCount] = useState(0);
    const refCount = useRef(0);
};
const incrementState = () => {
setCount(count + 1);
const incrementRef = () => {
    refCount.current++;
    console.log('Ref count:', refCount.current);
};
return (
    <div>
        <p>State count: {count}</p>
        <button onClick={incrementState}>Increment State</button>
        <button onClick={incrementRef}>Increment Ref</button>
    </div>
    );
}
export default Example;
```
- 代码细节： useState 返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染。 useRef 返回⼀个对象，通过 current 属性访问和修改其值。
- 案例应⽤： useState 适⽤于需要触发组件重新渲染的状态管理，如表单输⼊值、 计数器等。 useRef 适⽤于保存不需要触发重新渲染的值，如 DOM 节点引⽤、定时器 ID 等。

## 2. 为什么有 hooks？hooks 是⼲什么⽤的？
- 在 React 中，Hooks 是 React 16.8 引⼊的新特性，主要是为了解决类组件的⼀些问题，如代码复⽤困难、逻辑复杂时难以拆分等。Hooks 可以让你在不编写class 的情况下使⽤ state 以及其他 React 特性。
```javascript
import React, { useState } from'react';
function Counter() {
const [count, setCount] = useState(0);
return (
    <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
            Click me
        </button>
    </div>
);
}
export default Counter;
```
- 代码细节： useState 是⼀个 Hook，它返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染并更新count 的显示值。 
- 案例应⽤：Hooks 使得函数组件可以有状态，并且可以将复杂的逻辑拆分成多个⼩的 Hook，提⾼代码的复⽤性和可维护性。例如在多个组件中复⽤表单验证逻辑、数据获取逻辑等。

## 3. 常⻅的 hooks？
- React 提供了多个内置的 Hooks，还有很多社区⾃定义的 Hooks，常⻅的内置 Hooks 可以帮助开发者在函数组件中使⽤不同的 React 特性。
```javascript
// useState ：⽤于在函数组件中添加状态。
import React, { useState } from'react';
function Example() {
    const [count, setCount] = useState(0);
    return (
        <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count +
        1)}>Increment</button>
        </div>
    );
}
// useEffect：⽤于处理副作⽤，如数据获取、订阅、DOM 操作等。
import React, { useState, useEffect } from'react';
function DataFetching() {
    const [data, setData] = useState(null);
    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []);
    return (
        <div>
            {data? 
                <p>{data.message}</p> : <p>Loading...</p>}
        </div>
    );
}
// useContext：⽤于在组件之间共享数据，避免层层传递 `props`。
import React, { createContext, useContext } from'react';
const ThemeContext = createContext();
function ThemeProvider({ children }) {
    const theme= 'dark';
    return (
        <ThemeContext.Provider value={theme}>
            {children}
        </ThemeContext.Provider>
            
    );
}
function ChildComponent() {
    const theme = useContext(ThemeContext);
    return <p>Current theme: {theme}</p>;
}
function App() {
    return (
        <ThemeProvider>
            <ChildComponent />
        </ThemeProvider>
    );
}
```
- 案例应⽤：不同的 Hooks 适⽤于不同的场景， useState ⽤于状态管理， useEffect ⽤于处理异步操作和副作⽤， useContext ⽤于组件间数据共享。

## 4. 原生的hooks
- 原⽣的 Hooks 指的是 React 官⽅提供的内置 Hooks，它们是 React 核⼼库的⼀部分，可以直接在 React 项⽬中使⽤。
- 常⻅原⽣ Hooks 总结：
  - useState ：管理组件的状态，允许函数组件有状态变化。 
  - useEffect ：处理副作⽤，如数据获取、订阅、DOM 操作等。在组件渲染后或依赖项变化时执⾏回调函数。 
  - useContext ：获取上下⽂对象，⽤于在组件树中共享数据。 
  - useReducer ：类似于 Redux 的 reducer 模式，⽤于管理复杂的状态逻辑。 
  - useCallback ：返回⼀个记忆化的回调函数，⽤于优化性能，避免不必要的函数重新创建。 
  - useMemo ：返回⼀个记忆化的值，⽤于优化性能，避免不必要的计算。 
  - useRef ：创建⼀个可变的引⽤对象，通常⽤于保存 DOM 节点或在组件的整个⽣命周期内保持值不变。 
  - useImperativeHandle ：⽤于⾃定义使⽤ ref 时暴露给⽗组件的实例值。 
  - useLayoutEffect ：与 useEffect 类似，但会在 DOM 更新后同步执⾏，常⽤于需要测量 DOM 布局的场景。 
  - useDebugValue ：⽤于在 React DevTools 中显示⾃定义 Hook 的调试信息。 
- 案例应⽤：在不同的开发场景中选择合适的原⽣ Hooks 可以提⾼开发效率和组件性能，例如在性能敏感的组件中使⽤ useCallback 和 useMemo 进⾏优化。

## 5. useContext 如何进⾏组件之间的传输？
- useContext 结合 createContext 和 Context.Provider 实现组件间的数据传输。 createContext 创建⼀个上下⽂对象， Context.Provider ⽤于提供数据， useContext ⽤于在组件中获取上下⽂对象中的数据。
```javascript
import React, { createContext, useContext } from'react';
// 创建上下⽂对象
const UserContext = createContext();
// 提供数据的组件
function UserProvider({ children }) {
    const user = { name: 'John', age: 30 };
    return (
        <UserContext.Provider value={user}>
            {children}
        </UserContext.Provider>
    );
}
// 接收数据的组件
function DisplayUser() {
    const user = useContext(UserContext);
    return (
        <div>
            <p>Name: {user.name}</p>
            <p>Age: {user.age}</p>
        </div>
    );
}
function App() {
    return (
        <UserProvider>
            <DisplayUser />
        </UserProvider>
    );
}
export default App;
```
- 代码细节：
  - 使⽤ createContext 创建 UserContext 。 
  - UserProvider 组件使⽤ UserContext.Provider 包裹⼦组件，并通过 value 属性提供数据。 
  - DisplayUser 组件使⽤ useContext(UserContext) 获取上下⽂对象中的数据并显示。
- 案例应⽤：在多层嵌套的组件结构中，当多个组件需要访问相同的数据时，使⽤useContext 可以避免通过 props 层层传递数据，提⾼代码的简洁性和可维护性。

## 6. 虚拟 DOM 的理解
- 虚拟 DOM（Virtual DOM）是⼀种轻量级的 JavaScript 对象，它是真实DOM 的抽象表示。当组件状态发⽣变化时，React 等框架会先计算虚拟 DOM 的差异（Diffing 算法），然后将差异批量更新到真实 DOM 上，这样可以减少直接操作真实 DOM 的次数，提⾼性能。
- 代码案例（简单模拟虚拟 DOM 更新）：
```javascript
// 虚拟 DOM 节点类
class VNode {
    constructor(tag, props, children) {
        this.tag = tag;
        this.props = props;
        this.children = children;
    }
}
// 创建虚拟 DOM
const oldVNode = new VNode('div', { id: 'old' }, ['Old content']);
const newVNode = new VNode('div', { id: 'new' }, ['New content']);
// 简单的 Diff 算法和更新函数
function diff(oldVNode, newVNode) {
    if (oldVNode.tag!== newVNode.tag || oldVNode.props.id!==newVNode.props.id) {
        // 这⾥简单模拟更新操作
        console.log('Update DOM');
    }
}
diff(oldVNode, newVNode);
```
- 代码细节：定义了⼀个 VNode 类来表示虚拟 DOM 节点。创建了旧的和新的虚拟DOM 节点，通过 diff 函数⽐较它们的差异，若有差异则进⾏更新操作。
- 案例应⽤：在 React、Vue 等前端框架中⼴泛使⽤虚拟 DOM 来优化 DOM 操作。例如在⼀个列表组件中，当列表数据更新时，框架会通过虚拟 DOM 计算差异，只更新需要更新的部分，⽽不是重新渲染整个列表。

## 7. Vue3，有哪些改进
- Vue3 在性能、开发体验、代码组织等⽅⾯进⾏了诸多改进。采⽤了 Proxy 实现响应式系统，提⾼了响应式的性能和功能；引⼊了组合式 API，使代码更易于复⽤和维护；重构了虚拟 DOM 实现，优化了渲染性能。
```vue
<template>
    <div>
      <p>{{ count }}</p>
      <button @click="increment">Increment</button>
    </div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(0);
const increment = () => {
    count.value++;
};
</script>
```
- 代码细节：使⽤ script setup 语法和组合式 API， ref 函数创建响应式数据 count ，通过 count.value 访问和修改其值。点击按钮时调⽤ increment 函数 更新 count 的值。
- 案例应⽤：组合式 API 使得代码逻辑可以按照功能进⾏分组，提⾼了代码的可读性和可维护性。例如在⼤型项⽬中，不同的功能模块可以独⽴封装和复⽤。

## 8. vue双向绑定原理
- Vue 的双向绑定是通过数据劫持结合发布 - 订阅模式实现的。在 Vue2 中，使⽤ Object.defineProperty() 对数据对象的属性进⾏劫持，当属性值发⽣变化时，触发 setter ⽅法通知所有订阅者更新视图；在 Vue3 中，使⽤ Proxy 对象进⾏数据劫持。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2 Two - way Binding</title>
</head>
<body>
<input type="text" id="input">
<p id="output"></p>
<script>
    const data = {message: ''};
    // 数据劫持
    Object.defineProperty(data, 'message', {
        get() {
            return this._message;
        },
        set(newValue) {
            this._message = newValue;
            document.getElementById('output').textContent = newValue;
        }})
    const input = document.getElementById('input');
    input.addEventListener('input', function () {
        data.message = this.value;
    });
    // 初始化输出
    document.getElementById('output').textContent = data.message;
</script>
</body>
</html>
```
- 代码细节：使⽤ Object.defineProperty 对 data 对象的 message 属性进⾏劫持，当 message 属性被赋值时， setter ⽅法会被触发，更新⻚⾯上的 p 元素内容。同时，给输⼊框添加 input 事件监听器，当输⼊框内容变化时，更新data.message 的值，从⽽实现双向绑定。
- 案例应⽤：在表单输⼊场景中，如⽤户登录、注册表单，通过双向绑定可以⽅便地将⽤户输⼊的数据同步到数据对象中，同时将数据对象的变化反映到⻚⾯上。

## 9.  在什么阶段进⾏ DOM 操作
- 在前端开发中，不同的框架和场景有不同的适合进⾏ DOM 操作的阶段。在原⽣ JavaScript 中，通常在 DOMContentLoaded 事件触发后进⾏ DOM 操作，确保⽂档已经解析完成。在 Vue 中，可以在 mounted ⽣命周期钩⼦中进⾏ DOM 操作，此时组件已经挂载到 DOM 上。在 React 中，可以使⽤ useEffect 钩⼦在组件渲染后进⾏ DOM 操作。
```vue
<template>
    <div>
      <p ref="myParagraph">This is a paragraph.</p>
    </div>
</template>
<script>
export default {
    mounted() {
        const paragraph = this.$refs.myParagraph;
        paragraph.style.color ='red';
    }
};
</script>
```
- 代码细节：在 Vue 组件的 mounted 钩⼦中，通过 this.$refs 获取到 p 元素的 引⽤，然后修改其样式。
- 案例应⽤：当需要对⻚⾯上的元素进⾏样式修改、添加事件监听器等操作时，选择合适的阶段进⾏ DOM 操作可以避免出现元素未加载完成的错误。

## 10. hash 模式和 history 模式有什么区别？
- Vue 路由（Vue Router）是 Vue.js 官⽅的路由管理器，它的实现基于单⻚⾯应⽤（SPA）的原理。主要通过监听浏览器的 URL 变化，根据配置的路由规则匹配相应的组件，并将组件渲染到指定的路由出⼝（ <router - view> ）中。
- 在前端路由中，hash 模式和 history 模式是两种不同的实现⽅式，主要区别在于 URL 的表现形式和浏览器历史记录的管理。
- URL 表现形式：
  - hash 模式：URL 中使⽤ # 符号来分隔路径，例如http://example.com/#/home。 # 后⾯的内容不会发送到服务器，浏览器只会根据 # 后⾯的路径进⾏前端路由匹配。 
  - history 模式：URL 看起来像正常的路径，例如http://example.com/home 。它使⽤ HTML5 的 History API 来管理浏 览器历史记录，路径会发送到服务器。
- 浏览器历史记录管理：
  - hash 模式：每次 # 后⾯的路径变化都会添加⼀条新的历史记录，通过浏览器的前进后退按钮可以在这些历史记录之间切换。 
  - history 模式：使⽤ pushState 和 replaceState ⽅法来操作浏览器历史记录，也可以实现前进后退功能，但需要服务器端的⽀持，因为服务器需要对不同的路径返回相同的 HTML ⽂件。
```javascript
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
Vue.use(VueRouter);
const routes = [
    {
        path: '/home',
        name: 'Home',
        component: Home
    },
    {
        path: '/about',
        name: 'About',
        component: About
    }
];
// hash 模式
const routerHash = new VueRouter({
    mode: 'hash',
    routes
});
// history 模式
const routerHistory = new VueRouter({
    mode: 'history',
    routes
});
```
- 案例应⽤：hash 模式适合简单的单⻚应⽤，不需要服务器端额外配置；history 模式适合对 URL 美观性有要求的应⽤，但需要服务器端进⾏相应的配置，如在Node.js 中使⽤ Express 框架时需要配置中间件来处理不同路径的请求。
- 应用场景：
  - 单⻚⾯应⽤（SPA）：如企业官⽹、后台管理系统等，通过 Vue Router 可以实现⻚⾯的切换和导航，给⽤户带来流畅的交互体验。
  - 多⻚⾯应⽤（MPA）：在⼀些复杂的多⻚⾯应⽤中，也可以使⽤ Vue Router 来管理局部的路由，实现局部⻚⾯的动态加载和切换。
```vue
<template>
<div id="app">
<router-link to="/">Home</router-link>
<router-link to="/about">About</router-link>
<router-view></router-view>
</div>
</template>
<script>
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
Vue.use(VueRouter);
const routes = [
    {
    path: '/',
    name: 'Home',
    component: Home
    },
    {
    path: '/about',
    name: 'About',
    component: About
    }
];
const router = new VueRouter({
    mode: 'hash',
    routes
});
new Vue({
    router,
    render: h => h('div', { id: 'app' })
}).$mount('#app');
</script>
```
- 解析：上述代码定义了⼀个简单的 Vue 应⽤，使⽤ Vue Router 实现了两个路由： / 和 /about 。通过 <router - link> 组件创建导航链接，点击链接时会改变 URL 的路径。 <router - view> 是路由出⼝，匹配到的组件会渲染到这个位置。在 main.js 中，⾸先引⼊ VueRouter 并使⽤ Vue.use(VueRouter) 安装插件。然后定义路由规则数组 routes ，每个规则包含路径 path 、路由名称 name 和对应的组件 component 。接着创建 VueRouter 实例，指定路由模式为 hash ，并将路由规则传 ⼊。最后将路由实例挂载到 Vue 实例上。
- 兼容性：
  - Hash 路由模式：兼容性⾮常好，⼏乎所有的浏览器都⽀持哈希值的变化和 hashchange 事件。因此，在需要兼容旧版本浏览器的项⽬中，Hash 路由是⼀个⽐较稳妥的选择。
  - History 路由模式：依赖于 HTML5 的 History API ，因此在⼀些旧版本的浏览器中可能不⽀持。在使⽤ History 路由模式时，需要考虑项⽬的⽬标⽤户群体，如果需要兼容旧版本浏览器，可能需要进⾏额外的处理或者降级到 Hash 路由模式。
- 浏览器历史记录管理
  - Hash 路由模式：哈希值的变化会在浏览器的历史记录中留下记录，⽤户可以通过点击浏览器的前进、后退按钮来切换不同的哈希值状态。但是，由于哈希值的变化不会向服务器发送请求，因此历史记录中的每个状态对应的⻚⾯内容实际上是由前端代码控制的。
  - History 路由模式：利⽤ History API 可以更加灵活地管理浏览器的历史记录。 pushState ⽅法可以在不刷新⻚⾯的情况下向历史记录中添加⼀条新记录， replaceState ⽅法可以替换当前的历史记录。这种⽅式可以实现更复杂的历史记录管理，例如在不影响⽤户操作的情况下修改 URL。

## 11. Vue的diff算法优化（Vue2和3之间做了什么优化）
- Vue2 的 Diff 算法：Vue2 采⽤的是基于虚拟 DOM 的双指针⽐较算法，使⽤snabbdom 库实现。它会对新旧虚拟 DOM 树进⾏深度优先遍历，通过⽐较新旧节点的 key、tag、data 等属性来判断节点是否需要更新。在更新⼦节点时，会采⽤双指针法，对新旧⼦节点数组进⾏⽐较，找到可复⽤的节点并进⾏移动、插⼊或删除操作。但这种算法在处理⼤规模列表更新时，由于需要频繁地进⾏全量⽐较，性能开销较⼤。
- Vue3 的 Diff 算法优化：Vue3 对 Diff 算法进⾏了多⽅⾯的优化。⾸先引⼊了静态标记（PatchFlag），对于模板中的静态节点会标记为静态节点，在 Diff 过程中直接跳过这些节点的⽐较，⼤⼤减少了⽐较的⼯作量。其次，在处理动态节点时，采⽤了快速 Diff 算法，结合最⻓递增⼦序列算法，能更⾼效地找到可复⽤的节点，减少节点的移动操作，提⾼了更新效率。
- 应用场景：
  - Vue2：适⽤于⼩型项⽬或者对性能要求不是特别⾼的项⽬，因为其 Diff 算法虽然在处理复杂更新时性能有限，但对于简单的⻚⾯更新已经⾜够。 
  - Vue3：更适合⼤型项⽬和需要频繁进⾏数据更新的场景，如实时数据展示、交互式应⽤等，其优化后的 Diff 算法能显著提升性能。
- 代码案例：以下是⼀个简单的 Vue2 和 Vue3 列表更新的示例，通过对⽐可以感受两者的差异，但由于 Diff 算法是底层实现，代码中不会直接体现其细节。
- Vue2示例：
```vue
<template>
<div>
<ul>
    <li v-for="item in list" :key="item.id">{{ item.name }}</li>
</ul>
    <button @click="updateList">Update List</button>
</div>
</template>
<script>
export default {
    data() {
        return {
        list: [
            { id: 1, name: 'Item 1' },
            { id: 2, name: 'Item 2' },
            { id: 3, name: 'Item 3' }
        ]
        };
    },
    methods: {
    updateList() {
        this.list = [
            { id: 3, name: 'Item 3' },
            { id: 1, name: 'Item 1' },
            { id: 2, name: 'Item 2' }
            ];
        }
    }
};
</script>
```
- Vue3示例：
```vue
<template>
<div>
<ul>
  <li v-for="item in list" :key="item.id">{{ item.name }}</li>
</ul>
  <button @click="updateList">Update List</button>
</div>
</template>
<script setup>
import { ref } from 'vue';
const list = ref([
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' }
]);
const updateList = () => {
    list.value = [
        { id: 3, name: 'Item 3' },
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' }
    ];
};
</script>
```
- 解析：在上述代码中，Vue2 和 Vue3 的模板和功能基本相同，都是展示⼀个列表并提供⼀个按钮⽤于更新列表。但在底层，Vue3 的 Diff 算法会更⾼效地处理列表的更新，尤其是当列表元素顺序发⽣变化时，能更快地完成节点的移动和更新操作。

## 12. 如何进⾏组件的⼆次封装
- 明确封装⽬的：在开始⼆次封装之前，要清楚为什么要进⾏封装。常⻅的⽬的包括：
  - 提⾼复⽤性：将⼀些常⽤的功能或样式封装成⼀个通⽤组件，⽅便在多个项⽬或⻚⾯中使⽤。 
  - 简化使⽤：对⼀些复杂的原⽣组件或第三⽅组件进⾏简化，使其使⽤起来更加⽅便快捷。 
  - 统⼀⻛格：确保项⽬中使⽤的组件具有统⼀的外观和交互⻛格。
- ⼆次封装的步骤
### 1. 选择合适的基础组件
> 可以是原⽣ HTML 元素、框架⾃带的组件，或者第三⽅开源组件。例如，在 Vue 项⽬中，可能会对 input 元素、 el - input （Element UI 组件）等进⾏⼆次封装。

### 2. 分析基础组件的属性、方法和事件
> 了解基础组件提供了哪些属性可以配置、哪些⽅法可以调⽤以及会触发哪些事件。这有助于在⼆次封装时进⾏合理的继承和扩展。

### 3. 定义新组建的属性、方法和事件
- 属性：根据封装⽬的，定义新组件需要接收的属性。可以对基础组件的属性进⾏筛选和扩展。例如，封装⼀个 Input 组件时，可以定义placeholder、 value 、 disabled 等属性，同时还可以添加⼀些⾃定义属性，如 maxLength 来限制输⼊的最⼤⻓度。
```vue
<template>
<input :value="value" :placeholder="placeholder" :disabled="disabled" @input="handleInput">
</template>
<script>
export default {
    props: {
        value: {
            type: String,
            default: ''
        },
        placeholder: {
            type: String,
            default: '请输⼊内容'
        },
        disabled: {
            type: Boolean,
            default: false
        },
        maxLength: {
            type: Number,
            default: 50
        }
    },
    methods: {
        handleInput(event) {
            this.$emit('input', event.target.value.slice(0, this.maxLength));
        }
    }
}
</script>
```
- ⽅法：可以定义新组件⾃⼰的⽅法，也可以对基础组件的⽅法进⾏封装和调⽤。例如，封装⼀个 Modal 组件时，可以定义 open 和 close ⽅法来控制模态框的显示和隐藏。
```vue
<template>
    <div v-if="visible" class="modal">
        <!-- 模态框内容 -->
        <button @click="close">关闭</button>
    </div>
</template>
<script>
export default {
    data() {
        return {
            visible: false
        };
    },
    methods: {
        open() {
            this.visible = true;
        },
        close() {
            this.visible = false;
        }
    }
}
</script>
```
- 事件：要处理好基础组件触发的事件，并可以根据需要触发新的⾃定义事件。例如，在封装 Input 组件时，将基础 input 元素的 input 事件进⾏处理后，触发⾃定义的 input 事件，⽅便⽗组件监听。
### 4. 样式定制
- 继承基础组件样式：可以通过 CSS 类名或样式绑定的⽅式继承基础组件的样式。例如，在封装 Button 组件时，可以使⽤基础按钮的类名，同时添加⾃定义的类名来修改样式。
```vue
<template>
  <button :class="['base-button', customClass]">{{ label }}</button>
</template>
<script>
export default {
    props: {
        label: {
            type: String,
            default: '按钮'
        },
        customClass: {
            type: String,
            default: ''
        }
    }
}
</script>
<style scoped>
    .base-button {
        /* 基础按钮样式 */
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
    }
</style>
```
- 提供样式配置选项：可以通过属性来控制组件的样式，使组件的外观更加灵活。例如，定义⼀个 size 属性，根据不同的值显示不同⼤⼩的按钮。
### 5. 测试和优化
- 对⼆次封装的组件进⾏全⾯的测试，确保其功能正常、样式符合预期，并且在不同的使⽤场景下都能稳定⼯作。 
- 根据测试结果进⾏优化，例如优化性能、修复 bug、改进⽤户体验等。
- ⼆次封装组件需要综合考虑属性、⽅法、事件和样式的设计，以实现提⾼复⽤性、简化使⽤和统⼀⻛格的⽬的。通过以上步骤，可以创建出⾼质量的⼆次封装组件。

## 13. Vue插槽slot
- 插槽（Slot）是 Vue 中⼀个⾮常实⽤的特性，它允许你在封装组件时为组件提供灵活的内容插⼊机制，让组件可以根据不同的使⽤场景插⼊不同的内容，提⾼组件的复⽤性和灵活性。下⾯从概念、分类、使⽤⽅法等⽅⾯详细介绍插槽。
- 比如，⼀个通⽤的卡⽚组件，这个卡⽚组件有固定的样式和布局，但卡⽚内部的具体内容可能会根据不同的⻚⾯需求⽽变化。插槽就像是在这个卡⽚组件上预留的“空位”，在使⽤这个卡⽚组件时，你可以往这些“空位”⾥插⼊⾃定义的内容，⽐如图⽚、⽂字、按钮等。
- 插槽的分类和使用方法
### 1. 匿名插槽（默认插槽）
- 匿名插槽是最基本的插槽类型，它没有具体的名称，⽤于在组件中插⼊单个默认的内容区域。
- 使用方法：
  - 定义组件：在组件模板中使⽤ <slot></slot> 标签来定义插槽位置。
```vue
<!-- CustomCard.vue -->
<template>
<div class="custom-card">
    <div class="card-header">卡⽚头部</div>
    <slot></slot> <!-- 匿名插槽 -->
    <div class="card-footer">卡⽚底部</div>
</div>
</template>
<style scoped>
    .custom-card {
    border: 1px solid #ccc;
    padding: 10px;
    }
    .card-header {
    font-weight: bold;
    }
    .card-footer {
    color: #999;
    }
</style>
```
  - 使⽤组件：在使⽤该组件时，直接在组件标签内插⼊要显示的内容，这些内容会被插⼊到插槽的位置。
```vue
<template>
<div>
    <CustomCard>
        <p>这是卡⽚的主体内容。</p>
    </CustomCard>
</div>
</template>
<script>
import CustomCard from './CustomCard.vue';
export default {
    components: {CustomCard}
};
</script>
```
### 2. 具名插槽
- 概念：当组件需要多个不同的内容插⼊位置时，就可以使⽤具名插槽。每个插槽有⼀个唯⼀的名称，通过名称来区分不同的插⼊位置。
- 使用方法
  - 定义组件：在组件模板中使⽤ <slot name="插槽名称"></slot> 标签来定义具名插槽。
```vue
<!-- CustomLayout.vue -->
<template>
<div class="custom-layout">
    <header>
        <slot name="header"></slot> <!-- 具名插槽：头部 -->
    </header>
    <main>
        <slot></slot> <!-- 匿名插槽：主体内容 -->
    </main>
    <footer>
        <slot name="footer"></slot> <!-- 具名插槽：底部 -->
    </footer>
</div>
</template>
<style scoped>
.custom-layout {
    display: flex;
    flex-direction: column;
    height: 100vh;
}
header {
    background-color: #333;
    color: white;
    padding: 10px;
}
main {
    flex: 1;
    padding: 20px;
}
footer {
    background-color: #333;
    color: white;
    padding: 10px;
    text-align: center;
}
</style>
```
  - 使⽤组件：在使⽤该组件时，使⽤ `<template #插槽名称>` （Vue 3 语法，Vue 2中使⽤ `<template slot="插槽名称">`）来指定要插⼊到哪个具名插槽中。
```vue
<template>
<div>
    <CustomLayout>
        <template #header>
            <h1>⻚⾯标题</h1>
        </template>
        <p>这是⻚⾯的主体内容。</p>
        <template #footer>
            <p>版权所有 &copy; 2024</p>
        </template>
    </CustomLayout>
</div>
</template>
<script>
import CustomLayout from './CustomLayout.vue';
export default {
components: {CustomLayout}
};
</script>
```
### 3. 作用域插槽
- 作⽤域插槽允许在⽗组件中访问⼦组件的数据。⼦组件可以将⾃⼰的数据通过插槽传递给⽗组件，⽗组件可以根据这些数据进⾏不同的渲染。
- 使用方法
  - 定义组件：在组件模板中，通过 <slot :数据名称="数据值"></slot> 的⽅式将数据传递给插槽。
```vue
<!-- UserList.vue -->
<template>
<ul>
    <li v-for="user in users" :key="user.id">
        <slot :user="user"></slot> <!-- 作⽤域插槽，传递 user 数据 -->
    </li>
</ul>
</template>

<script>
export default {
data() {
    return {
        users: [
            { id: 1, name: '张三' },
            { id: 2, name: '李四' },
            { id: 3, name: '王五' }
        ]
    }
}
}
</script>
```
  - 使⽤组件：在使⽤该组件时，通过 `<template #default="{ 数据名称 }">`（Vue 3 语法，Vue 2 中使⽤ `<template slot-scope="{ 数据名称 }">`）来接收⼦组件传递的数据，并使⽤这些数据进⾏渲染。
```vue
<template>
<div>
    <UserList>
        <template #default="{ user }">
            <span>{{ user.name }}</span>
        </template>
    </UserList>
</div>
</template>
<script>
import UserList from './UserList.vue';
export default {
components: {UserList}
};
</script>
```
- 总结：插槽是 Vue 中实现组件灵活复⽤的重要特性，通过匿名插槽、具名插槽和作⽤域插槽， 你可以在封装组件时为不同的内容插⼊需求提供解决⽅案，使组件更加通⽤和强⼤

## 14. 静态组件和动态组件区别
- 在 Vue 中，动态组件和静态组件的核⼼区别在于 组件的渲染时机和灵活性。以下是详细对⽐和实际应⽤场景分析：
### 1. 核心区别对比





# 九、工程化
## 1. webpack 的作⽤，说说你对他的理解
- Webpack 是⼀个模块打包⼯具，它可以将各种类型的模块（如 JavaScript、CSS、图⽚等）打包成⼀个或多个⽂件，主要⽤于优化前端项⽬的资源管理和性能。
- 主要作用：
  - 模块打包：Webpack 可以处理项⽬中的各种模块依赖关系，将所有的模块打包成⼀个或多个⽂件，减少浏览器的请求次数，提⾼⻚⾯加载速度。例如，⼀个项⽬中有多个 JavaScript ⽂件和 CSS ⽂件，Webpack 可以将它们打包成⼀个或⼏个⽂件。
  - 资源处理：通过使⽤不同的 loader 和 plugin，Webpack 可以处理各种类型的资源，如将 Sass 或 Less 转换为 CSS，压缩图⽚，处理字体⽂件等。
  - 代码分割：Webpack ⽀持代码分割，可以将项⽬代码分割成多个⼩块，实现按需加载。例如，将不同⻚⾯的代码分割成不同的⽂件，当⽤户访问某个⻚⾯时，只加载该⻚⾯所需的代码。
```javascript
// 代码案例（简单配置示例）：
const path = require('path');
module.exports = {
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            }
        ]
    }
};
```
- 代码细节：
  - entry ：指定项⽬的⼊⼝⽂件，Webpack 会从该⽂件开始分析模块依赖关系。 
  - output ：指定打包后的⽂件输出路径和⽂件名。 
  - module.rules ：配置不同类型⽂件的 loader，例如对于 .css ⽂件，使⽤style-loader 和 css-loader 进⾏处理。
- 案例应⽤：在⼤型前端项⽬中，Webpack 可以帮助开发者更好地管理项⽬的资源和依赖关系，提⾼开发效率和项⽬性能。例如，在 React 或 Vue 项⽬中，通常会使⽤Webpack 进⾏打包和构建。

## 2. 前端工程化
- 端⼯程化是指将软件开发的⼯程⽅法应⽤于前端开发，通过⼀系列⼯具、流程和规范来提⾼前端开发的效率、质量和可维护性。
- 主要方面：
  - 模块化开发：将项⽬拆分成多个⼩的模块，每个模块具有独⽴的功能和职责，提⾼代码的复⽤性和可维护性。例如，使⽤ ES6 的模块语法（ import 和 export ）或 CommonJS 规范进⾏模块开发。 
  - ⾃动化构建：使⽤构建⼯具（如 Webpack、Gulp 等）⾃动完成代码的编译、 打包、压缩、合并等任务，减少⼈⼯操作，提⾼开发效率。 
  - 代码规范：制定统⼀的代码规范和⻛格指南，如 ESLint、Prettier 等⼯具可以帮助开发者检查和修复代码中的语法错误和⻛格问题，保证代码的⼀致性。 
  - 版本控制：使⽤版本控制系统（如 Git）来管理项⽬的代码，⽅便团队协作和代码的回溯、分⽀管理等。 
  - 测试和部署：建⽴⾃动化测试流程，使⽤测试框架（如 Jest、Mocha 等）对代码进⾏单元测试、集成测试等，确保代码的质量。同时，实现⾃动化部署，将代码部署到⽣产环境。
- 案例应⽤：在⼀个多⼈协作的前端项⽬中，通过前端⼯程化的⽅法，可以规范开发流程，提⾼团队协作效率，减少代码冲突和错误，同时提⾼项⽬的可维护性和性能。

## 3. vite 和 webpack 的区别
- Vite 和 Webpack 都是前端构建⼯具，但它们的实现原理和适⽤场景有所不同。
- 启动速度
  - Vite：基于原⽣ ES 模块，在开发环境下采⽤按需加载的⽅式，不需要像Webpack 那样对整个项⽬进⾏打包，因此启动速度⾮常快。当修改代码时，Vite 可以实现快速的热更新，只更新修改的模块。 
  - Webpack：在启动时需要对整个项⽬进⾏打包，分析模块依赖关系，因此启动速度相对较慢，尤其是在⼤型项⽬中。
- 构建⽅式：
  - Vite：开发环境下利⽤浏览器的原⽣ ES 模块⽀持，直接在浏览器中加载模块。⽣产环境下使⽤ Rollup 进⾏打包，将代码打包成适合⽣产环境的⽂ 件。 
  - Webpack：使⽤⾃⼰的打包机制，通过 loader 和 plugin 处理各种类型的模块，将所有模块打包成⼀个或多个⽂件。
- 配置复杂度
  - Vite：配置相对简单，默认提供了很多常⽤的配置，对于⼩型项⽬可以快速上⼿。例如，只需要配置⼊⼝⽂件和输出路径等基本信息。 
  - Webpack：配置相对复杂，需要根据项⽬的需求配置各种 loader 和 plugin，对于初学者来说有⼀定的学习成本。
- 适用场景
  - Vite：适⽤于⼩型项⽬和快速迭代的项⽬，能够提供快速的开发体验。例如，⼀些简单的静态⽹站、原型项⽬等。 
  - Webpack：适⽤于⼤型项⽬和复杂的项⽬，具有强⼤的功能和丰富的插件⽣态系统。例如，企业级的 Web 应⽤、⼤型电商⽹站等。

## 4. vite项目怎么部署到线上
- 将 Vite 项⽬部署到线上需要完成项⽬的构建、服务器配置和⽂件上传等步骤，确保项⽬在⽣产环境中能够正常运⾏。
- 部署步骤：
  - 项⽬构建：在本地项⽬根⽬录下运⾏ npm run build 命令，Vite 会根据配置⽂件将项⽬打包成⽣产环境可⽤的⽂件，通常会⽣成⼀个 dist ⽬录，包含打包后的 HTML、CSS、JavaScript 等⽂件。
  - 服务器选择：选择合适的服务器来部署项⽬，常⻅的服务器有 Nginx、Apache等。可以选择云服务器（如阿⾥云、腾讯云等）或⾃⼰搭建服务器。
```java
// 服务器配置， Nginx 配置示例：
server {
    listen 80;
    server_name yourdomain.com;
    root /path/to/your/dist;
    index index.html;
    location / {
        try_files $uri $uri/ /index.html;
    }
}
// 上述配置中，`listen` 指定监听的端⼝，`server_name` 指定域名，`root` 指定项⽬打包后的⽂件路径，`location` 配置⽤于处理路由，确保单⻚应⽤的路由正常⼯作。
// ⽂件上传：将本地 `dist` ⽬录下的所有⽂件上传到服务器的指定⽬录。可以使⽤FTP、SFTP 等⼯具进⾏⽂件上传。
// 域名配置：如果使⽤⾃定义域名，需要将域名解析到服务器的 IP 地址。在域名管理平台上添加相应的 DNS 记录。
```
- 案例应⽤：将⼀个使⽤ Vite 构建的 React 或 Vue 单⻚应⽤部署到线上，让⽤户可以通过域名访问该应⽤。


## 5. 进程之间如何进⾏通信？说⼀下应⽤场景？
- 进程间通信（IPC，Inter - Process Communication）是指在不同进程之间传播或交换信息的机制。常⻅的进程间通信⽅式有以下⼏种：
  - 管道（Pipe）：管道是⼀种半双⼯的通信⽅式，数据只能在⼀个⽅向上流动，通常⽤于⽗⼦进程之间的通信。管道本质上是⼀个内核缓冲区，写⼊管道的数据会被内核缓存，读取进程可以从管道中读取数据
  - 消息队列（Message Queue）：消息队列是⼀种消息的链表，存放在内核中并由消息队列标识符标识。消息队列允许⼀个或多个进程向它写⼊或读取消息，进程可以按照⼀定的规则从消息队列中获取消息，⽽不需要与其他进程保持同步。
  - 共享内存（Shared Memory）：共享内存是指多个进程可以访问同⼀块物理内存区域，这是最快的⼀种 IPC ⽅式。进程可以直接对共享内存进⾏读写操作，避免了数据的复制，但需要使⽤同步机制（如信号量）来避免竞态条件。
  - 信号量（Semaphore）：信号量是⼀种计数器，⽤于控制对共享资源的访问。它可以⽤来实现进程之间的同步和互斥，通过 P（等待）和 V（释放）操作来改变信号量的值。
  - 套接字（Socket）：套接字可以实现不同主机之间的进程通信，也可以⽤于同⼀主机上的进程通信。它提供了⼀种⽹络编程接⼝，通过⽹络协议进⾏数据传输。
- 应用场景：
  - 管道：常⽤于 shell 脚本中，例如将⼀个命令的输出作为另⼀个命令的输⼊，如 ls| grep test。
  - 消息队列：适⽤于需要异步通信的场景，如任务调度系统，⽣产者进程将任务消息放⼊消息队列，消费者进程从队列中取出任务进⾏处理。
  - 共享内存：在需要频繁交换⼤量数据的场景中⾮常有⽤，如图形处理、数据库管理系统等，多个进程可以同时访问共享内存中的数据。
  - 信号量：⽤于解决进程间的同步和互斥问题，如多个进程同时访问⼀个共享资源时，使⽤信号量来保证资源的互斥访问。
  - 套接字：⼴泛应⽤于⽹络编程，如 Web 服务器与客户端之间的通信、即时通讯软件等。
- 代码案例（Python 中使⽤管道进⾏进程间通信）
```python
import os
# 创建管道
r, w = os.pipe()
# 创建⼦进程
pid = os.fork()
if pid == 0:
    # ⼦进程关闭写端
    os.close(w)
    # 从管道读取数据
    r = os.fdopen(r)
    print(f"Child process received: {r.read()}")
    r.close()
else:
    # ⽗进程关闭读端
    os.close(r)
    w = os.fdopen(w, 'w')
    # 向管道写⼊数据
    w.write("Hello from parent process!")
    w.close()
    # 等待⼦进程结束
    os.wait()
```
- 解析：在上述代码中，⾸先使⽤ os.pipe() 创建了⼀个管道，返回两个⽂件描述符 r 和 w 分别⽤于读取和写⼊。然后使⽤ os.fork() 创建了⼀个⼦进程。⽗进程关闭读端，向管道写⼊数据；⼦进程关闭写端，从管道读取数据。通过这种⽅式实现了⽗⼦进程之间的通信。


## 6. 前端性能优化
- 前端性能优化的核⼼⽬标是提⾼⽹⻚的加载速度和响应速度，提升⽤户体验。主要从以下⼏个⽅⾯进⾏优化：
  - 压缩代码：对 HTML、CSS、JavaScript 代码进⾏压缩，去除不必要的空格、注释和换⾏符，减少⽂件⼤⼩，从⽽加快⽂件的下载速度。 
  - 合并⽂件：将多个 CSS ⽂件和 JavaScript ⽂件合并成⼀个⽂件，减少浏览器的请求次数，因为每次请求都有⼀定的开销。 
  - 图⽚优化：选择合适的图⽚格式（如 JPEG、PNG、WebP），对图⽚进⾏压缩，降低图⽚的分辨率和质量，同时可以采⽤图⽚懒加载技术，只在图⽚进⼊可视区域时才加载，减少初始加载的资源量。 
  - 缓存机制：利⽤浏览器的缓存机制，设置合理的缓存策略，如使⽤ Cache - Control 、 Expires 等 HTTP 头信息，让浏览器缓存静态资源，避免重复下载。 
  - CDN（内容分发⽹络）：使⽤ CDN 来分发静态资源，CDN 节点分布在全球各地， 可以将资源缓存到离⽤户最近的节点，减少数据传输的距离，提⾼资源的加载速 度。 
  - 优化 DOM 操作：减少 DOM 操作的次数，因为 DOM 操作会触发浏览器的重排和重绘，影响性能。可以使⽤⽂档⽚段（DocumentFragment）来批量操作 DOM，减少重排和重绘的次数。 
- 应⽤场景 
  - 电商⽹站：⽤户在浏览商品列表和详情⻚时，希望⻚⾯能够快速加载，因此需要进⾏前端性能优化，提⾼⽤户的购物体验。 
  - 新闻资讯⽹站：⼤量的图⽚和⽂章内容需要快速加载，以满⾜⽤户获取信息的需求，性能优化可以提⾼⽤户的留存率。 
  - 在线游戏：需要实时响应⽤户的操作，优化前端性能可以减少游戏的卡顿现象，提 ⾼游戏的流畅度。
- 代码案例（使⽤ Gulp 进⾏代码压缩和合并）
```javascript
const gulp = require('gulp');
const uglify = require('gulp-uglify');
const concat = require('gulp-concat');
const cssnano = require('gulp-cssnano');
// 压缩和合并 JavaScript ⽂件
gulp.task('scripts', function () {
    return gulp.src('src/js/*.js')
        .pipe(concat('all.js'))
        .pipe(uglify())
        .pipe(gulp.dest('dist/js'));
});
// 压缩和合并 CSS ⽂件
gulp.task('styles', function () {
    return gulp.src('src/css/*.css')
        .pipe(concat('all.css'))
        .pipe(cssnano())
        .pipe(gulp.dest('dist/css'));
});
// 默认任务
gulp.task('default', gulp.parallel('scripts', 'styles'));
```
- 解析：上述代码使⽤ Gulp 构建⼯具，通过 gulp-uglify 插件对 JavaScript ⽂件进⾏压缩， gulp-concat 插件将多个 JavaScript ⽂件合并成⼀个⽂件， gulp-cssnano 插件对 CSS ⽂件进⾏压缩和合并。最后定义了⼀个默认任务，同时执⾏ JavaScript 和 CSS 的处理任务。


## 7. JS和客户端交互方法
### 1. 原⽣WebView注⼊对象交互
- 在iOS和Android等客户端的WebView（⽤于在移动应⽤中显示⽹⻚内容的组件）中，可以向⽹⻚注⼊原⽣对象。这样在⽹⻚中的JavaScript代码就能直接调⽤这些原⽣对象的⽅法，实现与客户端的交互。
- Android端
```java
// java代码
webView.addJavascriptInterface(new JsInterface(), "AndroidObj");
public class JsInterface {
    @JavascriptInterface
    public void showToast(String message) {
        Toast.makeText(MainActivity.this, message,
        Toast.LENGTH_SHORT).show();
    }
}
```
```javascript
// 在JavaScript中调用
// 调⽤Android注⼊的对象⽅法
window.AndroidObj.showToast('Hello from JS');
```
- IOS端
```C
// Objective - C代码
WKUserContentController *userContentController =[[WKUserContentController alloc] init];
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.userContentController = userContentController;
WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];
[userContentController addScriptMessageHandler:self name:@"iOSObj"];
- (void)userContentController:(WKUserContentController*)userContentController didReceiveScriptMessage:(WKScriptMessage*)message {
    if ([message.name isEqualToString:@"iOSObj"]) {
        NSString *msg = message.body;
        NSLog(@"Received message from JS: %@", msg);
    }
}
```
```javascript
// 调⽤iOS注⼊的对象⽅法
window.webkit.messageHandlers.iOSObj.postMessage('Hello from JS');
```
### 2. 通过URL Scheme交互
- URL Scheme是⼀种类似于URL的链接格式，⽤于在应⽤间进⾏跳转和传递数据。JavaScript可以通过修改当前⻚⾯的URL为特定的URL Scheme，客户端的WebView捕获到这个URL Scheme后，进⾏相应的处理。
```javascript
// 在JavaScript中触发URL Scheme：
function callNativeFunction() {
    window.location.href = 'myapp://action?param1=value1&param2=value2';
}
```
- 客户端捕获URL Scheme并处理：
- Android端：在WebViewClient的 shouldOverrideUrlLoading ⽅法中拦截URL Scheme进⾏处理。
```java
webView.setWebViewClient(new WebViewClient() {
@Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        if (url.startsWith("myapp://")) {
        // 解析URL参数并处理
            return true;
        }
    return super.shouldOverrideUrlLoading(view, url);
    }
});
```
- iOS端：在WKUIDelegate的 webView:decidePolicyForNavigationAction:decisionHandler: ⽅法中拦截URL Scheme进⾏处理。
```C
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:
(WKNavigationAction *)navigationAction decisionHandler:(void (^)
(WKNavigationActionPolicy))decisionHandler {
    NSURL *url = navigationAction.request.URL;
    if ([url.scheme isEqualToString:@"myapp"]) {
        // 解析URL参数并处理
        decisionHandler(WKNavigationActionPolicyCancel);
        return;
    }
decisionHandler(WKNavigationActionPolicyAllow);
}
```
### 3. 消息传递机制（如postMessage）
- HTML5提供了 window.postMessage ⽅法，可⽤于在不同窗⼝或框架之间传递消息。在客户端WebView和⽹⻚之间也能借助这个机制进⾏通信。客户端可以监听⽹⻚发送的消息，⽹⻚也能监听客户端发送的消息。
```javascript
// 网页向客户端发送消息
window.postMessage({type: 'share', data: 'Some share data'},'*');
// 客户端监听消息（以Android为例）：
webView.evaluateJavascript("window.addEventListener('message',function(event) { console.log('Received message from client: ' +JSON.stringify(event.data)); });", null);
```












