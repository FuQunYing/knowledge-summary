# ⼀、HTML部分
## 1. script标签为什么放在body下⾯？
- 避免阻塞渲染：”script 默认会阻塞 HTML 解析，放在顶部会导致页面白屏时间变长。
- 提高页面加载速度：让 HTML 结构优先渲染出来，提升用户体验。
- 保证 DOM 已加载：某些脚本依赖页面元素，放在 body 底部能避免 document.getElementById找不到元素的问题。
- 总结： script 放底部是为了 性能优化 + 避免阻塞 + DOM 可用性。
## 2. HTML5语义化标签
- 常见的语义化标签：
> \<header>：头部区域
> \<nav>：导航部分
> \<section>：页面章节内容
> \<article>：独立的文章内容
> \<aside>：侧边栏
> \<footer>：尾部内容
> \<main>：页面主要内容
> \<figure> / \<figcaption>：带标注的媒体内容
> \<mark>：标记高亮
> \<time>：时间

- 好处：
> 结构更清晰，便于维护
> 有利于 SEO（搜索引擎更易理解结构）
> 有利于无障碍阅读（屏幕阅读器可识别语义）

## 3. ⾃定义属性 data-*
- data-* 是 HTML5 提供的用于存储自定义数据的方式，如：
```html
<div data-id="123" data-role="admin"></div>
```
- 特点
> 1. 可通过 JS 获取：element.dataset.id
> 2. 不会污染标准属性
> 3. 常用于组件初始化、业务标记

- 应用场景
> 存储业务数据
> 存储 UI 组件配置
> 在 HTML 与 JS 之间传递信息

## 4. 块级元素、⾏内元素
- 块级元素（block）
> 特点：独占一行，可以设置宽高、margin、padding，宽度默认 100%
> 常见：div, p, ul, li, h1~h6, section, article, header, footer

- 行内元素（inline）
> 特点：不独占一行，不能设置宽高（默认内容撑开），padding、margin 只有左右生效
> 常见：span, a, img（特殊，可替换）, strong, em

- 行内块元素 inline-block
> 可设置宽高，但不独占一行。

## 5. BFC
- BFC 是浏览器布局的一种渲染区域，有一套自己的布局规则。
- 如何触发 BFC？
> overflow: hidden | auto | scroll
> float: left/right
> display: inline-block
> position: absolute/fixed
> display: flow-root

- BFC 能解决什么？
> 清除浮动：父元素形成 BFC 就能包住子元素浮动高度。
> 避免 margin 重叠（外边距折叠）
> 避免浮动元素遮挡内容
> 自适应多列布局
> 一句话总结：BFC = 独立布局环境，用来解决浮动、margin 重叠等问题。

## 6. 可替换元素
- 浏览器根据其标签属性或外部资源来决定具体内容和尺寸。
- 常见可替换元素：
> img，input，textarea，button，select，iframe，video，embed

- 特点
> 1. 宽高可以设置
> 2. 内容由浏览器替换渲染
> 3. 默认行为一般不可用 CSS 完全控制

## 7. 脚本异步加载，三种常见方式（script标签中的defer和async）：
### 1. async
```html
<script src="a.js" async></script>
```
> 下载与解析 HTML 并行
> 下载完立即执行（可能会阻塞）
> 多个 script 执行顺序不保证

### 2. defer
```html
<script src="a.js" defer></script>
```
> 下载与解析 HTML 并行
> 等 DOM 全部解析完后按顺序执行
> 一般用于依赖 DOM 的代码
> 案例应⽤：若脚本有依赖关系且需在⽂档解析完后执⾏，⽤ defer ；若脚本⽆依赖且不影响⻚⾯渲染，⽤ async 。例如在加载第三⽅统计脚本时可⽤ async ，加载依赖于⽂档结构的脚本时⽤ defer 。

### 3. 动态创建 script
```JavaScript
const s = document.createElement('script');
s.src = 'xxx.js';
document.body.appendChild(s);
```
> 默认异步加载，等价于 async

## 8. a 标签 noopener 是什么？
```html
<!--当你使用-->
<a href="xxx" target="_blank" rel="noopener">
```
- 作用
> 防止新窗口通过 window.opener 控制原页面（安全）
> 防止恶意页面修改原窗口 Location（钓鱼攻击）
> 提升性能： 新页面不会与当前页面共享进程（Chrome），提升隔离性。
> 延伸：rel="noopener noreferrer" 中 noreferrer 还会隐藏 referer。
> 
## 9. 解析 html 标签时哪些是异步的？哪些是同步的？
> 原理：HTML 解析时， \<script> 标签默认同步加载执⾏，会阻塞⽂档解析。加defer 或 async 属性的 \<script> 异步。 \<link rel="stylesheet"> 同步加载，不阻塞⽂档解析，但阻塞 DOMContentLoaded 事件。 \<img> 异步加载，不影响⽂档解析。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <!-- 同步加载样式 -->
        <link rel="stylesheet" href="styles.css">
        <!-- 默认同步脚本 -->
        <script src="sync.js"></script>
        <!-- 异步脚本 -->
        <script async src="async.js"></script>
    </head>
    <body>
        <!-- 异步加载图⽚ -->
        <img src="example.jpg" alt="Example">
    </body>
</html>
<!--案例应⽤：合理安排标签的同步异步加载，可优化⻚⾯性能。如将不影响⻚⾯渲染的脚本设为异步，避免阻塞⽂档解析；将样式⽂件放在头部同步加载，确保⻚⾯样式正常显示。-->
```

# 二、CSS部分
## 1. 盒子模型（Box Model）
- CSS 有 标准盒模型 和 IE 盒模型。
- 标准盒模型（content-box）
> 盒子总宽度 = width + padding + border + margin

- IE 盒模型（border-box）,width 包含了 padding 和 border：
> 盒子总宽度 = width + margin
> border-box 优点：布局更好算、不容易超出容器。

```css
box-sizing: content-box;   /* 默认 */
box-sizing: border-box;    /* 更常用 */
```
## 2. GPU 渲染（硬件加速）
- 浏览器渲染一般分为：
> CPU：负责布局、绘制
> GPU：负责合成、加速动画

- 哪些 CSS 会触发 GPU 加速？
> transform（translate、scale），opacity，filter，will-change，translateZ(0)、translate3d(0,0,0)

- 优点
> 更流畅的动画（不会反复重排/重绘）
> 避免页面抖动（减少 layout）

- 缺点
> 占用 GPU 内存（图层过多会卡）
> 滥用可能导致耗电、掉帧

- 一句话：使用 transform + opacity 做动画，会进入 GPU 合成层，性能最好。
## 3. flex布局、grid布局
### 3.1 Flex（弹性布局）
- 一维布局：主轴 + 交叉轴
- 常用属性：
> 容器：display:flex
> 主轴方向：flex-direction
> 子项自动分配空间：flex: 1
> 主轴对齐：justify-content
> 交叉轴对齐：align-items
> 换行：flex-wrap

- 适用场景：
> 水平垂直居中
> 响应式导航栏
> 不定宽高布局

### 3.2 Grid（网格布局）
- 二维布局：可以同时控制行 + 列
- 常用属性：
> 行列大小：grid-template-rows / grid-template-columns
> 格子间距：gap
> 子项定位：grid-row / grid-column
> 自动填充：repeat(auto-fill, minmax())

- 适用场景：
> 桌面级布局
> 瀑布流
> 仿 Excel 栅格

- 总结区别
| 布局方式 | Flex | Grid |
| - | - | - |
| 维度 | 一维 | 二维 |
| 场景 | 内容自适应 | 更像先规划版面 |
| 控制 | 子项之间关系 | 行列网格精确布局 |

## 4. 百分比（%）的计算规则
- 关键点：百分比的参考对象，取决于属性本身。
| 属性                                         | 百分比相对于                   |
| ------------------------------------------ | ------------------------ |
| width                                      | 父元素 width                |
| height                                     | **不一定能生效**，取决于父元素是否有明确高度 |
| padding                                    | 父元素 **width**            |
| margin                                     | 父元素 width                |
| transform                                  | 自身大小                     |
| position: absolute 的 left/right/top/bottom | 包含块（一般为最近的定位父元素）         |
- 最容易考的点：padding 百分比是相对父元素的宽度，而不是高度，例如保持正方形常用：
```css
.box {
  width: 50%;
  padding-top: 50%; /* 相对父元素宽度 */
}
```

## 5. 如何实现随窗⼝⼤⼩变化的正⽅形？
- 使用 padding-top
```css
.square {
  width: 30%;
  padding-top: 30%;
  background: #1677ff;
}
```
- 使用 aspect-ratio，最常用，最现代
```css
.square {
  width: 200px;
  aspect-ratio: 1 / 1;
  background: #1677ff;
}
```
- 使用 vw（相对视口）
```css
.square {
  width: 20vw;
  height: 20vw;
}
```
- JS 动态设置（不推荐）
> 监听 window 大小然后设置 height=width。

- 总结最优解：
> aspect-ratio: 1; 是最简洁最现代的写法。

## 6. 了解重排和重绘吗？
- 原理：重排（回流）是指当 DOM 的变化影响了元素的布局信息（元素的宽⾼、边距、位置等），浏览器需要重新计算元素在视⼝内的位置和⼤⼩。
- 重绘是指当⼀个元素的外观发⽣改变，但没有影响到布局信息时，浏览器将新样式绘制到屏幕上。 
- 重排的代价⽐重绘⼤，因为重排可能会触发后续⼀系列元素的重排和重绘。
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #box {
                width: 100px;
                height: 100px;
                background-color: red;
            }
        </style>
    </head>
<body>
    <div id="box"></div>
    <button onclick="changeWidth()">Change Width</button>
    <button onclick="changeColor()">Change Color</button>
    <script>
    function changeWidth() {
        const box = document.getElementById('box');
        box.style.width = '200px'; // 触发重排和重绘
    }
    function changeColor() {
        document.getElementById('box');
        const box = box.style.backgroundColor = 'blue'; // 触发重绘
    }
    </script>
</body>
</html>
<!--案例应⽤：在开发中，应尽量减少重排和重绘的次数。⽐如批量修改 DOM 样式时，可先将元素从⽂档流中移除，修改完后再添加回去；避免频繁读取会触发重排的属性，如 offsetWidth 、 scrollTop 等。-->
```
## 7. CSS 和 JS 动画会导致重排吗？
- 原理：CSS 动画和 JS 动画是否导致重排取决于动画改变的属性。如果改变的是影响布局信息的属性（如宽度、⾼度、边距等），则会触发重排；如果改变的是只影响外观的属性（如颜⾊、透明度等），则只会触发重绘。⼀般来说，CSS 的 transform 和 opacity 属性在动画中不会触发重排，性能较好。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    #box {
    width: 100px;
    height: 100px;
    background-color: red;
    transition: all 1s;
    transform: translateX(100px); /* 不会触发重排 */
    width: 200px; /* 会触发重排 */
    }
    .move {
    }
    .resize {
    }
    </style>
</head>
<body>
    <div id="box"></div>
    <button onclick="moveBox()">Move Box</button>
    <button onclick="resizeBox()">Resize Box</button>
    <script>
        function moveBox() {
            const box = document.getElementById('box');
            box.classList.add('move');
        }
        function resizeBox() {
            const box = document.getElementById('box');
            box.classList.add('resize');
        }
    </script>
</body>
</html>
<!--案例应⽤：在实现动画效果时，优先使⽤ transform 和 opacity 属性来创建动画，以提⾼性能。例如制作元素的移动、旋转、缩放等动画时，使⽤transform属性；制作淡⼊淡出效果时，使⽤ opacity 属性。-->
```

# 三、JS部分
## 1. 事件——冒泡、捕获、委托、⾃定义事件
### 1.1 事件流：捕获 → 目标 → 冒泡
- 事件流分三阶段：
> 捕获阶段（从 window → 根节点 → 目标父层级）
> 目标阶段
> 冒泡阶段（从目标 → 向上冒到 window）

```JavaScript
// 绑定事件时：
element.addEventListener('click', handler, true);  // 捕获
element.addEventListener('click', handler, false); // 冒泡（默认）
```
### 1.2 事件委托（Event Delegation）
- 利用事件冒泡，将子元素事件统一绑定到父元素上。
- 优点：
> 减少事件绑定数量，提高性能
> 动态元素也能响应事件
> 便于管理事件

```JavaScript
// 例子：
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log(e.target.innerText);
  }
});
```
### 1.3 自定义事件（CustomEvent）
```JavaScript
// 创建一个事件：
const event = new CustomEvent('myEvent', { detail: { id: 1 } });
element.dispatchEvent(event);
// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.id);
});
```
- 用途：组件通信，状态通知，解耦代码

## 2. DOM API
- 常用 DOM 操作：
```JavaScript
// 查找元素：
document.getElementById()
document.querySelector()
document.querySelectorAll()
document.getElementsByClassName()
document.getElementsByTagName()
// 创建与插入
document.createElement()
parent.appendChild()
parent.insertBefore()
parent.append()
element.innerHTML
// 删除
element.remove()
parent.removeChild()
// 属性
element.getAttribute()
element.setAttribute()
element.dataset
// 样式
element.style
window.getComputedStyle()
// 节点关系
element.parentNode
element.children
element.nextElementSibling
// 尺寸与位置
element.getBoundingClientRect()
element.offsetWidth / offsetHeight
element.scrollTop
```

## 3. this、原型链
### 3.1 this的绑定规则，this 由 调用方式 决定：

| 情况              | this 指向                  |
| --------------- | ------------------------ |
| 作为对象方法调用        | 该对象                      |
| 普通函数调用          | window / undefined（严格模式） |
| 构造函数            | 实例对象                     |
| bind/call/apply | 显式绑定的值                   |
| 箭头函数            | 外层作用域的 this（无法被修改）       |

- 一句话总结：箭头函数的 this = 定义时的外层作用域，不会变。

### 3.2 原型与原型链
> 每个对象都有一个隐藏属性：__proto__
> 每个函数都有一个属性：prototype

```JavaScript
// 关系图（最常问）
obj → __proto__ → Object.prototype → null
fn  → __proto__ → Function.prototype → Object.prototype
```

- 原型链查找规则，访问属性时：
> 先查对象自身
> 找不到往原型链上查
> 一直到 Object.prototype
> 再到 null 停止

## 4. 数据类型转换
- JS 有 显示转换 和 隐式转换。
```JavaScript
// 显示转换
String(123)  → "123"
Number("123") → 123
Boolean(0) → false
parseInt("12px") → 12
parseFloat("3.14") → 3.14
```
- 隐式转换：主要发生在 +, ==, 比较运算、if 判断中
```JavaScript
// + 运算符，若其中一项为字符串 → 转成字符串拼接，否则 → 转成数字
1 + '2' = '12'
'2' - 1 = 1

// ==（宽松等于）规则，最重要规则：
null == undefined   // true
但 null != 0
// 对象与原始类型比较时：对象先转成原始类型（valueOf → toString）,例如：
[1] == 1  // true
[] == 0   // true
[] == ''  // true
```
-  Boolean 真假值判断
```JavaScript
// 假值（6个）：
false
0
''//（空字符串）
null
undefined
NaN
// 其余都是真值，包括：[]、{}、"0"、"false"
```

## 5. 为什么通过getElementsByClassName获取的元素集合⽆法直接forEach
- 原因：getElementsByClassName 返回的是 HTMLCollection，不是数组。
- HTMLCollection 的特点：
> 是类数组，但 不是数组
> 没有 forEach 方法
> 是动态集合（会自动更新）

- 证明： typeof document.getElementsByClassName('xx')  // object
- 解决方式
```JavaScript
// 转成数组
Array.from(collection).forEach(...)
// 使用扩展运算符
[...collection].forEach(...)
// 直接使用for
for (let i = 0; i < collection.length; i++) { ... }
```
- 改用 querySelectorAll：因为它返回的是 NodeList，天然就有 forEach。

## 6. event loop
- 原理：Event Loop（事件循环）是 JavaScript 的执⾏机制，⽤于处理异步操作。JavaScript 是单线程的，为了处理异步任务（如定时器、⽹络请求等），引⼊了事件循环机制。它的核⼼包括调⽤栈（Call Stack）、任务队列（Task Queue，分为宏任务队列和微任务队列）。当调⽤栈中的同步任务执⾏完后，事件循环会不断从任务队列中取出任务放⼊调⽤栈执⾏。
```javascript
console.log('Start');
setTimeout(() => {console.log('Timeout')}, 0);
Promise.resolve().then(() => { console.log('Promise');});
console.log('End');
```
- 代码细节：⾸先， console.log('Start') 是同步任务，直接在调⽤栈执⾏并输出。 setTimeout 是宏任务，会在 0 毫秒后将回调函数放⼊宏任务队列。 Promise.resolve().then() 是微任务，会将回调函数放⼊微任务队列。 console.log('End') 也是同步任务，接着执⾏。当调⽤栈为空时，事件循环会先处理微任务队列中的任务，所以输出 Promise ，然后处理宏任务队列中的任务，输出 Timeout 。
- 案例应⽤：在处理异步操作时，如⽹络请求、定时器等，事件循环机制确保了代码的执⾏顺序和异步任务的处理。例如在前端开发中，使⽤ fetch 进⾏⽹络请求，请求完成后的回调函数会通过事件循环机制在合适的时机执⾏。

## 7. 事件循环代码输出
```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
    async function async2() {
        console.log('async2');
    }
}
console.log('setTimeout');
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve) => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});
console.log('script end');
```
- 原理：同样基于事件循环机制，分析代码中同步任务、微任务和宏任务的执⾏顺序。 async/await 本质上是基于 Promise 的语法糖， await 会暂停当前函数的执⾏，等待后⾯的 Promise 完成。
- 代码细节：
  - i. ⾸先执⾏同步任务，输出 script start。 
  - ii. setTimeout 是宏任务，将回调函数放⼊宏任务队列。 
  - iii. 调⽤ async1 函数，输出 async1 start ，接着调⽤ async2 函数，输出async2。 await async2() 暂停 async1 函数的执⾏。 
  - iv. 执⾏ new Promise ，输出 promise1， resolve() 后将 then 回调放⼊微任务队列。 
  - v. 输出 script end ，此时调⽤栈为空。 
  - vi. 处理微任务队列，先执⾏ async1 函数中 await 后⾯的代码，输出 async1 end ，再执⾏ Promise 的 then 回调，输出 promise2。 
  - vii. 处理宏任务队列，输出 setTimeout 。
- 案例应⽤：理解事件循环代码输出顺序有助于调试和优化涉及异步操作的代码，避免出现意外的执⾏顺序问题。

## 8. 平时是怎么发异步请求的
- 原理：在前端开发中，常⻅的发送异步请求的⽅式有 XMLHttpRequest、 fetchAPI 和第三⽅库如 axios 。这些⽅式都是基于浏览器的⽹络请求能⼒，通过异步操作获取服务器数据，避免阻塞主线程。
- 代码案例（使⽤ fetch ）：
```javascript
fetch('https://api.example.com/data').then(response => {
if (!response.ok) {
    throw new Error('Network response was not ok');
}
    return response.json();
}).then(data => {console.log('Data:', data);})
.catch(error => {console.error('Error:', error)})
```
- 代码细节： fetch 函数返回⼀个 Promise ，它接收⼀个 URL 作为参数。第⼀个 then ⽅法处理响应对象，检查响应状态是否正常，若正常则将响应数据解析为JSON。第⼆个 then ⽅法处理解析后的数据。 catch ⽅法捕获请求过程中出现的错误。
- 案例应⽤：在开发中，当需要从服务器获取数据时，如获取⽤户信息、商品列表等，可使⽤上述⽅法发送异步请求。

## 9. 事件循环你是怎么⽤的
- 原理：事件循环主要⽤于处理异步任务，合理利⽤事件循环机制可以优化代码性能和实现复杂的异步逻辑。例如，将⼀些耗时的操作放在异步任务中，避免阻塞主线程。
```javascript
function longRunningTask() {
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += i;
}}
return sum;
// 使⽤ setTimeout 将耗时任务放⼊宏任务队列
setTimeout(() => {
    const result = longRunningTask();
    console.log('Task result:', result);
}, 0);
console.log('Main thread continues...');
```
- 代码细节： longRunningTask 是⼀个耗时的计算任务。使⽤ setTimeout 将其放⼊宏任务队列，主线程可以继续执⾏后续代码，输出 Main thread continues... 。当调⽤栈为空时，事件循环会从宏任务队列中取出longRunningTask 并执⾏。
- 案例应⽤：在前端开发中，对于⼀些复杂的计算、⼤数据处理等耗时操作，可利⽤事件循环将其异步化，避免⻚⾯卡顿。
# 四、HTTP部分
1. 常⻅状态码
- 2xx（成功）
> 200 OK：请求成功
> 201 Created：资源已创建（一般用于 POST）
> 3xx（重定向）

- 301 Moved Permanently：永久重定向
> 302 Found：临时重定向
> 304 Not Modified：使用缓存（协商缓存命中）

- 4xx（客户端错误）
> 400 Bad Request：请求参数问题
> 401 Unauthorized：未认证
> 403 Forbidden：已认证但权限不足
> 404 Not Found：资源不存在
> 429 Too Many Requests：请求太频繁（限流）

- 5xx（服务端错误）
> 500 Internal Server Error
> 502 Bad Gateway
> 503 Service Unavailable：服务不可用
> 504 Gateway Timeout

2. 301、302、304
- 301 永久重定向
> 告诉浏览器资源永久移动到新地址
> 浏览器会缓存重定向结果
> SEO 中会将权重转移到新地址

- 302 临时重定向
> 暂时跳到新地址
> 浏览器不会缓存
> 常用于登录跳转、临时调整

- 304 Not Modified
> 协商缓存生效
> 服务器告诉浏览器：你缓存的资源没变
> 浏览器直接读取本地缓存
> 触发条件：If-Modified-Since / If-None-Match

| 状态码 | 场景     | 是否重新下载资源   |
| --- | ------ | ---------- |
| 301 | 永久重定向  | 会          |
| 302 | 临时重定向  | 会          |
| 304 | 协商缓存命中 | **不会**下载资源 |

3. 常⻅的请求method
| Method  | 作用         | 是否安全 | 是否幂等 |
| ------- | ---------- | ---- | ---- |
| GET     | 获取数据       | ✔    | ✔    |
| POST    | 创建/提交数据    | ✘    | ✘    |
| PUT     | 更新资源（整体更新） | ✘    | ✔    |
| PATCH   | 局部更新       | ✘    | ✘    |
| DELETE  | 删除资源       | ✘    | ✔    |
| HEAD    | 获取响应头      | ✔    | ✔    |
| OPTIONS | 预检请求       | ✔    | ✔    |

4. 跨域问题：浏览器的 同源策略 导致：协议、域名、端口不同即跨域。
**解决跨域的方式**
- 1. 服务端 CORS（最常用）
```java
// 服务器设置：
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Access-Control-Allow-Methods: *
```
- 2. Nginx 反向代理：前端访问同域的 nginx，由 nginx 代理转发。
- 3. JSONP（只支持 GET）
- 4. WebSocket（不受同源策略限制）
- 5. 跨域资源共享 iframe 通信（postMessage）

5. session和cookie是如何⼯作的？
- Cookie
> 存储在浏览器
> 会自动随请求携带到同域服务器
> 一般用于：登录状态 token、偏好设置

- Session
> 存储在服务器
> 浏览器通过 cookie 中的 sessionId 来标识用户

- 工作流程：
> 用户第一次访问服务器
> 服务器创建 session，在 server 保存（如内存/Redis）
> 服务端返回 Set-Cookie: sessionId=xxxx
> 浏览器保存 cookie
> 下次请求自动带上 sessionId
> 服务器通过 sessionId 找到当前用户的数据

- 本质：
> Cookie 存 sessionId，Session 存用户数据
> 两者配合实现登录状态。

6. CDN
- 作用：
> 加速访问（就近节点返回资源）
> 减少源站压力
> 防止 DDoS
> 资源缓存提升加载速度

**补充DDos**
> **1. 什么是 DDoS？**
> > DDoS（Distributed Denial of Service）分布式拒绝服务攻击
> > 攻击者控制大量肉鸡设备（服务器、主机、IoT 设备等），向目标服务器同时发起大量无意义的请求，占满带宽、耗尽计算资源，使其：
> > 无法处理正常请求
> > CPU/带宽被打满
> > 服务瘫痪、宕机
> 一句话：
> > 用海量流量淹没目标，让它无法提供服务。
> **2. 常见 DDoS 攻击类型**
> ① 流量型攻击（最常见）
> > 用巨量带宽攻击目标，典型如：
> > UDP Flood
> > ICMP Flood（Ping Flood）
> > DNS Amplification（放大攻击）
> 目标：耗尽网络带宽
> ② 协议型攻击
> 利用协议缺陷，占用服务器资源：
> > SYN Flood（半连接攻击）
> > ACK Flood
> > TCP Slowloris
> 目标：耗尽服务器连接数、CPU
> ③ 应用层攻击
> 模拟真实请求，但大量消耗后端业务资源：
> > HTTP Flood（模拟真实浏览器访问）
> > CC 攻击
> 目标：耗尽应用服务器处理能力
> **3. DDoS 攻击的特点**
> 流量巨大（几十 G、几百 G、甚至 Tb 级别）
> 来源广泛（僵尸网络）
> 难以直接阻断
> 攻击成本低、防护成本高
> **4. 如何防御 DDoS？（面试高频）**
> ① CDN / 高防节点 / 云清洗
> > CDN 节点分担流量
> > 高防 IP 提供流量清洗
> > 将恶意流量在边缘拦截
> ② 限流、熔断、验证码
> > 限制同一 IP 请求次数
> > 出现异常访问就触发熔断
> > 验证码阻挡自动化请求
> ③ 防火墙 / WAF
> > 根据规则过滤恶意协议包
> > 阻挡常见攻击（SYN、UDP flood）
> ④ 隔离节点 / 分布式部署
> > 多区域部署，分散攻击压力
> ⑤ 黑洞路由（最后手段）
> > 直接丢弃所有到该 IP 的流量（服务暂时不可用）。
> 一句话总结（面试官爱听版）
> > DDoS 是利用大量设备并发向目标发起无意义请求，耗尽带宽和资源，使服务不可用。
> > 防御主要依赖 CDN + 高防清洗 + 限流 + WAF。

- 原理：
> 用户访问资源 → DNS 将域名解析到 最近的 CDN 节点
> 如果节点有缓存 → 直接返回
> 如果没有 → 回源服务器获取并缓存

- 一句话总结：CDN = 离用户最近的服务器负责返回静态资源。

7. 强缓存与协商缓存
- 强缓存（不会发送请求）
```java
// 响应头中包含：
Cache-Control: max-age=3600
Expires: xxx
```
> 效果
> - 在有效期内，浏览器直接读本地缓存
> - 状态码：200（from cache）

- 协商缓存（会发送请求）
```java
// 请求头：
If-Modified-Since
If-None-Match
// 响应头
Last-Modified
ETag
```
- 流程：
> 浏览器带上条件请求
> 服务端判断资源是否更新
> 如果未更新 → 返回 304

- 区别总结
| 类型   | 是否发请求 | 典型状态码           |
| ---- | ----- | --------------- |
| 强缓存  | ❌ 不发  | 200（from cache） |
| 协商缓存 | ✔ 发   | 304             |

8. fetch和XMLHttpRequest的区别
- 1. API 设计现代
```javascript
// fetch 是 Promise 设计，更简洁：
fetch('/api').then()
// XHR
const xhr = new XMLHttpRequest();
xhr.open();
xhr.send();
```
- 2. 默认不带cookie
```javascript
// fetch
fetch(url, { credentials: 'include' })
// XHR同源时，默认带cookie
```
- 3. 不支持同步请求：XHR 支持同步（已被废弃），fetch 不支持同步。
- 4. 错误处理不同
```javascript
// fetch 只会对网络错误 reject，
// HTTP 错误不会抛错，需要自己判断：
if (!res.ok) { ... }
```
- 5. 支持流（stream）读取:fetch 可以分块读取大文件（如视频）。
- 总结一句话：
| 功能     | fetch       | XHR     |
| ------ | ----------- | ------- |
| 风格     | Promise，更现代 | 回调地狱    |
| Cookie | 默认不带        | 默认带     |
| 同步     | ❌           | ✔（但不推荐） |
| 流式处理   | ✔           | ✘       |
| 兼容性    | 中等          | 极好      |

# 五、Web安全
1. SQL注⼊（SQL Injection）
**是什么？**
> 攻击者通过向输入字段（URL、表单、Header）提交 恶意 SQL 语句，导致服务器拼接 SQL 时被篡改，最终可能：
> > 数据泄露
> > 数据篡改
> > 数据删除
> > 获取 root 权限

- 例子（典型注入）：
```sql
SELECT * FROM users WHERE username = '${input}'
```
- 攻击输入：
```vbnet
' OR 1=1 --
```
- 执行结果变成
```sql
SELECT * FROM users WHERE username = '' OR 1=1 --'
```
**如何防御？**
- 使用 预编译（Prepared Statement）（最有效）
```sql
SELECT * FROM users WHERE username = ?
```
- 严格参数化查询
> 框架 ORM（Sequelize、Hibernate）默认支持。

- 过滤/转义特殊字符
> 如 ', ", --, ;

- 最小权限原则
> 数据库用户只给必须的权限。

- WAF（Web Application Firewall）
> 自动拦截恶意 SQL 语句。

2. XSS攻击
**是什么？**
> 攻击者将恶意脚本注入页面，让浏览器执行，可能：
> > 盗取 cookie
> > 获取用户信息
> > 冒充用户操作
> > 页面篡改

**XSS 类型**
- ① 反射型 XSS（最常见）
> 恶意脚本通过URL注入

- 存储型 XSS（最危险）
> 恶意代码存到 DB，每次访问都会执行。

- ③ DOM 型 XSS
> 攻击点发生在前端 JS 内部。

**如何防御**
- 对输出内容做 HTML 转义（最关键）
```php
< → &lt;  
> → &gt;  
" → &quot;  
' → &#39;
```
- 架一般自带转义：React、Vue 默认是安全的。
-  CSP（Content-Security-Policy）,制脚本来源：
```php
Content-Security-Policy: default-src 'self'
```
- 禁止直接拼接 HTML,使用 innerHTML，改用：textContent
- 对用户输入进行过滤、校验
- HttpOnly Cookie（防止被读取）

3. 请求伪造（CSRF / XSRF）
**是什么**
> 击者诱导用户点击恶意链接，使浏览器在用户不知情的情况下发出请求（带 Cookie），从而完成敏感操作。
> 比如：转账、修改密码。
> 核心点：
> > CSRF 利用了浏览器会自动携带 Cookie 的机制。

**如何防御**
- ① Token（CSRF Token）—— 最有效
> 服务端生成 token，页面提交时必须携带。
> 攻击者无法获取 token。

- ② SameSite Cookie 设置
> 阻止跨站请求自动带上 cookie：

```javascript
Set-Cookie: sessionId=xxx; SameSite=Lax
```
> 选项：
> > Lax：大部分场景安全
> > Strict：最安全（完全不允许跨站）
> > None + Secure：允许跨站（要 HTTPS）

- ③ Referer / Origin 验证:服务器检查请求来源是否合法。
- 用户操作增加验证码 / 二次确认

4. jwt（JSON Web Token）
**是什么**
> 一种前后端分离中常用的 无状态身份认证方式。
> JWT 由三部分组成（用点分隔）：
> ```css
> header.payload.signature
> ```

- ① Header（头部）声明算法：
```json
{ "alg": "HS256", "typ": "JWT" }
```
- ② Payload（负载）:存用户信息、过期时间：
```json
{ "userId": 1, "exp": 1700000000 }
```
- ③ Signature（签名）使用密钥生成，防篡改：
```scss
HMACSHA256(header + payload, secret)
```
**JWT工作流程**
- 用户登录成功，服务器生成 JWT 返回给前端
- 前端保存 JWT（localStorage / cookie）
- 后续请求在 Header 中携带：Authorization: Bearer \<token>
- 服务器验证签名 → 解析用户信息
- 不需要 Session，不维护服务端状态（无状态）
**JWT的优点**
- 无状态，后端不需要存储 session（适合分布式）
- 前后端分离非常方便
- 可以跨服务验证（微服务常用）
**JWT的缺点**
- 不能主动失效（除非维护黑名单）
- token 一旦泄露，风险极高
- 不适合存放敏感信息（payload 只是 Base64，不加密）
- 较大（比 sessionId 更占带宽）
**JWT 的安全性注意事项**
- ✔ 设置 短过期时间
- ✔ 搭配 Refresh Token
- ✔ 使用 HTTPS
- ✔ 不要把 JWT 放在 localStorage（容易被 XSS 偷走）
- ✔ 可以放在 HttpOnly Cookie 中提高安全性

5. 浏览器从输⼊⽹址到⻚⾯呈现发⽣了什么？
- 1. 用户输入 URL / 按回车：浏览器拿到一个字符串（例如 https://example.com/path），开始解析成各部分（协议、主机、端口、路径、查询、fragment）。
- 2. 存 / 预连接：浏览器会先查本地缓存（DNS 缓存、HTTP 缓存、HSTS、Service Worker、connection pool）。如果资源可用且命中强缓存，可能直接从本地返回并跳过网络请求。
- 3. DNS 解析（把域名解析为 IP）
> 浏览器先查本地 DNS 缓存 → OS 缓存 → hosts 文件 → 发起 DNS 请求到 DNS 服务器。
> 这一步可能被 CDN 或 DNS 负载均衡影响（返回最近节点 IP）。
> （优化点：DNS 缓存、DNS over HTTPS、prefetch）

- 4. 建立 TCP 连接（如果没有现成连接）
> 三次握手：SYN → SYN-ACK → ACK。
> HTTP/1.1 + keep-alive 会复用连接；HTTP/2 在一个连接上多路复用多个请求。

- 5. TLS 握手（如果是 HTTPS）
> 客户端/服务器协商加密算法、交换证书、验证证书、生成对称密钥（包括可能的会话复用 / 0-RTT 优化）。
> TLS 完成后数据加密传输。
> （优化点：TLS session resumption、OCSP stapling、HTTP/2、QUIC/HTTP3）

- 6. 发起 HTTP 请求：浏览器发送 HTTP 请求（包含 headers：Host、User-Agent、Accept、Cookie、If-Modified-Since/If-None-Match 等）。如果有 Service Worker，Service Worker 可以拦截请求并返回响应（缓存或自定义响应）。
- 7. 服务器处理并返回响应：服务器接收请求，处理（路由、后端逻辑、读取 DB、调用微服务等），返回响应头和响应体（HTML、或 301/302 重定向等）。（CDN、高防或缓存层可在此处命中并直接返回缓存内容）
- 8. 浏览器开始接收字节 —— HTML 开始解析（关键渲染路径开始）
> 当浏览器接收到 HTML 字节流时，会 边下载边解析（streaming parsing）：
> a. HTML 解析器：生成 Token → 构建 DOM 树（DOM）
> 浏览器把 HTML token 化，生成 DOM 节点并链接成 DOM 树。
> b. CSS 解析：下载 CSS（遇到 <link>）并构建 CSSOM（CSS Object Model）
> 遇到外部 CSS，会触发额外的请求（可并行下载）。CSSOM 与 DOM 共同用于后续渲染树构建。
> c. JavaScript 的影响（关键）
> 同步阻塞脚本（普通 <script>）：解析到 <script> 会暂停 HTML 解析 —— 浏览器必须先下载并执行脚本，脚本可能修改 DOM/CSSOM，因此解析被阻塞。
> defer：脚本并行下载，但在 HTML 解析完成后按顺序执行（不会阻塞解析）。
> async：并行下载，下载完成就执行（可能在解析中断），执行顺序不保证。
> 动态创建 <script>（appendChild）：默认 async 行为（不会阻塞）。
> Service Worker 可以拦截并直接提供内容，影响是否请求网络。
> （重点：JS 能修改 DOM/CSSOM，因此会阻塞渲染）

- 9. 构建 Render Tree（渲染树）：浏览器把 DOM 和 CSSOM 合并，构建 Render Tree（渲染树）：只包含需要被绘制的可见节点（例如 display:none 会被忽略），并计算每个节点的样式（resolved style）。
- 10. 布局（Reflow / Layout）：浏览器根据渲染树计算每个可见节点的几何尺寸和位置（即各元素的宽高、x/y）。这是一个代价较高的过程。（触发重排的操作：改 width/height、添加/移除 DOM、改变字体、改变 box-model 等）
- 11. 绘制（Paint）：将布局好的每个节点绘制成图层中的绘制命令（绘制文本、颜色、边框、阴影、图片等）。这一步称为 paint。
- 12. 合成（Compositing）现代浏览器会把页面拆成多个图层（layer），并交给 GPU 合成（特别是使用 transform, opacity, will-change 等会创建图层的属性）。合成阶段把图层合并到最终帧并呈现到屏幕。（涉及 GPU rasterization、合成顺序优化、图层缓存）
- 13. 首次绘制指标（可观测点）
> 浏览器在这过程中会记录关键性能指标（供 DevTools / 报表使用）：
> > FP（First Paint）：浏览器开始绘制的时间点。
> > FCP（First Contentful Paint）：首次绘制任何有意义内容（文本、图片等）。
> > LCP（Largest Contentful Paint）：最大可视内容绘制完成时间（用户感知重要指标）。
> > DOMContentLoaded：DOM 构建完成并解析完所有脚本（不等待样式/图片）。
> > load：页面所有资源（包括图片、iframe）加载完成。

- 14. JavaScript 执行与事件循环
> 页面渲染与 JS 执行并行但又相互影响：
> > 主线程负责解析 HTML/CSS、执行 JS、布局和绘制。长时间 JS 会阻塞渲染。
> > JS 的执行遵循事件循环（macrotasks、microtasks）。微任务（Promise.then）会在当前 macrotask 完结前执行，可能导致长时间锁主线程。
> > （优化点：避免主线程长任务、使用 Web Worker 做计算密集型任务）

- 15. 后续资源加载与渲染更新：图片、字体、视频等资源可能在初次布局后异步加载并触发 repaint 或 reflow（例如图片加载改变元素尺寸会触发 reflow）。浏览器会增量地重绘或合成受影响区域。
- 16. 浏览器缓存与条件请求：在后续访问中，浏览器会使用缓存策略（强缓存 / 协商缓存）。若使用协商缓存，会发送 If-Modified-Since / If-None-Match，服务端可返回 304 以节省带宽。
- 17. 交互阶段与生命周期事件
> DOMContentLoaded：DOM 构建完（同步脚本已执行完）。
> load：所有资源加载完。
> 可以监听 requestAnimationFrame 做动画，在下一帧渲染前执行回调。

- 额外补充：常见优化点（面试高频）
> 减少阻塞资源：把脚本放底部 / 使用 defer / async。
> Critical CSS：内联关键 CSS，延迟非关键 CSS。
> 预加载/预取：<link rel="preload">、prefetch、preconnect。
> 使用 CDN、启用 gzip/brotli、HTTP/2 或 HTTP/3（QUIC）。
> 开启缓存策略、合理使用 ETag/Last-Modified。
> 减少重排/重绘：合并 DOM 操作、使用 transform 代替 top/left、避免频繁读写 layout 属性。
> 使用 Service Worker 做离线缓存与路由拦截。
> 避免主线程阻塞：分割任务、使用 Web Worker。
> 按需创建合成图层，避免过多图层占用 GPU 内存。

- 短答题模版（面试时可念）
> “用户输入 URL 后，浏览器先做 DNS 解析、建立 TCP/TLS 连接，然后发 HTTP 请求。服务器返回 HTML，浏览器边下载边解析：构建 DOM、下载并解析 CSS（生成 CSSOM）、执行阻塞或非阻塞的 JS（影响解析），将 DOM+CSSOM 合并成渲染树，进行布局（reflow）、绘制（paint）、合成（composite）并把帧交给 GPU 呈现。期间还涉及缓存、CDN、Service Worker、HTTP/2 多路复用等优化点，最终触发 DOMContentLoaded/load 等事件。”


# 六、算法
1. 红绿灯
```javascript
function trafficLight() {
  const light = async (color, duration) => {
    console.log(color);
    await new Promise(resolve => setTimeout(resolve, duration));
  };
  
  const run = async () => {
    while (true) {
      await light('红灯', 3000);
      await light('绿灯', 2000);
      await light('黄灯', 1000);
    }
  };
  run();
}
```
2. 暂停函数
```javascript
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function run() {
  console.log(1);
  await sleep(1000);
  console.log(2);
}

```
3. 实现forEach
```javascript
Array.prototype.myForEach = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    callback.call(thisArg, this[i], i, this);
  }
};
```
4. 千位分隔符
```javascript
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
// 或者
function formatNumber(num) {
  return num.toLocaleString();
```
5. 扁平化数组
```javascript
// 方法1: 递归
function flatten(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
}

// 方法2: flat
const flatten = arr => arr.flat(Infinity);// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```
6. 斐波那契数列
```javascript
// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```
7. 分块数组
```javascript
function chunk(arr, size) {
  const result = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}
```
8. 数组分组
```javascript
function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const group = typeof key === 'function' ? key(item) : item[key];
    (acc[group] = acc[group] || []).push(item);
    return acc;
  }, {});
}
```
9. compose 复合函数
```javascript
// 从右到左执行
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 从左到右执行（pipe）
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
```
10. 根据id 合并2个数组
```javascript
function mergeById(arr1, arr2) {
  const map = new Map(arr1.map(item => [item.id, item]));
  arr2.forEach(item => {
    if (map.has(item.id)) {
      Object.assign(map.get(item.id), item);
    } else {
      map.set(item.id, item);
    }
  });
  return Array.from(map.values());
}
```
11. 归约reduce
```javascript
Array.prototype.myReduce = function(callback, initialValue) {
  let acc = initialValue !== undefined ? initialValue : this[0];
  let startIndex = initialValue !== undefined ? 0 : 1;
  
  for (let i = startIndex; i < this.length; i++) {
    acc = callback(acc, this[i], i, this);
  }
  return acc;
};
```
12. 记忆函数
```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}
```
13. 精简对象（移除假值）
```javascript
function compact(obj) {
  const result = {};
  for (let key in obj) {
    if (obj[key]) result[key] = obj[key];
  }
  return result;
}
```
14. 实现map
```javascript
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback.call(thisArg, this[i], i, this));
  }
  return result;
};
```
15. ⼿动实现 call
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};
```
16. 数组出现2次的数字（找重复项）
```javascript
function findDuplicates(arr) {
  const count = {};
  return arr.filter(item => {
    count[item] = (count[item] || 0) + 1;
    return count[item] === 2;
  });
}
```
17. 数组去重
```javascript
// 方法1: Set
const unique = arr => [...new Set(arr)];

// 方法2: filter
const unique = arr => arr.filter((item, index) => arr.indexOf(item) === index);
```
18. 蜗⽜排序（螺旋矩阵）
```javascript
// 输出 n×n 的螺旋矩阵：
function snail(n) {
  const res = Array.from({ length: n }, () => Array(n).fill(0));
  let num = 1, left = 0, right = n-1, top = 0, bottom = n-1;

  while (left <= right && top <= bottom) {
    for (let i = left; i <= right; i++) res[top][i] = num++;
    top++;
    for (let i = top; i <= bottom; i++) res[i][right] = num++;
    right--;
    for (let i = right; i >= left; i--) res[bottom][i] = num++;
    bottom--;
    for (let i = bottom; i >= top; i--) res[i][left] = num++;
    left++;
  }

  return res;
}

```
19. 冒泡排序
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```
20. 原型链继承
```javascript
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype); // 继承方法
Child.prototype.constructor = Child;
```
21. deepClone 深拷⻉
```javascript
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (map.has(obj)) return map.get(obj); // 处理循环引用
  
  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  return clone;
}
```
22. promise.all()
```javascript
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('参数必须是数组'));
    }
    
    const results = [];
    let count = 0;
    
    if (promises.length === 0) return resolve(results);
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        count++;
        if (count === promises.length) resolve(results);
      }).catch(reject);
    });
  });
};
```
23. 数组去重(有排序)：
```javascript
unique(arr, key) {
  if (!arr) return arr
  if (key === undefined) return [...new Set(arr)]
  const map = {
    'string': e => e[key],
    'function': e => key(e),
  }
  const fn = map[typeof key]
  const obj = arr.reduce((o,e) => (o[fn(e)]=e, o), {})
  return Object.values(obj)
}
```

# 七、移动端适配
1. 传统rem适配⽅案
- 核心原理
```JavaScript
// flexible.js 核心代码片段
document.documentElement.style.fontSize =
document.documentElement.clientWidth / 10 + 'px';
```
> rem：根元素字体⼤⼩的倍数单位（1rem = 根字体⼤⼩）
> 动态计算：通过JS实时计算屏幕宽度，设置 <html> 的 font-size
> 设计稿换算：使⽤PostCSS插件将设计稿像素转换为rem单位（如750px设计稿
1rem=75px）

- 实现流程
	1. 引⼊ lib-flexible 或⾃研动态计算脚本
	2. 使⽤PostCSS插件 postcss-pxtorem ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 75, // 设计稿宽度/10（750/10）
      propList: ['*'] // 转换所有属性
    }
  }
}
```
- 优势分析
> 兼容性好：⽀持到Android 4.4+ / iOS 6.1+
> 精细控制：通过JS可实现复杂逻辑（如区分横竖屏）
> 历史惯性：⽼项⽬维护⽅便

- 主要缺陷
> JS依赖：需要等待JS执⾏才能完成布局计算
> 缩放失真：某些Android机型存在rem计算精度问题
> 维护成本：需要维护两套单位系统（rem + px）

2. 现代vw/vh适配⽅案
- 核心原理
```css
/* 直接使⽤视⼝单位 */
.box {
  width: 50vw; /* 视⼝宽度的50% */
  height: 30vh; /* 视⼝⾼度的30% */
}
```
> vw：视⼝宽度百分⽐（1vw = 1%视⼝宽度）
> vh：视⼝⾼度百分⽐（1vh = 1%视⼝⾼度）
> ⽆需JS：纯CSS原⽣⽀持

- 实现流程
	1. 使⽤PostCSS插件 postcss-px-to-viewport ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 750, // 设计稿宽度
      unitPrecision: 5, // 转换精度
      viewportUnit: 'vw', // ⽬标单位
      selectorBlackList: ['.no-vw'], // 忽略类名
      minPixelValue: 1 // 最⼩转换像素
    }
  }
}
```
- 优势分析
> 原⽣⽀持：现代浏览器100%⽀持（包括iOS 8+/Android 4.4+）
> 渲染性能：避免JS计算导致的布局抖动
> 开发友好：设计稿直转vw，⽆需⼿动计算
> 响应灵敏：⾃动响应窗⼝⼤⼩变化

- 注意事项
> ⾼度适配：建议使⽤ vh 时配合 calc 计算安全区域
> 字体控制：可混合使⽤rem控制字体⼤⼩

```css
/* 混合⽅案示例 */
.title {
  font-size: 1.2rem; /* 使⽤rem保持⽂字可读性 */
  margin: 0 4vw; /* 使⽤vw保持间距响应 */
}
```
3. 方案对比决策
| 维度 | rem方案 | vw/vh方案 |
| - | - | - |
| 实现复杂度 | 需要JS + 构建工具 | 仅需构建工具 |
| 布局精度 | 存在0.01rem误差 | 精确到小数点后5位 |
| 渲染性能 | 存在JS执行延误 | 首屏渲染更快 |
| 维护成本 | 需维护动态计算逻辑 | 纯CSS配置 |
| 未来兼容性 | 逐渐淘汰 | CSS标准持续支持 |
4. 现在最佳实践
- 推荐方案：vw为主 + rem辅助
```css
/* 根元素设置（可选） */
:root {
	--base-font-size: calc(16px+ 0.5vw); /* 基础字体响应式 */
}
/* 混合使⽤示例 */
.container {
  width: 90vw;
  max-width: 750px; /* 桌⾯端限制最⼤宽度 */
}
.text {
	font-size: 1.2rem; /* 保持⽂字可读性 */
}
```

- 关键配置技巧
```css
/*安全区域适配：使⽤ env(safe-area-inset-*) */
body {
	padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* 1px边框解决⽅案：结合 transform + viewport */
.border-1px {
  position: relative;
  &::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #ddd;
    transform: scaleY(0.5);
    transform-origin: 0 0;
  }
}
```

- 构建工具配置
```JavaScript
// 现代工程化配置示例（Vue/React通用）
module.exports = {
  plugins: [
    require('postcss-px-to-viewport')({
    viewportWidth: 750 ,
    viewportUnit: 'vw',
    fontViewportUnit: 'rem', // 字体单独使用rem
    require('postcss-flexbugs-fixes'),
		require('postcss-viewport-units') // ⾃动添加兼容前缀
  ]
},
```
5. 升级迁移策略
- 渐进式迁移
```css
/*新⻚⾯直接使⽤vw⽅案*/
/*旧⻚⾯通过 @media 逐步替换*/
/* 兼容代码示例 */
.old-box {
  width: 10rem;
  @media (min-width: 320px) {
  	width: 50vw;
  }
}
```
- 降级处理
```css
.modern-box {
  width: 50vw;
  width: 10rem; /* 旧浏览器回退 */
}
```
- 监控覆盖：
```JavaScript
/*使⽤ Modernizr 检测浏览器⽀持*/
if (!Modernizr.cssvwunit) {
	loadScript('legacy-rem-polyfill.js');
}
```
6. 总结建议
- 新项⽬⾸选： vw/vh + postcss-px-to-viewport ⽅案
- ⽼项⽬维护：继续使⽤rem⽅案保持稳定
- 混合场景：核⼼布局⽤vw，字体/间距⽤rem
- 特殊需求：结合CSS容器查询（ @container ）实现更智能响应
> 现代浏览器对viewport单位的⽀持已⾮常成熟，拥抱CSS原⽣⽅案能获得更好的性能表
现和开发体验。对于需要兼容极旧浏览器的特殊项⽬（如政府/银⾏系统），可考虑保留rem⽅案作为兜底。

# 八、框架部分
## 1. usestate 和 useref 区别？- React
- 原理： useState 和 useRef 是 React Hooks 中的两个钩⼦。 useState ⽤于在函数组件中添加状态，当状态更新时，组件会重新渲染。 useRef 创建⼀个可变的对象，它的值在组件的整个⽣命周期内保持不变，并且修改它不会触发组件重新渲染。
```javascript
import React, { useState, useRef } from 'react';
function Example() {
    const [count, setCount] = useState(0);
    const refCount = useRef(0);
};
const incrementState = () => {
setCount(count + 1);
const incrementRef = () => {
    refCount.current++;
    console.log('Ref count:', refCount.current);
};
return (
    <div>
        <p>State count: {count}</p>
        <button onClick={incrementState}>Increment State</button>
        <button onClick={incrementRef}>Increment Ref</button>
    </div>
    );
}
export default Example;
```
- 代码细节： useState 返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染。 useRef 返回⼀个对象，通过 current 属性访问和修改其值。
- 案例应⽤： useState 适⽤于需要触发组件重新渲染的状态管理，如表单输⼊值、 计数器等。 useRef 适⽤于保存不需要触发重新渲染的值，如 DOM 节点引⽤、定时器 ID 等。








