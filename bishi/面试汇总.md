# ⼀、HTML部分
## 1. script标签为什么放在body下⾯？
- 避免阻塞渲染：”script 默认会阻塞 HTML 解析，放在顶部会导致页面白屏时间变长。
- 提高页面加载速度：让 HTML 结构优先渲染出来，提升用户体验。
- 保证 DOM 已加载：某些脚本依赖页面元素，放在 body 底部能避免 document.getElementById找不到元素的问题。
- 总结： script 放底部是为了 性能优化 + 避免阻塞 + DOM 可用性。

## 2. HTML5语义化标签
- 常见的语义化标签：
> \<header>：头部区域
> \<nav>：导航部分
> \<section>：页面章节内容
> \<article>：独立的文章内容
> \<aside>：侧边栏
> \<footer>：尾部内容
> \<main>：页面主要内容
> \<figure> / \<figcaption>：带标注的媒体内容
> \<mark>：标记高亮
> \<time>：时间

- 好处：
> 结构更清晰，便于维护
> 有利于 SEO（搜索引擎更易理解结构）
> 有利于无障碍阅读（屏幕阅读器可识别语义）

## 3. ⾃定义属性 data-*
- data-* 是 HTML5 提供的用于存储自定义数据的方式，如：
```html
<div data-id="123" data-role="admin"></div>
```
- 特点
> 1. 可通过 JS 获取：element.dataset.id
> 2. 不会污染标准属性
> 3. 常用于组件初始化、业务标记

- 应用场景
> 存储业务数据
> 存储 UI 组件配置
> 在 HTML 与 JS 之间传递信息

## 4. 块级元素、⾏内元素
- 块级元素（block）
> 特点：独占一行，可以设置宽高、margin、padding，宽度默认 100%
> 常见：div, p, ul, li, h1~h6, section, article, header, footer

- 行内元素（inline）
> 特点：不独占一行，不能设置宽高（默认内容撑开），padding、margin 只有左右生效
> 常见：span, a, img（特殊，可替换）, strong, em

- 行内块元素 inline-block
> 可设置宽高，但不独占一行。

## 5. BFC
- BFC 是浏览器布局的一种渲染区域，有一套自己的布局规则。
- 如何触发 BFC？
> overflow: hidden | auto | scroll
> float: left/right
> display: inline-block
> position: absolute/fixed
> display: flow-root

- BFC 能解决什么？
> 清除浮动：父元素形成 BFC 就能包住子元素浮动高度。
> 避免 margin 重叠（外边距折叠）
> 避免浮动元素遮挡内容
> 自适应多列布局
> 一句话总结：BFC = 独立布局环境，用来解决浮动、margin 重叠等问题。

## 6. 可替换元素
- 浏览器根据其标签属性或外部资源来决定具体内容和尺寸。
- 常见可替换元素：
> img，input，textarea，button，select，iframe，video，embed

- 特点
> 1. 宽高可以设置
> 2. 内容由浏览器替换渲染
> 3. 默认行为一般不可用 CSS 完全控制

## 7. 脚本异步加载，三种常见方式（script标签中的defer和async）：
### 7.1. async
```html
<script src="a.js" async></script>
```
> 下载与解析 HTML 并行
> 下载完立即执行（可能会阻塞）
> 多个 script 执行顺序不保证

### 7.2. defer
```html
<script src="a.js" defer></script>
```
> 下载与解析 HTML 并行
> 等 DOM 全部解析完后按顺序执行
> 一般用于依赖 DOM 的代码
> 案例应⽤：若脚本有依赖关系且需在⽂档解析完后执⾏，⽤ defer ；若脚本⽆依赖且不影响⻚⾯渲染，⽤ async 。例如在加载第三⽅统计脚本时可⽤ async ，加载依赖于⽂档结构的脚本时⽤ defer 。

### 7.3. 动态创建 script
```JavaScript
const s = document.createElement('script');
s.src = 'xxx.js';
document.body.appendChild(s);
```
> 默认异步加载，等价于 async

## 8. a 标签 noopener 是什么？
```html
<!--当你使用-->
<a href="xxx" target="_blank" rel="noopener">
```
- 作用
> 防止新窗口通过 window.opener 控制原页面（安全）
> 防止恶意页面修改原窗口 Location（钓鱼攻击）
> 提升性能： 新页面不会与当前页面共享进程（Chrome），提升隔离性。
> 延伸：rel="noopener noreferrer" 中 noreferrer 还会隐藏 referer。
> 

## 9. 解析 html 标签时哪些是异步的？哪些是同步的？
> HTML 解析时， \<script> 标签默认同步加载执⾏，会阻塞⽂档解析。加defer 或 async 属性的 \<script> 异步。 \<link rel="stylesheet"> 同步加载，不阻塞⽂档解析，但阻塞 DOMContentLoaded 事件。 \<img> 异步加载，不影响⽂档解析。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <!-- 同步加载样式 -->
        <link rel="stylesheet" href="styles.css">
        <!-- 默认同步脚本 -->
        <script src="sync.js"></script>
        <!-- 异步脚本 -->
        <script async src="async.js"></script>
    </head>
    <body>
        <!-- 异步加载图⽚ -->
        <img src="example.jpg" alt="Example">
    </body>
</html>
<!--案例应⽤：合理安排标签的同步异步加载，可优化⻚⾯性能。如将不影响⻚⾯渲染的脚本设为异步，避免阻塞⽂档解析；将样式⽂件放在头部同步加载，确保⻚⾯样式正常显示。-->
```

# 二、CSS部分
## 1. 盒子模型（Box Model）
- CSS 有 标准盒模型 和 IE 盒模型。
- 标准盒模型（content-box）
> 盒子总宽度 = width + padding + border + margin

- IE 盒模型（border-box）,width 包含了 padding 和 border：
> 盒子总宽度 = width + margin
> border-box 优点：布局更好算、不容易超出容器。

```css
box-sizing: content-box;   /* 默认 */
box-sizing: border-box;    /* 更常用 */
```

## 2. GPU 渲染（硬件加速）
- 浏览器渲染一般分为：
> CPU：负责布局、绘制
> GPU：负责合成、加速动画

- 哪些 CSS 会触发 GPU 加速？
> transform（translate、scale），opacity，filter，will-change，translateZ(0)、translate3d(0,0,0)

- 优点
> 更流畅的动画（不会反复重排/重绘）
> 避免页面抖动（减少 layout）

- 缺点
> 占用 GPU 内存（图层过多会卡）
> 滥用可能导致耗电、掉帧

- 一句话：使用 transform + opacity 做动画，会进入 GPU 合成层，性能最好。

## 3. flex布局、grid布局
### 3.1 Flex（弹性布局）
- Flex 是 Flexible Box 的缩写，意为“弹性布局”，⽤于为盒状模型提供最⼤的灵活性。任何⼀个容器都可以指定为 Flex 布局。当为⽗元素设置 display: flex 或 display:inline-flex 后，⼦元素的 float 、 clear 和 vertical-align 属性将失效。
- 基本概念：采⽤ Flex 布局的元素，称为 Flex 容器（flex container），简称“容器”。它的所有⼦元素⾃动成为容器成员，称为 Flex 项⽬（flex item），简称“项⽬” 。
- 容器默认存在两根轴：⽔平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start ，结束位置叫做 main end ；交叉轴的开始位置叫做 cross start ，结束位置叫做 cross end 。项⽬默认沿主轴排列，单个项⽬占据的主轴空间叫做 main size ，占据的交叉轴空间叫做 cross size 。
- 一维布局：主轴 + 交叉轴
- 容器的属性：
  - display，定义有一个元素为Flex容器，有两种取值：flex，容器为块级元素；inline-flex，容器为行内元素
  - flex-direction，决定主轴的方向，即项目的排列方向
    - row （默认值）：主轴为⽔平⽅向，起点在左端。 
    - row-reverse ：主轴为⽔平⽅向，起点在右端。
    - column ：主轴为垂直⽅向，起点在上沿。
    - column-reverse ：主轴为垂直⽅向，起点在下沿。
  - flex-wrap，定义如果⼀条轴线排不下，如何换⾏
    - nowrap （默认值）：不换⾏。 
    - wrap ：换⾏，第⼀⾏在上⽅。 
    - wrap-reverse ：换⾏，第⼀⾏在下⽅。
  - flex-flow，是 flex-direction 和 flex-wrap 的简写形式，默认值为 row nowrap。
  - justify-content，定义了项目在主轴上的对齐方式
    - flex-start：左对齐
    - flex-end：右对齐
    - center：居中
    - space-between：两端对齐，项目之间的间隔都相等
    - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
  - align-items，定义项目在交叉轴上如何对齐
    - stretch （默认值）：如果项⽬未设置⾼度或设为 auto ，将占满整个容器的⾼度。 
    - flex-start ：交叉轴的起点对⻬。 
    - flex-end ：交叉轴的终点对⻬。 
    - center ：交叉轴的中点对⻬。 
    - baseline ：项⽬的第⼀⾏⽂字的基线对⻬。
  - align-content，定义了多根轴线的对⻬⽅式。如果项⽬只有⼀根轴线，该属性不起作⽤。
    - stretch （默认值）：轴线占满整个交叉轴。
    - flex-start ：与交叉轴的起点对⻬。 
    - flex-end ：与交叉轴的终点对⻬。 
    - center ：与交叉轴的中点对⻬。 
    - space-between ：与交叉轴两端对⻬，轴线之间的间隔平均分布。 
    - space-around ：每根轴线两侧的间隔都相等。所以，轴线之间的间隔⽐轴线与边框的间隔⼤⼀倍。
- 项目的属性
  - order：定义项⽬的排列顺序。数值越⼩，排列越靠前，默认为 0。
  - flex-grow：定义项⽬的放⼤⽐例，默认为 0，即如果存在剩余空间，也不放⼤。如果所有项⽬的 flex - grow 属性都为 1，则它们将等分剩余空间
  - flex-basis：定义了在分配多余空间之前，项⽬占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项⽬的本来⼤⼩。
  - flex：是 flex-grow、 flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。
  -  align-self：允许单个项⽬有与其他项⽬不⼀样的对⻬⽅式，可覆盖 align-items 属性。默认值为 auto ，表示继承⽗元素的 align-items 属性，如果没有⽗元素，则等同于 stretch 。
- 适用场景：
> 水平垂直居中
> 响应式导航栏
> 不定宽高布局

### 3.2 Grid（网格布局）
- 二维布局：可以同时控制行 + 列
- 常用属性：
> 行列大小：grid-template-rows / grid-template-columns
> 格子间距：gap
> 子项定位：grid-row / grid-column
> 自动填充：repeat(auto-fill, minmax())

- 适用场景：
> 桌面级布局
> 瀑布流
> 仿 Excel 栅格

- 总结区别
| 布局方式 | Flex | Grid |
| - | - | - |
| 维度 | 一维 | 二维 |
| 场景 | 内容自适应 | 更像先规划版面 |
| 控制 | 子项之间关系 | 行列网格精确布局 |

## 4. 百分比（%）的计算规则
- 关键点：百分比的参考对象，取决于属性本身。
| 属性                                         | 百分比相对于                   |
| ------------------------------------------ | ------------------------ |
| width                                      | 父元素 width                |
| height                                     | **不一定能生效**，取决于父元素是否有明确高度 |
| padding                                    | 父元素 **width**            |
| margin                                     | 父元素 width                |
| transform                                  | 自身大小                     |
| position: absolute 的 left/right/top/bottom | 包含块（一般为最近的定位父元素）         |
- 最容易考的点：padding 百分比是相对父元素的宽度，而不是高度，例如保持正方形常用：
```css
.box {
  width: 50%;
  padding-top: 50%; /* 相对父元素宽度 */
}
```

## 5. 如何实现随窗⼝⼤⼩变化的正⽅形？
- 使用 padding-top
```css
.square {
  width: 30%;
  padding-top: 30%;
  background: #1677ff;
}
```
- 使用 aspect-ratio，最常用，最现代
```css
.square {
  width: 200px;
  aspect-ratio: 1 / 1;
  background: #1677ff;
}
```
- 使用 vw（相对视口）
```css
.square {
  width: 20vw;
  height: 20vw;
}
```
- JS 动态设置（不推荐）
> 监听 window 大小然后设置 height=width。

- 总结最优解：
> aspect-ratio: 1; 是最简洁最现代的写法。

## 6. 了解重排和重绘吗？
- 重排（回流）是指当 DOM 的变化影响了元素的布局信息（元素的宽⾼、边距、位置等），浏览器需要重新计算元素在视⼝内的位置和⼤⼩。
- 重绘是指当⼀个元素的外观发⽣改变，但没有影响到布局信息时，浏览器将新样式绘制到屏幕上。 
- 重排的代价⽐重绘⼤，因为重排可能会触发后续⼀系列元素的重排和重绘。
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #box {
                width: 100px;
                height: 100px;
                background-color: red;
            }
        </style>
    </head>
<body>
    <div id="box"></div>
    <button onclick="changeWidth()">Change Width</button>
    <button onclick="changeColor()">Change Color</button>
    <script>
    function changeWidth() {
        const box = document.getElementById('box');
        box.style.width = '200px'; // 触发重排和重绘
    }
    function changeColor() {
        document.getElementById('box');
        const box = box.style.backgroundColor = 'blue'; // 触发重绘
    }
    </script>
</body>
</html>
<!--案例应⽤：在开发中，应尽量减少重排和重绘的次数。⽐如批量修改 DOM 样式时，可先将元素从⽂档流中移除，修改完后再添加回去；避免频繁读取会触发重排的属性，如 offsetWidth 、 scrollTop 等。-->
```

## 7. CSS 和 JS 动画会导致重排吗？
- CSS 动画和 JS 动画是否导致重排取决于动画改变的属性。如果改变的是影响布局信息的属性（如宽度、⾼度、边距等），则会触发重排；如果改变的是只影响外观的属性（如颜⾊、透明度等），则只会触发重绘。⼀般来说，CSS 的 transform 和 opacity 属性在动画中不会触发重排，性能较好。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    #box {
    width: 100px;
    height: 100px;
    background-color: red;
    transition: all 1s;
    transform: translateX(100px); /* 不会触发重排 */
    width: 200px; /* 会触发重排 */
    }
    .move {
    }
    .resize {
    }
    </style>
</head>
<body>
    <div id="box"></div>
    <button onclick="moveBox()">Move Box</button>
    <button onclick="resizeBox()">Resize Box</button>
    <script>
        function moveBox() {
            const box = document.getElementById('box');
            box.classList.add('move');
        }
        function resizeBox() {
            const box = document.getElementById('box');
            box.classList.add('resize');
        }
    </script>
</body>
</html>
<!--案例应⽤：在实现动画效果时，优先使⽤ transform 和 opacity 属性来创建动画，以提⾼性能。例如制作元素的移动、旋转、缩放等动画时，使⽤transform属性；制作淡⼊淡出效果时，使⽤ opacity 属性。-->
```

# 三、JS部分
## 1. 事件——冒泡、捕获、委托、⾃定义事件
### 1.1 事件流：捕获 → 目标 → 冒泡
- 事件流分三阶段：
> 捕获阶段（从 window → 根节点 → 目标父层级）
> 目标阶段
> 冒泡阶段（从目标 → 向上冒到 window）

```JavaScript
// 绑定事件时：
element.addEventListener('click', handler, true);  // 捕获
element.addEventListener('click', handler, false); // 冒泡（默认）
```
### 1.2 事件委托（Event Delegation）
- 利用事件冒泡，将子元素事件统一绑定到父元素上。
- 优点：
> 减少事件绑定数量，提高性能
> 动态元素也能响应事件
> 便于管理事件

```JavaScript
// 例子：
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log(e.target.innerText);
  }
});
```
### 1.3 自定义事件（CustomEvent）
```JavaScript
// 创建一个事件：
const event = new CustomEvent('myEvent', { detail: { id: 1 } });
element.dispatchEvent(event);
// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.id);
});
```
- 用途：组件通信，状态通知，解耦代码

## 2. DOM API
- 常用 DOM 操作：
```JavaScript
// 查找元素：
document.getElementById()
document.querySelector()
document.querySelectorAll()
document.getElementsByClassName()
document.getElementsByTagName()
// 创建与插入
document.createElement()
parent.appendChild()
parent.insertBefore()
parent.append()
element.innerHTML
// 删除
element.remove()
parent.removeChild()
// 属性
element.getAttribute()
element.setAttribute()
element.dataset
// 样式
element.style
window.getComputedStyle()
// 节点关系
element.parentNode
element.children
element.nextElementSibling
// 尺寸与位置
element.getBoundingClientRect()
element.offsetWidth / offsetHeight
element.scrollTop
```

## 3. this、原型链
### 3.1 this的绑定规则，this 由 调用方式 决定：

| 情况              | this 指向                  |
| --------------- | ------------------------ |
| 作为对象方法调用        | 该对象                      |
| 普通函数调用          | window / undefined（严格模式） |
| 构造函数            | 实例对象                     |
| bind/call/apply | 显式绑定的值                   |
| 箭头函数            | 外层作用域的 this（无法被修改）       |

- 一句话总结：箭头函数的 this = 定义时的外层作用域，不会变。

### 3.2 原型与原型链
> 每个对象都有一个隐藏属性：__proto__
> 每个函数都有一个属性：prototype

```JavaScript
// 关系图（最常问）
obj → __proto__ → Object.prototype → null
fn  → __proto__ → Function.prototype → Object.prototype
```

- 原型链查找规则，访问属性时：
> 先查对象自身
> 找不到往原型链上查
> 一直到 Object.prototype
> 再到 null 停止

## 4. 数据类型转换
- JS 有 显示转换 和 隐式转换。
```JavaScript
// 显示转换
String(123)  → "123"
Number("123") → 123
Boolean(0) → false
parseInt("12px") → 12
parseFloat("3.14") → 3.14
```
- 隐式转换：主要发生在 +, ==, 比较运算、if 判断中
```JavaScript
// + 运算符，若其中一项为字符串 → 转成字符串拼接，否则 → 转成数字
1 + '2' = '12'
'2' - 1 = 1

// ==（宽松等于）规则，最重要规则：
null == undefined   // true
但 null != 0
// 对象与原始类型比较时：对象先转成原始类型（valueOf → toString）,例如：
[1] == 1  // true
[] == 0   // true
[] == ''  // true
```
-  Boolean 真假值判断
```JavaScript
// 假值（6个）：
false
0
''//（空字符串）
null
undefined
NaN
// 其余都是真值，包括：[]、{}、"0"、"false"
```

## 5. 为什么通过getElementsByClassName获取的元素集合⽆法直接forEach
- 原因：getElementsByClassName 返回的是 HTMLCollection，不是数组。
- HTMLCollection 的特点：
> 是类数组，但 不是数组
> 没有 forEach 方法
> 是动态集合（会自动更新）

- 证明： typeof document.getElementsByClassName('xx')  // object
- 解决方式
```JavaScript
// 转成数组
Array.from(collection).forEach(...)
// 使用扩展运算符
[...collection].forEach(...)
// 直接使用for
for (let i = 0; i < collection.length; i++) { ... }
```
- 改用 querySelectorAll：因为它返回的是 NodeList，天然就有 forEach。

## 6. event loop
- Event Loop（事件循环）是 JavaScript 的执⾏机制，⽤于处理异步操作。JavaScript 是单线程的，为了处理异步任务（如定时器、⽹络请求等），引⼊了事件循环机制。它的核⼼包括调⽤栈（Call Stack）、任务队列（Task Queue，分为宏任务队列和微任务队列）。当调⽤栈中的同步任务执⾏完后，事件循环会不断从任务队列中取出任务放⼊调⽤栈执⾏。
```javascript
console.log('Start');
setTimeout(() => {console.log('Timeout')}, 0);
Promise.resolve().then(() => { console.log('Promise');});
console.log('End');
```
- 代码细节：⾸先， console.log('Start') 是同步任务，直接在调⽤栈执⾏并输出。 setTimeout 是宏任务，会在 0 毫秒后将回调函数放⼊宏任务队列。 Promise.resolve().then() 是微任务，会将回调函数放⼊微任务队列。 console.log('End') 也是同步任务，接着执⾏。当调⽤栈为空时，事件循环会先处理微任务队列中的任务，所以输出 Promise ，然后处理宏任务队列中的任务，输出 Timeout 。
- 案例应⽤：在处理异步操作时，如⽹络请求、定时器等，事件循环机制确保了代码的执⾏顺序和异步任务的处理。例如在前端开发中，使⽤ fetch 进⾏⽹络请求，请求完成后的回调函数会通过事件循环机制在合适的时机执⾏。

## 7. 事件循环代码输出
```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
    async function async2() {
        console.log('async2');
    }
}
console.log('setTimeout');
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve) => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});
console.log('script end');
```
- 同样基于事件循环机制，分析代码中同步任务、微任务和宏任务的执⾏顺序。 async/await 本质上是基于 Promise 的语法糖， await 会暂停当前函数的执⾏，等待后⾯的 Promise 完成。
- 代码细节：
  - i. ⾸先执⾏同步任务，输出 script start。 
  - ii. setTimeout 是宏任务，将回调函数放⼊宏任务队列。 
  - iii. 调⽤ async1 函数，输出 async1 start ，接着调⽤ async2 函数，输出async2。 await async2() 暂停 async1 函数的执⾏。 
  - iv. 执⾏ new Promise ，输出 promise1， resolve() 后将 then 回调放⼊微任务队列。 
  - v. 输出 script end ，此时调⽤栈为空。 
  - vi. 处理微任务队列，先执⾏ async1 函数中 await 后⾯的代码，输出 async1 end ，再执⾏ Promise 的 then 回调，输出 promise2。 
  - vii. 处理宏任务队列，输出 setTimeout 。
- 案例应⽤：理解事件循环代码输出顺序有助于调试和优化涉及异步操作的代码，避免出现意外的执⾏顺序问题。

## 8. 平时是怎么发异步请求的
- 在前端开发中，常⻅的发送异步请求的⽅式有 XMLHttpRequest、 fetchAPI 和第三⽅库如 axios 。这些⽅式都是基于浏览器的⽹络请求能⼒，通过异步操作获取服务器数据，避免阻塞主线程。
- 代码案例（使⽤ fetch ）：
```javascript
fetch('https://api.example.com/data').then(response => {
if (!response.ok) {
    throw new Error('Network response was not ok');
}
    return response.json();
}).then(data => {console.log('Data:', data);})
.catch(error => {console.error('Error:', error)})
```
- 代码细节： fetch 函数返回⼀个 Promise ，它接收⼀个 URL 作为参数。第⼀个 then ⽅法处理响应对象，检查响应状态是否正常，若正常则将响应数据解析为JSON。第⼆个 then ⽅法处理解析后的数据。 catch ⽅法捕获请求过程中出现的错误。
- 案例应⽤：在开发中，当需要从服务器获取数据时，如获取⽤户信息、商品列表等，可使⽤上述⽅法发送异步请求。

## 9. 事件循环你是怎么⽤的
- 事件循环主要⽤于处理异步任务，合理利⽤事件循环机制可以优化代码性能和实现复杂的异步逻辑。例如，将⼀些耗时的操作放在异步任务中，避免阻塞主线程。
```javascript
function longRunningTask() {
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += i;
}}
return sum;
// 使⽤ setTimeout 将耗时任务放⼊宏任务队列
setTimeout(() => {
    const result = longRunningTask();
    console.log('Task result:', result);
}, 0);
console.log('Main thread continues...');
```
- 代码细节： longRunningTask 是⼀个耗时的计算任务。使⽤ setTimeout 将其放⼊宏任务队列，主线程可以继续执⾏后续代码，输出 Main thread continues... 。当调⽤栈为空时，事件循环会从宏任务队列中取出longRunningTask 并执⾏。
- 案例应⽤：在前端开发中，对于⼀些复杂的计算、⼤数据处理等耗时操作，可利⽤事件循环将其异步化，避免⻚⾯卡顿。

## 10.防抖节流的作⽤
- 防抖（Debounce）和节流（Throttle）是两种优化⾼频触发事件的技术。防抖是指在⼀定时间内，只有最后⼀次触发事件才会执⾏回调函数；节流是指在⼀定时间内，只执⾏⼀次回调函数。
- 防抖是在⼀定时间内只有最后⼀次触发事件才执⾏回调，节流是在⼀定时间内只执⾏⼀次回调。
```javascript
// 防抖
function debounce(func, delay) {
    let timer = null;
return function () {
    const context = this;
    const args = arguments;
    if (timer) {clearTimeout(timer);}
    timer = setTimeout(() => {
        func.apply(context, args);
    }, delay);
};
}
function search() {console.log('Searching...'); }
const debouncedSearch = debounce(search, 300);
const input = document.getElementById('search-input');
input.addEventListener('input', debouncedSearch);
//节流
function throttle(func, delay) {
    let timer = null;
    return function () {
        if (!timer) {
            const context = this;
            const args = arguments;
            func.apply(context, args);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    };
}
function scrollHandler() {console.log('Scrolling...');}
const throttledScroll = throttle(scrollHandler, 500);
window.addEventListener('scroll', throttledScroll);
```
- 代码细节：防抖函数通过 setTimeout 和 clearTimeout 来控制回调函数的执⾏，每次触发事件时都会清除之前的定时器，重新计时。节流函数通过⼀个定时器来控制回调函数的执⾏频率，在定时器存在时不执⾏回调函数。
- 案例应⽤：防抖适⽤于搜索框输⼊联想、窗⼝⼤⼩调整等场景，避免频繁触发事件导致性能问题。节流适⽤于滚动加载、按钮点击等场景，控制事件的触发频率。
- 防抖使⽤场景分析：
  - 搜索框输⼊联想：当⽤户在搜索框输⼊内容时，不需要每次输⼊⼀个字符就发起请求，⽽是等⽤户停⽌输⼊⼀段时间后再发起请求，减少不必要的
    请求次数。 
  - 窗⼝⼤⼩调整：当窗⼝⼤⼩改变时，不需要每次⼤⼩变化都触发重新布局等操作，等⽤户停⽌调整⼀段时间后再进⾏处理。
- 节流
  - 滚动加载：在⻚⾯滚动时，不需要每次滚动都去检查是否需要加载更多数据，⽽是每隔⼀段时间检查⼀次，避免频繁触发加载操作。 
  - 按钮点击：对于⼀些防⽌⽤户重复点击的按钮，⽐如提交表单按钮，使⽤节流可以确保在⼀定时间内只响应⼀次点击事件。

## 11. js 写⼀下保留两位⼩数
- 在 JavaScript 中，可以使⽤ toFixed() ⽅法或数学计算来实现保留两位⼩数的功能。 toFixed() ⽅法会将数字转换为字符串，并按照指定的⼩数位数进⾏四舍五⼊。
```javascript
// 使⽤ toFixed() ⽅法
const num = 3.14159;
const result = num.toFixed(2);
console.log(result); // 输出: "3.14"
// 数学计算方法
const num = 3.14159;
const result = Math.round(num * 100) / 100;
console.log(result); // 输出: 3.14
```
- 代码细节： toFixed(2) 直接将数字转换为保留两位⼩数的字符串。数学计算⽅法先将数字乘以 100，然后使⽤ Math.round() 进⾏四舍五⼊，最后再除以 100 得到保留两位⼩数的结果。 
- 案例应⽤：在处理货币⾦额、统计数据等需要精确到⼩数点后两位的场景中使⽤。

## 12. 合并区间
- 合并区间问题通常是给定⼀个包含多个区间的数组，需要将重叠的区间合并为⼀个区间。可以先对区间数组按照区间的起始位置进⾏排序，然后遍历数组，合并重叠的区间。
```javascript
function merge(intervals) {
    if (intervals.length <= 1) return intervals;
    intervals.sort((a, b) => a[0] - b[0]);
    const result = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = result[result.length - 1];
        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            result.push(current);
        }
    }
    return result;
}
const intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
const mergedIntervals = merge(intervals);
console.log(mergedIntervals); // 输出: [[1, 6], [8, 10], [15, 18]]
```
- 代码细节：⾸先对区间数组进⾏排序，确保区间按起始位置从⼩到⼤排列。然后遍历数组，⽐较当前区间和结果数组中最后⼀个区间是否重叠，如果重叠则合并，否则将当前区间添加到结果数组中。 
- 案例应⽤：在⽇程安排、时间管理等场景中，合并重叠的时间区间可以更清晰地展示可⽤时间。

## 13. 常⻅的数据结构的特点
- 常⻅的数据结构包括数组、链表、栈、队列、树、图等，每种数据结构都有其独特的特点和适⽤场景。
```javascript
// 数组
const array = [1, 2, 3, 4, 5];
// 链表节点类
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}
const node1 = new ListNode(1);
const node2 = new ListNode(2);
node1.next = node2;
// 栈
class Stack {
    constructor() {
        this.items = [];
    }
    push(item) {
        this.items.push(item);
    }
    pop() {
        return this.items.pop();
    }
}
const stack = new Stack();
stack.push(1);
stack.push(2);
console.log(stack.pop()); // 输出: 2
// 队列
class Queue {
    constructor() {
        this.items 
    }
    enqueue(item) {
        this.items.push(item);
    }
    dequeue() {
        return this.items.shift();
    }
}
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
console.log(queue.dequeue()); // 输出: 1
```
- 代码细节：数组是⼀种线性数据结构，⽀持随机访问，通过下标可以快速访问元素。链表是由节点组成的线性数据结构，每个节点包含数据和指向下⼀个节点的指针，插⼊和删除操作效率⾼。栈是⼀种后进先出（LIFO）的数据结构，只能在栈顶进⾏插⼊和删除操作。队列是⼀种先进先出（FIFO）的数据结构，在队尾插⼊元素，在队头删除元素。
- 案例应⽤：数组适⽤于需要随机访问元素的场景，如排序算法。链表适⽤于频繁插⼊和删除元素的场景，如实现栈和队列。栈适⽤于函数调⽤栈、浏览器历史记录等场景。队列适⽤于任务调度、消息队列等场景。

## 14. 设计模式-单例模式
- 设计模式是指在软件开发过程中，针对反复出现的问题所总结归纳出的通⽤解决⽅案。常⻅的设计模式包括单例模式、⼯⼚模式、观察者模式、装饰器模式等。
```javascript
// 单例模式
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            this.data = [];
            Singleton.instance = this;
        }
        return Singleton.instance;
    }
    addItem(item) {
        this.data.push(item);
    }
    getData() {
        return this.data;
    }
}
const instance1 = new Singleton();
const instance2 = new Singleton();
instance1.addItem('Item 1');
console.log(instance2.getData()); // 输出: ['Item 1']
```
- 代码细节：单例模式确保⼀个类只有⼀个实例，并提供⼀个全局访问点。在Singleton 类的构造函数中，检查是否已经存在实例，如果不存在则创建⼀个新 实例，否则返回已有的实例。 
- 案例应⽤：单例模式适⽤于需要确保只有⼀个实例的场景，如数据库连接池、⽇志记录器等。⼯⼚模式适⽤于根据不同的条件创建不同类型的对象。观察者模式适⽤于对象之间的⼀对多依赖关系，当⼀个对象的状态发⽣变化时，所有依赖它的对象都会得到通知。

## 15. 观察者模式
- 观察者模式定义了⼀种⼀对多的依赖关系，当⼀个对象（主题）的状态发⽣变化时，所有依赖它的对象（观察者）都会得到通知并⾃动更新。
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }
    addObserver(observer) {
        this.observers.push(observer);
    }
    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index!== -1) {
            this.observers.splice(index, 1);
        }
        
    }
    notify() {
        this.observers.forEach(observer => observer.update());
    }
    setState(newState) {
        this.state = newState;
        this.notify();
    }
}
class Observer {
    constructor(subject) {
        this.subject = subject;
        this.subject.addObserver(this);
    }
    update() {
        console.log(`Observer updated with state:${this.subject.state}`);
    }
}
const subject = new Subject();
const observer1 = new Observer(subject);
const observer2 = new Observer(subject);
subject.setState('New state');
```
- 代码细节： Subject 类表示主题，包含⼀个观察者数组，提供添加、移除观察者和通知观察者的⽅法。 Observer 类表示观察者，在构造函数中注册到主题上，并实现 update ⽅法⽤于接收主题的通知。 
- 案例应⽤：在前端开发中，观察者模式常⽤于实现事件系统、状态管理库等。例如，当⼀个组件的状态发⽣变化时，通知其他依赖该组件的组件进⾏更新。

## 16. 【代码】实现⼀个 call 改变 this 指向
-  call ⽅法⽤于调⽤⼀个函数，并指定该函数内部的 this 值。可以通过将函数挂载到指定的对象上，然后调⽤该对象的⽅法来实现 this 指向的改变。
```javascript
Function.prototype.myCall = function (context = window, ...args) {
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;
    const result = context[fnSymbol](...args);
    delete context[fnSymbol];
    return result;
};
function greet(message) {
    console.log(`${message}, ${this.name}`);
}
const person = { name: 'John' };
greet.myCall(person, 'Hello'); // 输出: Hello, John
```
- 代码细节：在 Function.prototype 上添加 myCall ⽅法，将调⽤ myCall 的函数挂载到 context 对象上，使⽤ Symbol 作为属性名避免冲突。调⽤该属性并传⼊参数，最后删除该属性并返回结果。 
- 案例应⽤：在需要动态改变函数 this 指向的场景中使⽤，如在回调函数中使⽤特定对象的⽅法。

## 17. 【代码】实现⼀个 promise.all
-  Promise.all ⽅法接收⼀个可迭代对象（通常是数组），该数组中的每个元素都是⼀个 Promise 对象，返回⼀个新的 Promise 。当所有输⼊的 Promise都成功完成时，新的 Promise 会以⼀个包含所有结果的数组进⾏ resolve ；如果其中任何⼀个 Promise 被 reject ，新的 Promise 会⽴即以该错误进⾏reject。
```javascript
function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('Expected an array'));
        }
        const results = [];
        let completedCount = 0;
        if (promises.length === 0) {
            return resolve(results);
        }
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                results[index] = result;
                completedCount++;
                if (completedCount === promises.length) {
                    resolve(results);
                }
            
        }).catch(error => {
            reject(error);
            });
        });
    });
}
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

promiseAll([promise1, promise2, promise3]).then(results => {
    console.log(results); // 输出: [1, 2, 3]
}).catch(error => {
    console.error(error);
});
```
- 代码细节：⾸先检查传⼊的 promises 是否为数组，若不是则 reject 。创建⼀个结果数组和⼀个计数器，遍历 promises 数组，使⽤ Promise.resolve 确保每个元素都是 Promise 对象。当⼀个 Promise 成功完成时，将结果存⼊结果数组，计数器加 1，当计数器等于数组⻓度时， resolve 结果数组。若有⼀个Promise 被 reject ，则⽴即 reject 整个 Promise 。 
- 案例应⽤：在需要同时处理多个异步任务，并且需要等待所有任务都完成后再进⾏下⼀步操作的场景中使⽤，如批量请求数据。

## 18. 实现 promise any ⽅法 和 once ⽅法？
- Promise.any 实现：Promise.any 接收⼀个可迭代对象，返回⼀个新的 Promise 。当可迭代对象中的任何⼀个 Promise 成功完成时，新的 Promise 会以该 Promise的结果进⾏ resolve ；如果所有 Promise 都被 reject ，则新的 Promise会以⼀个包含所有错误的 AggregateError 进⾏ reject。
```javascript
Promise.myAny = function (promises) {
    return new Promise((resolve, reject) => {
        const errors = [];
        let rejectedCount = 0
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(result => {
                resolve(result);
            }).catch(error => {
                errors[index] = error;
                rejectedCount++;
            if (rejectedCount === promises.length) {
                reject(new AggregateError(errors, 'All promises were rejected'));
            }
        });
    });
});
};
const promise1 = Promise.reject(new Error('Error 1'));
const promise2 = Promise.resolve('Success');
const promise3 = Promise.reject(new Error('Error 2'));
Promise.myAny([promise1, promise2, promise3]).then(result => {
    console.log(result); // 输出: Success
}).catch(error => {console.error(error);});
// 代码细节
// 1. 遍历 `promises` 数组，使⽤ `Promise.resolve` 确保每个元素都是`Promise` 对象。
// 2. 当有⼀个 `Promise` 成功时，⽴即 `resolve` 该结果。
// 3. 当所有 `Promise` 都被 `reject` 时，`reject` ⼀个包含所有错误的`AggregateError`。
```
- once ⽅法实现：once ⽅法⽤于确保⼀个函数只执⾏⼀次。可以通过闭包来实现，在函数内部记录函数是否已经执⾏过。
```javascript
function once(func) {
    let hasBeenCalled = false;
    let result;
    return function (...args) {
        if (!hasBeenCalled) {
            result = func.apply(this, args);
            hasBeenCalled = true;
        }
        return result;
    };
}
function greet() {console.log('Hello!');}
// 代码细节
// 1. 使⽤闭包变量 `hasBeenCalled` 记录函数是否已经执⾏过。
// 2. 第⼀次调⽤时执⾏函数并记录结果，将 `hasBeenCalled` 设为 `true`，后续调⽤直接返回第⼀次的结果。
```
- 案例应⽤： Promise.any 适⽤于多个异步任务，只要有⼀个成功就可以继续后续操作的场景； once ⽅法适⽤于只需要执⾏⼀次的初始化操作等场景。

# 四、HTTP部分
## 1. 常⻅状态码
- 1xx（信息性状态码）：表示临时响应，⽤来通知客户端请求的第⼀部分已经收到，客户端应继续发送其余部分。不过这类状态码在实际应⽤中较少使⽤。
> 100 Continue：客户端应当继续发送请求。这个临时响应是⽤来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。

- 2xx（成功）表示请求已成功被服务器接收、理解并接受
> 200 OK：请求成功，最常⻅的成功状态码，当客户端请求资源成功时，服务器返回此状态 码。例如，浏览器请求⼀个 HTML ⻚⾯，服务器成功返回⻚⾯内容时，状态码为 200。
> 201 Created：请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴，且其 URI 已经随 Location 头信息返回。
> 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容。常⽤于删除操作成功时。

- 3xx（重定向）表示要完成请求，需要进⼀步操作，通常⽤于重定向
> 301 Moved Permanently：永久重定向，表示请求的资源已永久移动到新的 URL。常⽤于⽹站域名变更或⻚⾯结构调整时，告诉搜索引擎和浏览器该⻚⾯已永久转移到新地址。
> 302 Found：临时重定向，请求的资源临时从不同的 URI 响应请求，但客户端应继续使⽤原有 URI 进⾏以后的请求。
> 304 Not Modified：使用缓存（协商缓存命中），表示资源未被修改，可以使⽤缓存的版本。客户端可以继续使⽤缓存的响应，⽽⽆需再次向服务器请求资源。

- 4xx（客户端错误）表示客户端可能存在错误，妨碍了服务器的处理。
> 400 Bad Request：客户端发送的请求有错误，不能被服务器所识别。例如，请求参数格式错误。
> 401 Unauthorized：请求未经授权，需要进⾏身份验证。通常在访问需要登录的资源时，如果⽤户未登录，会返回此状态码。
> 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执⾏此请求。可能是因为权限不⾜，即使进⾏了身份验证也⽆法访问该资源。
> 404 Not Found：请求的资源不存在，可能是 URI 错误或者资源已被删除。
> 405 Method Not Allowed：客户端请求的⽅法被禁⽌，例如使⽤ POST ⽅法，请求⼀个只⽀持 GET ⽅法的接⼝。
> 429 Too Many Requests：请求太频繁（限流）

- 5xx（服务端错误）表示服务器在处理请求的过程中发⽣了错误。
> 500 Internal Server Error，最常⻅的服务器错误状态码，表明服务器在执⾏请求时发⽣了内部错误，可能是代码逻辑错误、数据库连接问题等。
> 502 Bad Gateway：作为⽹关或者代理⼯作的服务器尝试执⾏请求时，从上游服务器接收到⽆效的响应。
> 503 Service Unavailable：服务器⽬前⽆法使⽤（由于超载或停机维护），通常只是暂时状态。
> 504 Gateway Timeout：⽹关或者代理服务器未能及时从上游服务器收到响应。

- 代码案例（使⽤ Node.js 实现简单的 HTTP 服务器并返回不同状态码）
```javascript
const http = require('http');
const server = http.createServer((req, res) => {
    if (req.url === '/') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Welcome to the home page!');
    } else if (req.url === '/about') {
        res.statusCode = 301;
        res.setHeader('Location', '/new - about');
        res.end();
    } else if (req.url === '/new - about') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('This is the new about page!');
    } else {
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Page not found!');
    }
});

server.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```
- 代码解析：上述代码创建了⼀个简单的 HTTP 服务器，根据不同的请求 URL 返回不同的状态码和响应内容。当请求根路径 / 时，返回状态码 200 和欢迎信息；当请求 /about 时，返回状态码 301 并设置重定向到 /new - about ；当请求 /new - about 时，返回状态码 200 和新的关于⻚⾯信息；当请求其他不存在的路径时，返回状态码 404 和⻚⾯未找到信息。

## 2. 301、302、304
- 301 永久重定向
> 告诉浏览器资源永久移动到新地址
> 浏览器会缓存重定向结果
> SEO 中会将权重转移到新地址

- 302 临时重定向
> 暂时跳到新地址
> 浏览器不会缓存
> 常用于登录跳转、临时调整

- 304 Not Modified
> 协商缓存生效
> 服务器告诉浏览器：你缓存的资源没变
> 浏览器直接读取本地缓存
> 触发条件：If-Modified-Since / If-None-Match

| 状态码 | 场景     | 是否重新下载资源   |
| --- | ------ | ---------- |
| 301 | 永久重定向  | 会          |
| 302 | 临时重定向  | 会          |
| 304 | 协商缓存命中 | **不会**下载资源 |

## 3. 常⻅的请求method
| Method  | 作用         | 是否安全 | 是否幂等 |
| ------- | ---------- | ---- | ---- |
| GET     | 获取数据       | ✔    | ✔    |
| POST    | 创建/提交数据    | ✘    | ✘    |
| PUT     | 更新资源（整体更新） | ✘    | ✔    |
| PATCH   | 局部更新       | ✘    | ✘    |
| DELETE  | 删除资源       | ✘    | ✔    |
| HEAD    | 获取响应头      | ✔    | ✔    |
| OPTIONS | 预检请求       | ✔    | ✔    |

## 4. 跨域问题：浏览器的 同源策略 导致：协议、域名、端口不同即跨域。
**解决跨域的方式**
- 1. 服务端 CORS（最常用）
```java
// 服务器设置：
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Access-Control-Allow-Methods: *
```
- 2. Nginx 反向代理：前端访问同域的 nginx，由 nginx 代理转发。
- 3. JSONP（只支持 GET）
- 4. WebSocket（不受同源策略限制）
- 5. 跨域资源共享 iframe 通信（postMessage）

## 5. session和cookie是如何⼯作的？
- Cookie
> 存储在浏览器
> 会自动随请求携带到同域服务器
> 一般用于：登录状态 token、偏好设置

- Session
> 存储在服务器
> 浏览器通过 cookie 中的 sessionId 来标识用户

- 工作流程：
> 用户第一次访问服务器
> 服务器创建 session，在 server 保存（如内存/Redis）
> 服务端返回 Set-Cookie: sessionId=xxxx
> 浏览器保存 cookie
> 下次请求自动带上 sessionId
> 服务器通过 sessionId 找到当前用户的数据

- 本质：
> Cookie 存 sessionId，Session 存用户数据
> 两者配合实现登录状态。

## 6. CDN
- 作用：
> 加速访问（就近节点返回资源）
> 减少源站压力
> 防止 DDoS
> 资源缓存提升加载速度

## 7. 补充DDos
### 7.1. 什么是 DDoS？
- DDoS（Distributed Denial of Service）分布式拒绝服务攻击，攻击者控制大量肉鸡设备（服务器、主机、IoT 设备等），向目标服务器同时发起大量无意义的请求，占满带宽、耗尽计算资源，使其：
- 无法处理正常请求
- CPU/带宽被打满
- 服务瘫痪、宕机
- 一句话： 用海量流量淹没目标，让它无法提供服务。

### 7.2. 常见 DDoS 攻击类型
- ① 流量型攻击（最常见）用巨量带宽攻击目标，典型如：
  - UDP Flood
  - ICMP Flood（Ping Flood）
  - DNS Amplification（放大攻击）
  - 目标：耗尽网络带宽
-  ② 协议型攻击，利用协议缺陷，占用服务器资源：
  - SYN Flood（半连接攻击）
  - ACK Flood
  - TCP Slowloris
  - 目标：耗尽服务器连接数、CPU
- ③ 应用层攻击，模拟真实请求，但大量消耗后端业务资源：
  - HTTP Flood（模拟真实浏览器访问）
  - CC 攻击
  - 目标：耗尽应用服务器处理能力

### 7.3. DDoS 攻击的特点
> 流量巨大（几十 G、几百 G、甚至 Tb 级别）
> 来源广泛（僵尸网络）
> 难以直接阻断
> 攻击成本低、防护成本高

### 7.4. 如何防御 DDoS？（面试高频）
- ① CDN / 高防节点 / 云清洗
  - CDN 节点分担流量
  - 高防 IP 提供流量清洗
  - 将恶意流量在边缘拦截
- ② 限流、熔断、验证码
  - 限制同一 IP 请求次数
  - 出现异常访问就触发熔断
  - 验证码阻挡自动化请求
-  ③ 防火墙 / WAF
  - 根据规则过滤恶意协议包
  -  阻挡常见攻击（SYN、UDP flood）
- ④ 隔离节点 / 分布式部署
  - 多区域部署，分散攻击压力
- ⑤ 黑洞路由（最后手段）
  - 直接丢弃所有到该 IP 的流量（服务暂时不可用）。
- 一句话总结（面试官爱听版）
  - DDoS 是利用大量设备并发向目标发起无意义请求，耗尽带宽和资源，使服务不可用。
  - 防御主要依赖 CDN + 高防清洗 + 限流 + WAF。

- 用户访问资源 → DNS 将域名解析到 最近的 CDN 节点
- 如果节点有缓存 → 直接返回
- 如果没有 → 回源服务器获取并缓存

- 一句话总结：CDN = 离用户最近的服务器负责返回静态资源。

## 8. 强缓存与协商缓存
- 强缓存（不会发送请求）
```java
// 响应头中包含：
Cache-Control: max-age=3600
Expires: xxx
```
- 效果
  - 在有效期内，浏览器直接读本地缓存
  - 状态码：200（from cache）

- 协商缓存（会发送请求）
```java
// 请求头：
If-Modified-Since
If-None-Match
// 响应头
Last-Modified
ETag
```
- 流程：
  - 浏览器带上条件请求
  - 服务端判断资源是否更新
  - 如果未更新 → 返回 304

- 区别总结
| 类型   | 是否发请求 | 典型状态码           |
| ---- | ----- | --------------- |
| 强缓存  | ❌ 不发  | 200（from cache） |
| 协商缓存 | ✔ 发   | 304             |

## 9. fetch和XMLHttpRequest的区别
### 9.1. API 设计现代
```javascript
// fetch 是 Promise 设计，更简洁：
fetch('/api').then()
// XHR
const xhr = new XMLHttpRequest();
xhr.open();
xhr.send();
```
### 9.2. 默认不带cookie
```javascript
// fetch
fetch(url, { credentials: 'include' })
// XHR同源时，默认带cookie
```
### 9.3. 不支持同步请求：XHR 支持同步（已被废弃），fetch 不支持同步。
### 9.4. 错误处理不同
```javascript
// fetch 只会对网络错误 reject，
// HTTP 错误不会抛错，需要自己判断：
if (!res.ok) { }
```
### 9.5. 支持流（stream）读取:fetch 可以分块读取大文件（如视频）。
- 总结一句话：
| 功能     | fetch       | XHR     |
| ------ | ----------- | ------- |
| 风格     | Promise，更现代 | 回调地狱    |
| Cookie | 默认不带        | 默认带     |
| 同步     | ❌           | ✔（但不推荐） |
| 流式处理   | ✔           | ✘       |
| 兼容性    | 中等          | 极好      |

## 10. http 和 https 的区别？
- HTTP （超⽂本传输协议）是明⽂传输协议，数据在传输过程中容易被截取和篡改，存在安全⻛险。 HTTPS （超⽂本传输安全协议）是在 HTTP 的基础上加⼊了 SSL/TLS 协议进⾏加密，保证了数据传输的安全性。
- 区别分析
  - 安全性：HTTP ：数据以明⽂形式传输，容易被中间⼈窃取和篡改，如⽤户的账号密码、敏感信息等可能会泄露。 HTTPS ：使⽤ SSL/TLS 协议对数据进⾏加密，即使数据被截取，攻击者也⽆法获取其中的敏感信息。
  - 端口号：HTTP ：默认使⽤端⼝号 80。HTTPS ：默认使⽤端⼝号 443。
  - 证书：HTTP ：不需要证书。 HTTPS ：需要向认证机构申请 SSL 证书，⽤于验证服务器的身份和加密数据传输。
- 案例应⽤：在涉及⽤户敏感信息交互的场景，如⽹上银⾏、电⼦商务平台等，必须使⽤ HTTPS 协议来保障⽤户数据的安全。⽽对于⼀些对安全性要求不⾼的静态⻚⾯，如新闻资讯⽹站的部分⻚⾯，可使⽤ HTTP 协议。

## 11.  开发过程中有没有⽤过抓包或者代理⼯具？类似 charles？
- 抓包⼯具（如 Charles、Fiddler 等）和代理⼯具可以拦截、监控和修改⽹络请求和响应。其原理是在客户端和服务器之间充当中间代理，捕获经过的数据，⽅便开发者分析请求和响应的详细信息，如请求头、请求体、响应状态码、响应内容等。
- 使⽤场景及案例：
  - 接⼝调试：在开发前后端分离的项⽬时，通过抓包⼯具可以查看前端发送的请求是否符合预期，后端返回的数据格式和内容是否正确。例如，前端发送⼀个登录请求，通过抓包⼯具可以查看请求的 URL 、请求⽅法、请求参数以及后端返回的状态码和响应数据，帮助定位接⼝调⽤过程中出现的问题。
  - 性能分析：分析请求和响应的时间，找出性能瓶颈。⽐如，查看某个⻚⾯加载时各个请求的耗时情况，判断是哪个请求导致⻚⾯加载缓慢，进⽽进⾏优化。
  - 数据篡改：在测试过程中，可以使⽤抓包⼯具修改请求或响应的数据，模拟不同的场景进⾏测试。例如，修改请求中的参数，测试后端接⼝对异常数据的处理能⼒。

## 12. url 链接每⼀部分代表什么含义
- ⼀个完整的 URL （统⼀资源定位符）由多个部分组成，每个部分都有特定的含义，⽤于定位互联⽹上的资源。
- 示例及各部分含义：
  - 示例 URL ： https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section
  - 协议（Protocol）： https 表示使⽤的是超⽂本传输安全协议，规定了客户端和服务器之间通信的规则和⽅式。 
  - 域名（Domain Name）： www.example.com 是⽹站的域名，⽤于标识服务器 的位置。域名会通过 DNS（域名系统）解析为对应的 IP 地址。 
  - 端⼝号（Port）： 8080 是服务器监听的端⼝号，⽤于区分不同的服务。默认情况下， HTTP 使⽤ 80 端⼝， HTTPS 使⽤ 443 端⼝。 
  - 路径（Path）： /path/to/resource 表示服务器上资源的具体位置，类似于⽂件系统中的⽂件路径。 
  - 查询参数（Query Parameters）： param1=value1&param2=value2 是传递给服务器的额外参数，⽤于向服务器传递数据或进⾏条件筛选等操作。 
  - ⽚段标识符（Fragment Identifier）： #section ⽤于定位⻚⾯内的特定部分，当⻚⾯加载完成后，浏览器会⾃动滚动到该部分。

## 13. 跨域与同源
- 同源策略是浏览器的⼀个重要安全机制，它规定浏览器只允许访问同源（协议、域名、端⼝都相同）的资源。如果⼀个请求的源（协议、域名、端⼝）与当前
  ⻚⾯的源不同，就会产⽣跨域问题。
- 同源示例及⾮同源示例：
  - 同源： ⻚⾯ https://www.example.com/page1.html 和请求https://www.example.com/api/data 是同源的，因为协议都是https ，域名都是 www.example.com ，端⼝默认都是 443。
  - ⾮同源（跨域）： ⻚⾯ https://www.example.com/page1.html 和请求http://anotherdomain.com/api/data 存在跨域问题，因为协议不同 （⼀个是 https ，⼀个是 http ），域名也不同。
- 跨域解决⽅案：
  - JSONP（JSON with Padding）：利⽤ <script> 标签的 src 属性不受同源策略限制的特点，通过动态创建 <script> 标签来实现跨域数据请求。 
  - CORS（跨域资源共享）：是⼀种现代的跨域解决⽅案，服务器端设置响应头（如 Access-Control-Allow-Origin ）来允许特定源的请求访问资源。 
  - 代理服务器：在同源的服务器上设置代理，将客户端的请求转发到⽬标服务器，再将响应返回给客户端。

## 14. http 链接创建的过程
- HTTP 是基于 TCP 协议的应⽤层协议， HTTP 链接的创建依赖于 TCP 连接的建⽴。
- 详细过程：
  - 客户端发起连接请求：客户端（浏览器）根据输⼊的 URL 解析出服务器的 IP地址和端⼝号，然后向服务器发送 TCP 连接请求（SYN 包），该包包含客户端的初始序列号等信息。
  - 服务器响应连接请求：服务器接收到客户端的 SYN 包后，向客户端发送⼀个SYN + ACK 包，表示同意建⽴连接，并包含服务器的初始序列号和对客户端序列号的确认信息。
  - 客户端确认连接：客户端接收到服务器的 SYN + ACK 包后，向服务器发送⼀个ACK 包，表示确认连接。⾄此， TCP 连接建⽴完成。
  - 发送 HTTP 请求：在 TCP 连接建⽴后，客户端向服务器发送 HTTP 请求，包括请求⾏、请求头和请求体（如果有）。
  - 服务器处理请求并返回响应：服务器接收到 HTTP 请求后，进⾏相应的处理，然后返回 HTTP 响应，包括响应⾏、响应头和响应体。
  - 关闭连接：当请求和响应完成后，客户端和服务器可以选择关闭 TCP 连接，通过四次挥⼿的过程释放连接资源。

## 15. ⻓链接和短链接的区别是什么
- ⻓链接和短链接是指客户端和服务器之间连接的保持⽅式，主要区别在于连接的持续时间和使⽤场景。区别分析如下：
- 连接持续时间：
  - 短链接：每次请求时建⽴连接，请求完成后⽴即关闭连接。例如，在传统的 HTTP 1.0 协议中，每个请求都需要重新建⽴ TCP 连接，请求结束后连接关闭。
  - ⻓链接：在⼀次连接建⽴后，会保持⼀段时间不关闭，客户端和服务器可以在这个连接上多次发送请求和响应。例如，在 HTTP 1.1 及以后的版本中，默认⽀持⻓连接（ Connection: keep - alive ）。
- 性能开销：
  - 短链接：每次建⽴和关闭连接都需要⼀定的时间和资源开销，如 TCP 连接的三次握⼿和四次挥⼿过程。在频繁请求的场景下，会增加性能开销。
  - ⻓链接：避免了频繁建⽴和关闭连接的开销，提⾼了性能。但⻓连接会占⽤服务器的资源，如果⻓时间不使⽤，也需要进⾏管理和清理。
- 使⽤场景：
  - 短链接：适⽤于请求频率较低、对连接实时性要求不⾼的场景，如静态⻚⾯的请求。 
  - ⻓链接：适⽤于需要频繁交互、对实时性要求较⾼的场景，如即时通讯、游戏服务器等。

## 16. 浏览器从输⼊⽹址到⻚⾯呈现发⽣了什么？
- 1. 用户输入 URL / 按回车：浏览器拿到一个字符串（例如 https://example.com/path），开始解析成各部分（协议、主机、端口、路径、查询、fragment）。
- 2. 存 / 预连接：浏览器会先查本地缓存（DNS 缓存、HTTP 缓存、HSTS、Service Worker、connection pool）。如果资源可用且命中强缓存，可能直接从本地返回并跳过网络请求。
- 3. DNS 解析（把域名解析为 IP）
> 浏览器先查本地 DNS 缓存 → OS 缓存 → hosts 文件 → 发起 DNS 请求到 DNS 服务器。
> 这一步可能被 CDN 或 DNS 负载均衡影响（返回最近节点 IP）。
> （优化点：DNS 缓存、DNS over HTTPS、prefetch）

- 4. 建立 TCP 连接（如果没有现成连接）
> 三次握手：SYN → SYN-ACK → ACK。
> HTTP/1.1 + keep-alive 会复用连接；HTTP/2 在一个连接上多路复用多个请求。

- 5. TLS 握手（如果是 HTTPS）
> 客户端/服务器协商加密算法、交换证书、验证证书、生成对称密钥（包括可能的会话复用 / 0-RTT 优化）。
> TLS 完成后数据加密传输。
> （优化点：TLS session resumption、OCSP stapling、HTTP/2、QUIC/HTTP3）

- 6. 发起 HTTP 请求：浏览器发送 HTTP 请求（包含 headers：Host、User-Agent、Accept、Cookie、If-Modified-Since/If-None-Match 等）。如果有 Service Worker，Service Worker 可以拦截请求并返回响应（缓存或自定义响应）。
- 7. 服务器处理并返回响应：服务器接收请求，处理（路由、后端逻辑、读取 DB、调用微服务等），返回响应头和响应体（HTML、或 301/302 重定向等）。（CDN、高防或缓存层可在此处命中并直接返回缓存内容）
- 8. 浏览器开始接收字节 —— HTML 开始解析（关键渲染路径开始）
> 当浏览器接收到 HTML 字节流时，会 边下载边解析（streaming parsing）：
> a. HTML 解析器：生成 Token → 构建 DOM 树（DOM）
> 浏览器把 HTML token 化，生成 DOM 节点并链接成 DOM 树。
> b. CSS 解析：下载 CSS（遇到 <link>）并构建 CSSOM（CSS Object Model）
> 遇到外部 CSS，会触发额外的请求（可并行下载）。CSSOM 与 DOM 共同用于后续渲染树构建。
> c. JavaScript 的影响（关键）
> 同步阻塞脚本（普通 <script>）：解析到 <script> 会暂停 HTML 解析 —— 浏览器必须先下载并执行脚本，脚本可能修改 DOM/CSSOM，因此解析被阻塞。
> defer：脚本并行下载，但在 HTML 解析完成后按顺序执行（不会阻塞解析）。
> async：并行下载，下载完成就执行（可能在解析中断），执行顺序不保证。
> 动态创建 <script>（appendChild）：默认 async 行为（不会阻塞）。
> Service Worker 可以拦截并直接提供内容，影响是否请求网络。
> （重点：JS 能修改 DOM/CSSOM，因此会阻塞渲染）

- 9. 构建 Render Tree（渲染树）：浏览器把 DOM 和 CSSOM 合并，构建 Render Tree（渲染树）：只包含需要被绘制的可见节点（例如 display:none 会被忽略），并计算每个节点的样式（resolved style）。
- 10. 布局（Reflow / Layout）：浏览器根据渲染树计算每个可见节点的几何尺寸和位置（即各元素的宽高、x/y）。这是一个代价较高的过程。（触发重排的操作：改 width/height、添加/移除 DOM、改变字体、改变 box-model 等）
- 11. 绘制（Paint）：将布局好的每个节点绘制成图层中的绘制命令（绘制文本、颜色、边框、阴影、图片等）。这一步称为 paint。
- 12. 合成（Compositing）现代浏览器会把页面拆成多个图层（layer），并交给 GPU 合成（特别是使用 transform, opacity, will-change 等会创建图层的属性）。合成阶段把图层合并到最终帧并呈现到屏幕。（涉及 GPU rasterization、合成顺序优化、图层缓存）
- 13. 首次绘制指标（可观测点）
> 浏览器在这过程中会记录关键性能指标（供 DevTools / 报表使用）：
> > FP（First Paint）：浏览器开始绘制的时间点。
> > FCP（First Contentful Paint）：首次绘制任何有意义内容（文本、图片等）。
> > LCP（Largest Contentful Paint）：最大可视内容绘制完成时间（用户感知重要指标）。
> > DOMContentLoaded：DOM 构建完成并解析完所有脚本（不等待样式/图片）。
> > load：页面所有资源（包括图片、iframe）加载完成。

- 14. JavaScript 执行与事件循环
> 页面渲染与 JS 执行并行但又相互影响：
> > 主线程负责解析 HTML/CSS、执行 JS、布局和绘制。长时间 JS 会阻塞渲染。
> > JS 的执行遵循事件循环（macrotasks、microtasks）。微任务（Promise.then）会在当前 macrotask 完结前执行，可能导致长时间锁主线程。
> > （优化点：避免主线程长任务、使用 Web Worker 做计算密集型任务）

- 15. 后续资源加载与渲染更新：图片、字体、视频等资源可能在初次布局后异步加载并触发 repaint 或 reflow（例如图片加载改变元素尺寸会触发 reflow）。浏览器会增量地重绘或合成受影响区域。
- 16. 浏览器缓存与条件请求：在后续访问中，浏览器会使用缓存策略（强缓存 / 协商缓存）。若使用协商缓存，会发送 If-Modified-Since / If-None-Match，服务端可返回 304 以节省带宽。
- 17. 交互阶段与生命周期事件
> DOMContentLoaded：DOM 构建完（同步脚本已执行完）。
> load：所有资源加载完。
> 可以监听 requestAnimationFrame 做动画，在下一帧渲染前执行回调。

- 额外补充：常见优化点（面试高频）
> 减少阻塞资源：把脚本放底部 / 使用 defer / async。
> Critical CSS：内联关键 CSS，延迟非关键 CSS。
> 预加载/预取：<link rel="preload">、prefetch、preconnect。
> 使用 CDN、启用 gzip/brotli、HTTP/2 或 HTTP/3（QUIC）。
> 开启缓存策略、合理使用 ETag/Last-Modified。
> 减少重排/重绘：合并 DOM 操作、使用 transform 代替 top/left、避免频繁读写 layout 属性。
> 使用 Service Worker 做离线缓存与路由拦截。
> 避免主线程阻塞：分割任务、使用 Web Worker。
> 按需创建合成图层，避免过多图层占用 GPU 内存。

- 短答题模版（面试时可念）
> “用户输入 URL 后，浏览器先做 DNS 解析、建立 TCP/TLS 连接，然后发 HTTP 请求。服务器返回 HTML，浏览器边下载边解析：构建 DOM、下载并解析 CSS（生成 CSSOM）、执行阻塞或非阻塞的 JS（影响解析），将 DOM+CSSOM 合并成渲染树，进行布局（reflow）、绘制（paint）、合成（composite）并把帧交给 GPU 呈现。期间还涉及缓存、CDN、Service Worker、HTTP/2 多路复用等优化点，最终触发 DOMContentLoaded/load 等事件。”

## 17. 浏览器的组成
- 现代浏览器主要由多个组件组成，每个组件负责不同的功能，协同⼯作以实现⽹⻚的加载和渲染等功能。
- 主要组件：
  - ⽤户界⾯：包括地址栏、书签栏、标签⻚等，⽤于⽤户与浏览器进⾏交互。 
  - 浏览器引擎：负责协调和管理其他组件的⼯作，如解析 HTML、CSS 等资源，将渲染结果传递给渲染引擎。
  - 渲染引擎：负责解析 HTML 和 CSS，构建 DOM 树和 CSSOM 树，合并为渲染树，进⾏布局和绘制，将⻚⾯内容显示在屏幕上。不同的浏览器使⽤不同的渲染引擎，如 Chrome 使⽤ Blink 引擎，Firefox 使⽤ Gecko 引擎。
  - ⽹络模块：负责处理⽹络请求和响应，包括 DNS 解析、TCP 连接建⽴、HTTP请求发送和响应接收等。
  - JavaScript 引擎：负责执⾏ JavaScript 代码，如 Chrome 的 V8 引擎。它将JavaScript 代码编译为机器码，提⾼执⾏效率。 
  - 数据存储模块：负责管理浏览器的本地存储，如localStorage、 sessionStorage、 IndexedDB 等，⽤于保存⽤户的浏览数据、缓存等。 
  - 安全模块：负责保障浏览器的安全，如防⽌跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，对⽹⻚的内容和请求进⾏安全检查。
- 应用场景
  - ⽤户界⾯：⽅便⽤户输⼊ URL、管理书签、切换标签⻚等操作，提供良好的⽤户体验。 
  - 渲染引擎：确保⽹⻚能够正确地解析和显示，处理不同的 HTML 和 CSS 标准。 
  - ⽹络模块：实现⽹⻚资源的下载和更新，保证数据的传输稳定和⾼效。 
  - JavaScript 引擎：⽀持⽹⻚中的动态交互和复杂功能，如表单验证、动画效果等。 
  - 数据存储模块：⽤于保存⽤户的登录状态、个性化设置、离线缓存等信息，提⾼⽤户的使⽤便利性。 
  - 安全模块：保护⽤户的隐私和数据安全，防⽌恶意⽹站的攻击。
- 代码案例
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Storage Example</title>
</head>
<body>
<input type="text" id="inputText">
<button id="saveButton">Save to Local Storage</button>
<button id="loadButton">Load from Local Storage</button>
<p id="output"></p>
<script>
    const input = document.getElementById('inputText');
    const saveButton = document.getElementById('saveButton');
    const loadButton= document.getElementById('loadButton');
    const output = document.getElementById('output');
    saveButton.addEventListener('click', function () {
        const text = input.value;
        localStorage.setItem('savedText', text);
        output.textContent = 'Text saved to local storage.';
    });
    loadButton.addEventListener('click', function () {
        const savedText = localStorage.getItem('savedText');
        if (savedText) {
            output.textContent = 'Loaded text: ' + savedText;
        } else {
            output.textContent = 'No text found in local storage.';
        }
    });
</script>
</body>
</html>
```
- 代码解析：此代码示例主要展示了浏览器数据存储模块中 localStorage 的使⽤。具体如下：
  - ⾸先通过 document.getElementById 获取输⼊框、保存按钮、加载按钮和⽤于显示输出信息的段落元素。 
  - 给保存按钮添加点击事件监听器，当点击保存按钮时，获取输⼊框中的⽂本内容，使⽤ localStorage.setItem ⽅法将⽂本保存到 localStorage 中，并在输出段 落显示保存成功的信息。 
  - 给加载按钮添加点击事件监听器，当点击加载按钮时，使⽤localStorage.getItem ⽅法从 localStorage 中获取之前保存的⽂本。如果能获取到⽂本，则在输出段落显示加载的⽂本；如果没有找到保存的⽂本，则显示相应提示信息。这体现了浏览器数据存储模块对⽤户数据的存储和读取功能，⽅便在不同⻚⾯或会话间保留⽤户输⼊的信息。

## 18. DOM BOM 和 BOM 的 API
-  DOM （⽂档对象模型）和 BOM （浏览器对象模型）是浏览器编程中的重要概念。
  - DOM：是 HTML ⽂档的树形结构表示，将 HTML ⽂档解析为⼀个由节点组成的树，每个节点可以是元素节点、⽂本节点等。通过 DOM ，可以使⽤ JavaScript 动态地操作 HTML ⽂档的内容、结构和样式。
  - BOM：是浏览器窗⼝的对象模型，提供了与浏览器窗⼝相关的操作接⼝，如窗⼝⼤⼩调整、导航、弹出对话框等。
- DOM API：
  - document.getElementById() ：通过元素的 id 属性获取元素节点。
  - document.createElement() ：创建⼀个新的元素节点。
  - element.appendChild() ：将⼀个节点添加为另⼀个节点的⼦节点。
  - element.style ：⽤于操作元素的样式。
- BOM API：
  - window.alert() ：弹出⼀个警告对话框。
  - window.location ：⽤于获取和设置当前⻚⾯的 URL 。
  - window.history ：⽤于操作浏览器的历史记录，如前进、后退等。
  - window.innerWidth 和 window.innerHeight ：获取浏览器窗⼝的内部宽度和⾼度。

## 19. websocket 通信原理
- WebSocket 是⼀种在单个 TCP 连接上进⾏全双⼯通信的协议，它允许浏览器和服务器之间进⾏实时通信。
- 通信过程：
  - 握⼿阶段：客户端向服务器发送⼀个 HTTP 请求，请求头中包含 Upgrade:websocket 和 Connection: Upgrade 等信息，表示要升级为 WebSocket 连接。服务器收到请求后，如果⽀持 WebSocket 协议，会返回⼀个状态码为101 的响应，表示同意升级连接。
  - 建⽴连接：握⼿成功后， TCP 连接保持打开，客户端和服务器可以在这个连接上进⾏双向通信。
  - 数据传输：客户端和服务器可以随时向对⽅发送数据，数据以帧的形式传输。 WebSocket 协议定义了不同类型的帧，如⽂本帧、⼆进制帧等。
  - 关闭连接：当⼀⽅需要关闭连接时，会发送⼀个关闭帧给对⽅。对⽅收到关闭帧后，会发送⼀个确认关闭帧，然后双⽅关闭 TCP 连接。
- 代码案例
```javascript
// 服务器端（使⽤ Node.js 的 ws 库）：
const WebSocket = require('ws'); 
const wss = new WebSocket.Server({ port: 8080 }); 
wss.on('connection', function connection(ws) {
    ws.on('message', function incoming(message) {
        console.log('received: %s', message);
        ws.send('Server received: ' + message);
    });
});
```
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Example</title>
</head>
<body>
<button id="sendButton">Send Message</button>
<script>
    const socket = new WebSocket('ws://localhost:8080');
    socket.onopen = function () {console.log('Connected to the server')}
    socket.onmessage = function (event) {console.log('Received from server: ', event.data)}
    socket.onclose = function () {console.log('Disconnected from the server')}
    const sendButton = document.getElementById('sendButton');
    sendButton.addEventListener('click', function () {socket.send('Hello, server!')})
</script>
</body>
</html>
```
- 代码细节：
  - 服务器端使⽤ ws 库创建⼀个 WebSocket 服务器，监听 8080 端⼝。当有客户端连接时，监听客户端发送的消息，并将消息原样返回给客户端。 
  - 客户端使⽤ WebSocket 构造函数创建⼀个 WebSocket 实例，连接到服务器。监听 open、 message 和 close 事件，分别处理连接建⽴、接收消息 和连接关闭的情况。点击按钮时，向服务器发送消息。
- 案例应⽤：WebSocket 适⽤于需要实时通信的场景，如在线聊天、实时数据展示（股票⾏情、实时监控等）、多⼈游戏等。

# 五、Web安全
## 1. SQL注⼊（SQL Injection）
- 攻击者通过在表单输⼊或 URL 参数中注⼊恶意的 SQL 语句，试图绕过应⽤程序的验证机制，从⽽执⾏⾮法的数据库操作，如获取、修改或删除数据库中的数据。最终可能会导致：
> 数据泄露
> 数据篡改
> 数据删除
> 获取 root 权限

- 例子（典型注入）：
```sql
SELECT * FROM users WHERE username = '${input}'
```
- 攻击输入：
```vbnet
' OR 1=1 --
```
- 执行结果变成
```sql
SELECT * FROM users WHERE username = '' OR 1=1 --'
```
- 如何防御？
  - 前端输⼊验证：在前端对⽤户输⼊进⾏初步验证，限制输⼊的⻓度和格式，防⽌⽤户输⼊恶意的 SQL 语句。但前端验证不能作为唯⼀的安全措施，因为可以被绕过，主要起到提示⽤户的作⽤。
  - 后端严格处理：后端使⽤参数化查询或预编译语句来处理⽤户输⼊，避免将⽤户输⼊直接拼接到 SQL 语句中，从⽽防⽌ SQL 注⼊攻击。
  - 使用 预编译（Prepared Statement）（最有效）
  ```sql
  SELECT * FROM users WHERE username = ?
  ```
  - 严格参数化查询
  > 框架 ORM（Sequelize、Hibernate）默认支持。

  - 过滤/转义特殊字符
  > 如 ', ", --, ;

  - 最小权限原则
  > 数据库用户只给必须的权限。

  - WAF（Web Application Firewall）
  > 自动拦截恶意 SQL 语句。

## 2. XSS攻击
- 攻击者通过在⽬标⽹站注⼊恶意脚本，当⽤户访问该⽹站时，恶意脚本会在⽤户的浏览器中执⾏，从⽽获取⽤户的敏感信息，如 Cookie、会话令牌等，或者进⾏其他恶意操作，像修改⻚⾯内容、重定向到恶意⽹站等。：
> 盗取 cookie
> 获取用户信息
> 冒充用户操作
> 页面篡改

- XSS 类型
  - 反射型 XSS（最常见）
  > 恶意脚本作为参数被包含在 URL 中，当⽤户访问包含恶意脚本的URL 时，服务器会将该脚本反射到响应⻚⾯中并执⾏。

  - 存储型 XSS（最危险）
  > 攻击者将恶意脚本存储在⽬标⽹站的数据库中，当其他⽤户访问包含该恶意脚本的⻚⾯时，脚本会被执⾏。

  - DOM 型 XSS
  > 基于 DOM 操作的 XSS 攻击，通过修改⻚⾯的 DOM 结构来注⼊恶意脚本，不需要与服务器进⾏交互。

- 防范措施
  - 输⼊验证和过滤：在前端和后端都对⽤户输⼊进⾏严格验证和过滤，只允许合法的字符和格式。可以使⽤正则表达式对输⼊内容进⾏检查。 
  - 输出编码：在渲染⽤户输⼊的内容时，对特殊字符进⾏ HTML 转义，将其转换为HTML 实体，防⽌恶意脚本的执⾏。例如，将 < 转换为 &lt; ， > 转换为 &gt; 。可以使⽤库如 DOMPurify 来进⾏ HTML 净化。 
  - 设置 CSP（内容安全策略）：通过设置 CSP 响应头，限制⻚⾯可以加载的资源和执⾏的脚本来源，只允许从指定的域名加载脚本，从⽽防⽌恶意脚本的注⼊。

## 3. 请求伪造（CSRF / XSRF）
- 攻击者诱导⽤户在已登录的⽹站上执⾏恶意操作，利⽤⽤户的身份信息完成⾮法请求。攻击者通常会构造⼀个恶意链接或表单，当⽤户在已登录的⽹站上点击该链接或提交表单时，会⾃动向该⽹站发送⼀个伪造的请求。
> 比如：转账、修改密码。
> 核心点：CSRF 利用了浏览器会自动携带 Cookie 的机制。

- 防范措施
  - 使⽤ CSRF 令牌：在表单提交或 AJAX 请求中添加 CSRF 令牌，服务器在处理请求时验证令牌的有效性。可以在表单中隐藏⼀个包含 CSRF 令牌的字段，或者在请求头中添加令牌信息。 
  - SameSite 属性：设置 Cookie 的 SameSite 属性，限制 Cookie 的跨站发送。 SameSite 属性有三个值： Strict 、 Lax 和 None 。 Strict 表示 Cookie只能在同站请求中发送， Lax 表示在⼀些安全的跨站请求中可以发送， None 表示允许跨站发送，但需要同时设置 Secure 属性。 
  - 验证请求来源：服务器端验证请求的来源，检查请求的 Referer 或 Origin 头信息，确保请求来⾃合法的域名。

## 4. 点击劫持
- 攻击者通过创建⼀个透明的、不可⻅的 iframe，将⽬标⽹站嵌⼊其中，并在其上覆盖⼀个诱导⽤户点击的按钮或链接。当⽤户点击表⾯的按钮或链接时，实际上点击的是iframe 中的⽬标⽹站的某个操作，从⽽在⽤户不知情的情况下完成恶意操作。
- 防范措施
  - 设置 HTTP 响应头：服务器端设置 X - Frame - Options 响应头，限制⻚⾯是否可以被其他⽹站通过 iframe 嵌⼊。该响应头有三个值： DENY 表示⻚⾯不能被任何⽹站嵌⼊， SAMEORIGIN 表示⻚⾯只能被同域名的⽹站嵌⼊， ALLOW - FROM uri表示⻚⾯只能被指定的域名嵌⼊。 
  - 使⽤ JavaScript 检测：在⻚⾯中使⽤ JavaScript 检测⻚⾯是否被嵌⼊到 iframe中，如果是则进⾏相应的处理，如跳转到正常⻚⾯或显示警告信息。

## 5. 不安全的第三方库引入
- 在项⽬中引⼊不安全的第三⽅库，这些库可能存在安全漏洞，攻击者可以利⽤这些漏洞对项⽬进⾏攻击，获取⽤户信息或破坏系统。
- 防范措施
  - 选择可靠的第三⽅库：从官⽅渠道或知名的开源社区获取第三⽅库，选择维护活跃、⼝碑良好的库。 
  - 及时更新库版本：关注第三⽅库的更新信息，及时更新到最新版本，以修复已知的安全漏洞。
  - 安全审查：在引⼊新的第三⽅库之前，对其进⾏安全审查，检查是否存在已知的安全问题。

## 4. jwt（JSON Web Token）
- 一种前后端分离中常用的 无状态身份认证方式。
- JWT 由三部分组成（用点分隔）：
```css
header.payload.signature
```
- ① Header（头部）声明算法：
```json
{ "alg": "HS256", "typ": "JWT" }
```
- ② Payload（负载）:存用户信息、过期时间：
```json
{ "userId": 1, "exp": 1700000000 }
```
- ③ Signature（签名）使用密钥生成，防篡改：
```scss
HMACSHA256(header + payload, secret)
```
- JWT工作流程
  - 用户登录成功，服务器生成 JWT 返回给前端
  - 前端保存 JWT（localStorage / cookie）
  - 后续请求在 Header 中携带：Authorization: Bearer \<token>
  - 服务器验证签名 → 解析用户信息
  - 不需要 Session，不维护服务端状态（无状态）
- JWT的优点
  - 无状态，后端不需要存储 session（适合分布式）
  - 前后端分离非常方便
  - 可以跨服务验证（微服务常用）
- JWT的缺点
  - 不能主动失效（除非维护黑名单）
  - token 一旦泄露，风险极高
  - 不适合存放敏感信息（payload 只是 Base64，不加密）
  - 较大（比 sessionId 更占带宽）
- JWT 的安全性注意事项
  - ✔ 设置 短过期时间
  - ✔ 搭配 Refresh Token
  - ✔ 使用 HTTPS
  - ✔ 不要把 JWT 放在 localStorage（容易被 XSS 偷走）
  - ✔ 可以放在 HttpOnly Cookie 中提高安全性

## 5. 加密的具体过程 、ssl 加密的细节 、 http2.0
- SSL/TLS 加密过程：
  - 客户端发起握⼿请求：客户端向服务器发送 ClientHello 消息，包含客户端⽀持的 SSL/TLS 版本、加密算法列表、随机数等信息。 
  - 服务器响应握⼿请求：服务器收到 ClientHello 消息后，发送ServerHello 消息，选择⼀个 SSL/TLS 版本和加密算法，并发送服务器的证书和另⼀个随机数。
  - 客户端验证证书：客户端验证服务器证书的有效性，包括证书的颁发机构、有效期等。如果证书有效，客户端会⽣成⼀个会话密钥，使⽤服务器证书中的公钥进⾏加密后发送给服务器。
  - 服务器解密会话密钥：服务器使⽤⾃⼰的私钥解密客户端发送的会话密钥。
  - 建⽴安全连接：客户端和服务器使⽤会话密钥进⾏对称加密通信，后续的请求和响应都使⽤该密钥进⾏加密和解密。
- HTTP/2.0 特性：
  - ⼆进制分帧： HTTP/2.0 将请求和响应数据分割成⼆进制帧，提⾼了传输效率。 
  - 多路复⽤：允许在⼀个连接上同时发送多个请求和响应，避免了 HTTP 1.x 中的队头阻塞问题。
  - 头部压缩：使⽤ HPACK 算法对请求和响应的头部进⾏压缩，减少了头部数据的传输量。
  - 服务器推送：服务器可以主动向客户端推送资源，提前将客户端可能需要的资源发送给客户端，提⾼⻚⾯加载速度。

## 6. JSONP 和 Cors 为什么可以解决同源问题
- JSONP（JSON with Padding）：
  - JSONP 利⽤了 <script> 标签的 src 属性不受同源策略限制的特点。前端⻚⾯动态创建 <script> 标签，将请求的 URL 作为 src 属性的值，并在 URL 中添加⼀个回调函数名作为参数。服务器收到请求后，将数据包装在回调函数中返回给客户端。客户端的 <script> 标签加载该响应后，会执⾏回调函数，从⽽获取到服务器返回的数据。
  - 解决同源问题的原因：由于 <script> 标签的 src 属性可以跨域请求资源，所以通过这种⽅式绕过了浏览器的同源策略限制。
- CORS（跨域资源共享）：
  - CORS 是⼀种现代的跨域解决⽅案，基于 HTTP 协议，通过服务器端设置响应头来允许特定源的请求访问资源。当客户端发起跨域请求时，浏览器会⾃动在请求头中添加 Origin 字段，标识请求的源。服务器收到请求后，检查Origin 字段，如果该源在允许的范围内，会在响应头中添加相应的跨域允许 信息（如 Access - Control - Allow - Origin ），浏览器根据这些信息判断是否允许该跨域请求。 
  - 解决同源问题的原因：通过服务器端的配置，明确允许哪些源可以访问资源，从⽽在保证安全的前提下解决了跨域问题。

## 7. 浏览器发请求时有个 options 请求，做什么的（跨域的预检请求）
- 当浏览器发起跨域请求时，如果请求是复杂请求（如使⽤ PUT 、 DELETE等⾮简单请求⽅法，或者包含⾃定义请求头、 Content - Type 不是简单类型等），浏览器会先发送⼀个 OPTIONS 请求，称为预检请求。
- 预检请求的作⽤：
  - 检查服务器⽀持情况：通过 OPTIONS 请求，浏览器询问服务器是否⽀持当前请求的⽅法、请求头和源。服务器会在响应头中返回允许的请求⽅法（如 Access - Control - Allow - Methods ）、允许的请求头（如 Access - Control - Allow - Headers ）和允许的源（如 Access - Control - Allow Origin ）等信息。 
  - 避免不必要的跨域请求：如果服务器不⽀持当前请求的⽅法、请求头或源，浏览器就不会发送真正的请求，从⽽避免了不必要的跨域请求和潜在的安全⻛ 险。

# 六、算法
## 1. 红绿灯
```javascript
function trafficLight() {
  const light = async (color, duration) => {
    console.log(color);
    await new Promise(resolve => setTimeout(resolve, duration));
  };
  
  const run = async () => {
    while (true) {
      await light('红灯', 3000);
      await light('绿灯', 2000);
      await light('黄灯', 1000);
    }
  };
  run();
}
```

## 2. 暂停函数
```javascript
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function run() {
  console.log(1);
  await sleep(1000);
  console.log(2);
}

```

## 3. 实现forEach
```javascript
Array.prototype.myForEach = function(callback, thisArg) {
  for (let i = 0; i < this.length; i++) {
    callback.call(thisArg, this[i], i, this);
  }
};
// 补
Array.prototype.myForEach = function (cb, arg) {
    if (this === null || this === undefined) {
        throw new TypeError('Array.prototype.myForEach called on null or undefined');
    }
    if (typeof cb!== 'function') {
        throw new TypeError(`${cb} is not a function`);
    }
    let arr = Object(this);
    let len = arr.length >>> 0; //>>>确保数组⻓度是⼩于32位的整数
    for (let i = 0; i < len; i++) {
        if (i in arr) { //处理稀疏数组 跳过空值
            cb.call(arg, arr[i], i, arr);
        }
    }
};
```

## 4. 千位分隔符
```javascript
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
// 或者
function formatNumber(num) {
    return num.toLocaleString();
}
```

## 5. 扁平化数组
```javascript
// 方法1: 递归
function flatten(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
}
// 方法2: flat
const flatten = arr => arr.flat(Infinity);// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```

## 6. 斐波那契数列
```javascript
// 递归
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
// 动态规划（更优）
function fib(n) {
  if (n <= 1) return n;
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
```

## 7. 分块数组
```javascript
function chunk(arr, size) {
  const result = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}
```

## 8. 数组分组
```javascript
function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const group = typeof key === 'function' ? key(item) : item[key];
    (acc[group] = acc[group] || []).push(item);
    return acc;
  }, {});
}
```

## 9. compose 复合函数
```javascript
// 从右到左执行
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 从左到右执行（pipe）
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
```

## 10. 根据id 合并2个数组
```javascript
function mergeById(arr1, arr2) {
  const map = new Map(arr1.map(item => [item.id, item]));
  arr2.forEach(item => {
    if (map.has(item.id)) {
      Object.assign(map.get(item.id), item);
    } else {
      map.set(item.id, item);
    }
  });
  return Array.from(map.values());
}
```

## 11. 归约reduce
```javascript
Array.prototype.myReduce = function(callback, initialValue) {
  let acc = initialValue !== undefined ? initialValue : this[0];
  let startIndex = initialValue !== undefined ? 0 : 1;
  
  for (let i = startIndex; i < this.length; i++) {
    acc = callback(acc, this[i], i, this);
  }
  return acc;
};
```

## 12. 记忆函数
```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}
```

## 13. 精简对象（移除假值）
```javascript
function compact(obj) {
  const result = {};
  for (let key in obj) {
    if (obj[key]) result[key] = obj[key];
  }
  return result;
}
```

## 14. 实现map
```javascript
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback.call(thisArg, this[i], i, this));
  }
  return result;
};
```

## 15. ⼿动实现 call
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};
```

## 16. 数组出现2次的数字（找重复项）
```javascript
function findDuplicates(arr) {
  const count = {};
  return arr.filter(item => {
    count[item] = (count[item] || 0) + 1;
    return count[item] === 2;
  });
}
```

## 17. 数组去重
```javascript
// 方法1: Set
const unique = arr => [...new Set(arr)];

// 方法2: filter
const unique = arr => arr.filter((item, index) => arr.indexOf(item) === index);
```

## 18. 蜗⽜排序（螺旋矩阵）
```javascript
// 输出 n×n 的螺旋矩阵：
function snail(n) {
  const res = Array.from({ length: n }, () => Array(n).fill(0));
  let num = 1, left = 0, right = n-1, top = 0, bottom = n-1;

  while (left <= right && top <= bottom) {
    for (let i = left; i <= right; i++) res[top][i] = num++;
    top++;
    for (let i = top; i <= bottom; i++) res[i][right] = num++;
    right--;
    for (let i = right; i >= left; i--) res[bottom][i] = num++;
    bottom--;
    for (let i = bottom; i >= top; i--) res[i][left] = num++;
    left++;
  }

  return res;
}

```

## 19. 冒泡排序
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

## 20. 原型链继承
```javascript
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype); // 继承方法
Child.prototype.constructor = Child;
```

## 21. deepClone 深拷⻉
```javascript
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (map.has(obj)) return map.get(obj); // 处理循环引用
  
  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  return clone;
}
```

## 22. promise.all()
```javascript
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('参数必须是数组'));
    }
    
    const results = [];
    let count = 0;
    
    if (promises.length === 0) return resolve(results);
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        count++;
        if (count === promises.length) resolve(results);
      }).catch(reject);
    });
  });
};
```

## 23. 数组去重(有排序)：
```javascript
unique(arr, key)
{
  if (!arr) return arr
  if (key === undefined) return [...new Set(arr)]
  const map = {
    'string': e => e[key],
    'function': e => key(e),
  }
  const fn = map[typeof key]
  const obj = arr.reduce((o,e) => (o[fn(e)]=e, o), {})
  return Object.values(obj)
}
```

## 24. 数组元素偏移
- 实现数组元素偏移可以通过将数组的后 k 个元素移动到数组的前⾯。可以使⽤三次反转数组的⽅法来实现，先反转整个数组，再反转前 k 个元素，最后反转剩下的元素。
```javascript
function rotate(nums, k) {
    const n = nums.length;
    k = k % n
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
    [nums[start], nums[end]] = [nums[end], nums[start]];
    start++;
    end--;
}}

function rotate(nums, k) {
    const n = nums.length;
    k = k % n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
    return nums;
}
function reverse(nums, start, end) {
    while (start < end) {
        [nums[start], nums[end]] = [nums[end], nums[start]];
        start++;
        end--;
    }
}
const nums = [1, 2, 3, 4, 5, 6, 7];
const k = 3;
const rotatedNums = rotate(nums, k);
console.log(rotatedNums); // 输出: [5, 6, 7, 1, 2, 3, 4]
```
- 代码细节
  - ⾸先计算 k 对数组⻓度 n 取模，避免 k ⼤于数组⻓度的情况。 
  - 第⼀次调⽤ reverse 函数反转整个数组。 
  - 第⼆次调⽤ reverse 函数反转数组的前 k 个元素。 
  - 第三次调⽤ reverse 函数反转数组中剩余的元素。 
- 案例应⽤：在处理循环数组、周期性数据等场景中会⽤到，⽐如实现⼀个时钟表盘上数字的循环滚动效果。

## 25. 数组拉平（flatten）
- 数组拉平是将嵌套数组转换为⼀维数组。可以使⽤递归的⽅式遍历数组，若元素是数组则继续递归处理，若元素是基本类型则添加到结果数组中。
```javascript
function flatten(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
            result.push(...flatten(arr[i]));
        } else {
            result.push(arr[i]);
        }
    }
    return result;
}
const nestedArray = [1, [2, [3, 4], 5], 6];
const flattenedArray = flatten(nestedArray);
console.log(flattenedArray); // 输出: [1, 2, 3, 4, 5, 6]
```
- 代码细节：
  - 创建⼀个空数组 result ⽤于存储拉平后的元素。
  - 遍历输⼊数组 arr ，若元素是数组，则递归调⽤ flatten 函数并将结果展开添加到 result 中；若元素不是数组，则直接添加到 result 中。
- 案例应⽤：在处理树形结构数据、多维矩阵转换等场景中会⽤到，⽐如将⼀个多级菜单的数据结构转换为⼀维列表。

## 26. lc1026 ⼆叉树最⼤差值
- 题⽬描述：给定⼆叉树的根节点 root ，找出存在于不同节点 A 和 B 之间的最⼤值 V ，其中 V = |A.val - B.val| ，且 A 是 B 的祖先。
- 原理：可以使⽤深度优先搜索（DFS）遍历⼆叉树，在遍历过程中记录从根节点到当前节点路径上的最⼤值和最⼩值，然后计算当前节点值与最⼤值、最⼩值的差值，更新最⼤差值。
```javascript
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
function maxAncestorDiff(root) {
    let maxDiff = 0; 
    function dfs(node, minVal, maxVal) {
        if (!node) return;
        // 更新最⼤差值
        maxDiff = Math.max(maxDiff, Math.abs(node.val - minVal),Math.abs(node.val - maxVal));
        // 更新路径上的最⼤值和最⼩值
        minVal= Math.min(minVal, node.val);
        maxVal= Math.max(maxVal, node.val);
        // 递归遍历左⼦树和右⼦树
        dfs(node.left, minVal, maxVal);
        dfs(node.right, minVal, maxVal);
    }
    dfs(root, root.val, root.val);
    return maxDiff;
}
// 构建⼆叉树示例
const root = new TreeNode(8);
root.left = new TreeNode(3);
root.right = new TreeNode(10);
root.left.left = new TreeNode(1);
root.left.right = new TreeNode(6);
root.left.right.left = new TreeNode(4);
root.left.right.right = new TreeNode(7);
root.right.right = new TreeNode(14);
root.right.right.left = new TreeNode(13);
const result = maxAncestorDiff(root);
console.log(result);
```
- 代码细节：
  - 定义 TreeNode 类表示⼆叉树节点。 
  - maxAncestorDiff 函数中，使⽤ dfs 函数进⾏深度优先搜索。 dfs 函数接收当前节点、路径上的最⼩值和最⼤值作为参数。 
  - 在 dfs 函数中，计算当前节点值与最⼩值、最⼤值的差值，更新最⼤差值。 然后更新路径上的最⼩值和最⼤值，并递归遍历左⼦树和右⼦树。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是⼆叉树的节点数，需要遍历每个节点⼀次。 
  - 空间复杂度：$O(h)$，其中 $h$ 是⼆叉树的⾼度，递归调⽤栈的深度为树的⾼度。

## 27. 长文章加载优化相关算法实现（预加载、分页并发处理）
- 预加载是在⽤户当前操作之前提前加载可能会⽤到的资源，以提⾼后续操作的响应速度。对于⻓⽂章，可提前加载后续⻚⾯的内容。这⾥我们假设⽂章内容存储在⼀个数组中，每个元素代表⼀⻚的内容。预加载实现思路及代码示例：
```javascript
// 模拟⽂章数据
const articlePages = Array.from({ length: 100 }, (_, i) => `Page ${i +1} content`);
// 预加载函数
function preloadPages(currentPage, preloadCount) {
    const preloadedPages = [];
    for (let i = 1; i <= preloadCount; i++) {
        const nextPageIndex = currentPage + i;
        if (nextPageIndex < articlePages.length) {
            preloadedPages.push(articlePages[nextPageIndex]);
        }
    }
    return preloadedPages;
}
// 当前⻚⾯为第 1 ⻚，预加载 3 ⻚
const currentPage = 1;
const preloadCount = 3;
const preloaded = preloadPages(currentPage - 1, preloadCount);
console.log('Preloaded pages:', preloaded);
```
- 代码细节
  - articlePages 数组模拟了⽂章的所有⻚⾯内容。 
  - preloadPages 函数接收当前⻚⾯索引和预加载的⻚⾯数量作为参数。通过循环，从当前⻚⾯的下⼀⻚开始，将指定数量的⻚⾯内容添加到 
  - preloadedPages 数组中，若超出⽂章总⻚数则停⽌。
- 案例应⽤：在⻓⽂章阅读场景中，当⽤户阅读到当前⻚⾯时，提前加载后续⼏⻚的内容，当⽤户翻⻚时可以⽴即显示，减少等待时间。

- 分⻚并发处理是指同时加载多个⻚⾯的数据，提⾼数据加载的效率。可以使⽤ Promise.all 来实现多个⻚⾯数据的并发加载。分页并发处理实现思路及代码示例
```javascript
// 模拟异步加载⻚⾯数据
function loadPage(pageIndex) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(articlePages[pageIndex]);
        }, Math.random() * 1000); // 模拟不同的加载时间
    });
}
// 分⻚并发加载函数
async function loadPagesConcurrently(pageIndices) {
    const promises = pageIndices.map(index => loadPage(index));
    return Promise.all(promises);
}
// 并发加载第 2、3、4 ⻚
const pageIndicesToLoad = [1, 2, 3];
loadPagesConcurrently(pageIndicesToLoad).then(pages => {
    console.log('Concurrently loaded pages:', pages);
});
```
- 代码细节：
  - loadPage 函数模拟异步加载⻚⾯数据，返回⼀个 Promise ，在随机时间后解析为对应⻚⾯的内容。 
  - loadPagesConcurrently 函数接收⼀个⻚⾯索引数组，将每个索引对应的loadPage 函数调⽤封装成 Promise ，并使⽤ Promise.all 并发执⾏这些Promise 。
- 案例应⽤：在⻓⽂章列表展示中，需要同时加载多个⻚⾯的数据来填充列表，使⽤分⻚并发处理可以加快数据加载速度，提升⽤户体验。

## 28. ⼤⽂件断点续传实现（计算并记录切⽚的哈希值）
- ⼤⽂件断点续传的核⼼是将⼤⽂件分割成多个切⽚，分别上传这些切⽚，并记录每个切⽚的哈希值。在上传过程中，如果出现中断，下次上传时可以根据已上传切⽚的哈希值判断哪些切⽚需要重新上传。
```javascript
// 模拟⽂件
const largeFile = new Blob(['a'.repeat(1024 * 1024 * 10)], { type: 'text/plain' }); // 10MB ⽂件
const sliceSize = 1024 * 1024; // 每个切⽚ 1MB
const slices = [];
const hashMap = new Map();
// 分割⽂件并计算哈希值
async function splitFileAndCalculateHash() {
    for (let i = 0; i < largeFile.size; i += sliceSize) {
        const slice = largeFile.slice(i, i + sliceSize);
        slices.push(slice);
        const hash = await calculateHash(slice);
        hashMap.set(i, hash);
    }
    return hashMap;
}
// 计算⽂件切⽚的哈希值
async function calculateHash(slice) {
    const buffer = await slice.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2,
        '0')).join('');
    return hashHex;
}
// 模拟上传切⽚
async function uploadSlices() {
    const uploadedHashes = new Map(); // 模拟已上传切⽚的哈希值记录
    for (let i = 0; i < slices.length; i++) {
        const start = i * sliceSize;
        const hash = hashMap.get(start);
        if (!uploadedHashes.has(hash)) {
        // 模拟上传操作
            await new Promise(resolve => setTimeout(resolve,Math.random() * 1000));
            uploadedHashes.set(hash, true);
            console.log(`Uploaded slice starting at ${start} with hash${hash}`);
        }
    }
}
splitFileAndCalculateHash().then(() => {
    uploadSlices();
});
```
- 代码细节：
  - splitFileAndCalculateHash 函数将⼤⽂件分割成多个切⽚，并调⽤calculateHash 函数计算每个切⽚的哈希值，将哈希值存储在 hashMap中
  - calculateHash 函数使⽤ crypto.subtle.digest ⽅法计算切⽚的 SHA - 256 哈希值。 
  - uploadSlices 函数模拟上传切⽚的过程，通过 uploadedHashes 记录已上传切⽚的哈希值，避免重复上传。
- 案例应⽤：在上传⼤⽂件（如视频、⼤型⽂档）时，⽹络不稳定或其他原因可能导致上传中断，使⽤断点续传可以从上次中断的位置继续上传，节省时间和带宽。

## 29. 前端⽂件分⽚（input 接受⽂件，拿到⽂件指针，对它进⾏分⽚处理，计算哈希值）
- 前端通过 <input type="file"> 元素让⽤户选择⽂件，获取⽂件对象后，根据指定的切⽚⼤⼩对⽂件进⾏分割，同时计算每个切⽚的哈希值。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Slicing</title>
</head>
<body>
    <input type="file" id="fileInput">
    <button id="sliceButton">Slice File</button>
    <script>
        const fileInput = document.getElementById('fileInput');
        const sliceButton = document.getElementById('sliceButton');
        sliceButton.addEventListener('click', async () => {
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a file.');
                return;
            }
            const sliceSize = 1024 * 1024; // 每个切⽚ 1MB
            const slices = [];
            const hashMap = new Map();
            for (let i = 0; i < file.size; i += sliceSize) {
                const slice = file.slice(i, i + sliceSize);
                slices.push(slice);
                const hash = await calculateHash(slice);
                hashMap.set(i, hash);
                console.log(`Slice starting at ${i} with hash${hash}`);
            }
        });
        async function calculateHash(slice) {
            const buffer = await slice.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }
    </script>
</body>
</html>
```
- 代码细节：
  - 通过 \<input type="file"> 元素让⽤户选择⽂件，点击按钮时获取⽂件对象。 
  - 按照指定的切⽚⼤⼩对⽂件进⾏分割，调⽤ calculateHash 函数计算每个切⽚的哈希值，并将哈希值存储在 hashMap 中。 
  - calculateHash 函数使⽤ crypto.subtle.digest ⽅法计算切⽚的 SHA - 256 哈希值。
- 案例应⽤：在需要上传⼤⽂件的场景中，前端先对⽂件进⾏分⽚处理并计算哈希值，然后将切⽚和哈希值信息发送到服务器，服务器可以根据哈希值验证切⽚的完整性。

## 30. 数组去重
### 30.1.利⽤ Set 数据结构实现去重
- ES6 引⼊的 Set 对象是⼀种⽆序且唯⼀的数据结构，它不允许存储重复的值。因此，可以将数组转换为 Set ，再将 Set 转换回数组，从⽽实现数组去重。
```javascript
function uniqueArray(arr) {
    return [...new Set(arr)];
}
const arr = [1, 2, 2, 3, 4, 4, 5]; 
const uniqueArr = uniqueArray(arr);
console.log(uniqueArr); // 输出: [1, 2, 3, 4, 5]
```
- 代码细节：
  - new Set(arr) ：将数组 arr 转换为 Set 对象，在转换过程中会⾃动去除重复的值。
  - [...new Set(arr)] ：使⽤扩展运算符将 Set 对象展开到⼀个新数组中。
- 复杂度分析：
  - 时间复杂度：$O(n)$，其中 $n$ 是数组的⻓度。因为 Set 的插⼊和查找操作的平均时间复杂度都是 $O(1)$，所以整个去重操作的时间复杂度为 $O(n)$。 
  - 空间复杂度：$O(n)$，因为需要额外的 Set 对象来存储数组中的元素。

### 30.2. 利⽤双重循环实现去重
- 通过双重循环遍历数组，外层循环遍历每个元素，内层循环检查该元素是否已经在前⾯出现过，如果出现过则跳过，否则将其保留。
```javascript
function uniqueArrayLoop(arr) {
const result = [];
for (let i = 0; i < arr.length; i++) {
    let isDuplicate= false;
    for (let j = 0; j < result.length; j++) {
        if (arr[i] === result[j]) {
            isDuplicate = true;
            break;
        }
    }
    if (!isDuplicate) {
        result.push(arr[i]);
    }
    }
    return result;
}
const arrLoop = [1, 2, 2, 3, 4, 4, 5];
const uniqueArrLoop = uniqueArrayLoop(arrLoop);
console.log(uniqueArrLoop); // 输出: [1, 2, 3, 4, 5]
```
- 代码细节：
  - 外层循环遍历数组 arr 中的每个元素。 
  - 内层循环遍历结果数组 result ，检查当前元素是否已经存在于 result中。 
  - 如果不存在，则将该元素添加到 result 中。
- 复杂度分析
  - 时间复杂度：$O(n^2)$，因为需要使⽤双重循环遍历数组。 
  - 空间复杂度：$O(n)$，主要⽤于存储去重后的结果数组。

## 31. 字符串反转算法
### 31.1.利⽤数组的 reverse ⽅法实现字符串反转
- 将字符串转换为字符数组，使⽤数组的 reverse ⽅法反转数组元素的顺序，再将反转后的数组转换回字符串。
```javascript
function reverseString(str) {
    return str.split('').reverse().join('');
}
const str = 'hello'; const reversedStr = reverseString(str);
console.log(reversedStr); // 输出: 'olleh'
```
- 代码细节：
  - str.split('') ：将字符串 str 转换为字符数组。 
  - .reverse() ：调⽤数组的 reverse ⽅法反转数组元素的顺序。 
  - .join('') ：将反转后的数组转换回字符串。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是字符串的⻓度。因为 split、 reverse 和 join 操作的时间复杂度都是 $O(n)$。 
  - 空间复杂度：$O(n)$，主要⽤于存储字符数组。
### 31.2. 利⽤循环实现字符串反转
- 通过循环从字符串的末尾开始，依次将每个字符添加到⼀个新字符串中，从⽽实现字符串反转。
```javascript
function reverseStringLoop(str) {
    let reversed ='';
    for (let i = str.length - 1; i >= 0; i--) {
        reversed += str[i];
    }
    return reversed;
}

const strLoop  = 'hello';
const reversedStrLoop = reverseStringLoop(strLoop);
console.log(reversedStrLoop); // 输出: 'olleh'
```
- 代码细节：
  - 初始化⼀个空字符串 reversed ⽤于存储反转后的字符串。 
  - 从字符串的最后⼀个字符开始，依次将字符添加到 reversed 中。
- 复杂度分析：
  - 时间复杂度：$O(n)$，其中 $n$ 是字符串的⻓度。因为需要遍历字符串⼀次。 
  - 空间复杂度：$O(n)$，主要⽤于存储反转后的字符串。

## 32. 斐波那契数列⽣成算法
### 32.1.递归实现
- 斐波那契数列的定义是：$F(0) = 0$，$F(1) = 1$，$F(n) = F(n - 1) + F(n - 2)$（$n \geq 2$）。可以使⽤递归的⽅式根据这个定义来⽣成斐波那契数列。
```javascript
function fibonacciRecursive(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
const n = 6;
const resultRecursive = fibonacciRecursive(n);
console.log(resultRecursive); // 输出: 8
```
- 代码细节：
  - 当 $n$ 为 0 或 1 时，直接返回 $n$。 
  - 当 $n$ ⼤于 1 时，递归调⽤ fibonacciRecursive 函数计算 $F(n - 1)$ 和$F(n - 2)$ 的值，并将它们相加。
- 复杂度分析
  - 时间复杂度：$O(2^n)$，因为递归调⽤会产⽣⼤量的重复计算，时间复杂度呈指数级增⻓。 
  - 空间复杂度：$O(n)$，主要是递归调⽤栈的深度。
### 32.2. 迭代实现
- 使⽤迭代的⽅式，从 $F(0)$ 和 $F(1)$ 开始，依次计算后续的斐波那契数，避免了递归带来的重复计算问题。
```javascript
function fibonacciIterative(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
const nIterative = 6;
const resultIterative = fibonacciIterative(nIterative);
console.log(resultIterative); // 输出: 8
```
- 代码细节：
  - 初始化两个变量 a 和 b 分别为 0 和 1。 
  - 通过循环从 2 到 $n$，依次计算下⼀个斐波那契数，并更新 a 和 b 的值。
- 复杂度分析： 
  - 时间复杂度：$O(n)$，因为只需要遍历⼀次从 2 到 $n$ 的所有数。 
  - 空间复杂度：$O(1)$，只使⽤了常数级的额外空间。

## 33. 截取最⼤不连续⼦字符串，找出字符串中最⻓的不包含重复字符的⼦字符串
- 可以使⽤滑动窗⼝算法来解决这个问题。滑动窗⼝是⼀种常⽤的算法技巧，它通过两个指针（左指针和右指针）来维护⼀个窗⼝，不断移动右指针扩⼤窗⼝，当窗⼝内出现重复字符时，移动左指针缩⼩窗⼝，直到窗⼝内不再有重复字符。在这个过程中，记录窗⼝的最⼤⻓度以及对应的⼦字符串。
```javascript
function longestNonRepeatingSubstring(s) {
    // ⽤于存储字符及其在字符串中的索引
    const charIndexMap = new Map();
    // 左指针，初始化为 0
    let left = 0;
    // 最⼤不重复⼦字符串的⻓度
    let maxLength = 0;
    // 最⼤不重复⼦字符串
    let maxSubstring = '';
    // 遍历字符串，右指针不断向右移动
    for (let right = 0; right < s.length; right++) {
        const char = s[right];
        // 如果字符已经在 map 中，并且其索引⼤于等于左指针
        if (charIndexMap.has(char) && charIndexMap.get(char) >= left) { 
            // 移动左指针到重复字符的下⼀个位置
            left = charIndexMap.get(char) + 1;
        }
        // 更新字符的最新索引
        charIndexMap.set(char, right);
        // 当前窗⼝的⻓度
        const currentLength = right - left + 1;
        // 如果当前窗⼝⻓度⼤于最⼤⻓度
        if (currentLength > maxLength) {
            // 更新最⼤⻓度
            maxLength = currentLength;
            // 截取最⼤不重复⼦字符串
            maxSubstring = s.slice(left, right + 1);
        }
    }
    return maxSubstring;
}
// 测试示例
const input = "abcabcbb";
const result = longestNonRepeatingSubstring(input);
console.log(result);
```
- **代码解释**
- 初始化
  - charIndexMap ：使⽤ Map 对象来存储字符及其在字符串中的索引。 
  - left ：左指针，初始化为 0，表示滑动窗⼝的起始位置。 
  - maxLength ：⽤于记录最⼤不重复⼦字符串的⻓度，初始化为 0。 
  - maxSubstring ：⽤于记录最⼤不重复⼦字符串，初始化为空字符串。
- 遍历字符串
  - 使⽤ right 指针从左到右遍历字符串。 
  - 对于每个字符 char ，检查它是否已经在 charIndexMap 中，并且其索引⼤于等于 left 。如果是，则说明该字符在当前窗⼝内重复，需要移动 left 指针到重复字符的下⼀个位置。 
  - 更新 charIndexMap 中该字符的最新索引。
- 更新最⼤⻓度和⼦字符串：
  - 计算当前窗⼝的⻓度 currentLength。 
  - 如果 currentLength ⼤于 maxLength ，则更新 maxLength 并截取当前窗⼝对应的⼦字符串作为 maxSubstring。
- 返回结果：
  - 遍历结束后，返回 maxSubstring。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是字符串的⻓度。因为只需要遍历⼀次字符串， 每个字符最多被访问两次（⼀次是右指针访问，⼀次是左指针可能的访问）。 
  - 空间复杂度：$O(k)$，其中 $k$ 是字符集的⼤⼩。在本题中，如果字符串只包含ASCII 字符，那么 $k$ 为 128；如果包含 Unicode 字符，$k$ 会更⼤。主要的空间开销是 charIndexMap 所占⽤的空间。

## 34. 对比2个版本号
- 解题思路
  - 分割版本号：使⽤点号（. ）将版本号分割成数组，数组中的每个元素代表版本号的⼀部分，如 1.2.3 分割后为 ['1', '2', '3']。 
  - 逐位⽐较：从数组的第⼀个元素开始，逐位⽐较两个版本号的对应部分。 
    - 如果对应部分的数字不同，则数字⼤的版本号更⼤。 
    - 如果对应部分的数字相同，则继续⽐较下⼀位。
  - 处理⻓度不⼀致的情况：如果⼀个版本号的位数⽐另⼀个多，需要继续⽐较多出的部分。如果多出的部分都是 0，则两个版本号相等；否则，位数多且⾮零部分⼤的版本号更⼤。
```javascript
function compareVersion(version1, version2) {
    // 分割版本号为数组
    const v1 = version1.split('.');
    const v2 = version2.split('.');
    // 获取两个数组的最⼤⻓度
    const maxLength = Math.max(v1.length, v2.length);
    for (let i = 0; i < maxLength; i++) {
    // 将当前位转换为数字，如果该位不存在则默认为 0
    const num1 = parseInt(v1[i] || 0);
    const num2 = parseInt(v2[i] || 0);
        if (num1 > num2) {
            return 1; // version1 ⼤于 version2
        } else if (num1 < num2) {
            return -1; // version1 ⼩于 version2 
        }
    // 如果当前位相等，则继续⽐较下⼀位
    }
    return 0; // 两个版本号相等
}

// 测试示例
const version1 = "1.2.3";
const version2 = "1.2.4";
const result = compareVersion(version1, version2);
console.log(result);
```
- 代码解释
  - 分割版本号：使⽤ split('.') ⽅法将版本号字符串分割成数组，⽅便逐位⽐较。 
  - 获取最⼤⻓度：使⽤ Math.max(v1.length, v2.length) 获取两个版本号数组的最⼤⻓度，确保能够处理位数不同的版本号。 
  - 逐位⽐较：使⽤ for 循环遍历数组，将当前位的字符串转换为数字进⾏⽐较。如果 num1 > num2 ，则返回 1；如果 num1 < num2 ，则返回 -1；如果相等，则继续⽐较下⼀位。 
  - 处理⻓度不⼀致的情况：如果⼀个版本号的位数⽐另⼀个多，在⽐较时会将缺失的部分视为 0。如果遍历完所有位都相等，则返回 0 表示两个版本号相等。
- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是两个版本号中较⻓的位数。因为只需要遍历⼀次数组，每个元素最多被访问⼀次。 
  - 空间复杂度：$O(n)$，主要的空间开销是存储分割后的版本号数组。

## 35. 在数组中查找重复出现两次的数字
### 35.1. 使用Set
- 利⽤ Set 只能存储唯⼀值的特性。遍历数组，若数字不在 Set 中，将其添加进去；若已存在，则表明该数字重复，把它添加到结果 Set ⾥。最后将结果 Set 转换为数组返回。
```javascript
function findDuplicatesWithSet(arr) {
const seen = new Set(); 
const duplicates = new Set(); 
for (const num of arr) {
    if (seen.has(num)) {
        duplicates.add(num);
    } else {
        seen.add(num);
    }
}
    return Array.from(duplicates);
}
// 测试
const array1 = [1, 2, 3, 2, 4, 3, 5];
console.log(findDuplicatesWithSet(array1));
```
- 复杂度分析
  - 时间复杂度：$O(n)$，这⾥的 $n$ 是数组的⻓度，因为只需要对数组进⾏⼀次遍历
  - 空间复杂度：$O(k)$，其中 $k$ 是数组中不同数字的个数。在最坏情况下，$k$ 等于 $n$。
### 35.2. 使用Map
- 使⽤ Map 来记录每个数字的出现次数。遍历数组，对于每个数字，若它不在 Map中，将其添加并把出现次数设为 1；若已存在，将出现次数加 1。最后遍历 Map ，找出出现次数为 2 的数字并添加到结果数组。
```javascript
function findDuplicatesWithMap(arr) {
    const numMap = new Map();
    const duplicates = [];
    for (const num of arr) {
        if (numMap.has(num)) {
            numMap.set(num, numMap.get(num) + 1);
        } else {
            numMap.set(num, 1);
        }
    }
    for (const [num, count] of numMap) {
        if (count === 2) {
            duplicates.push(num);
        }
    }
    return duplicates;
}
// 测试
const array2 = [1, 2, 3, 2, 4, 3, 5];
console.log(findDuplicatesWithMap(array2));
```
- 复杂度分析
  - 时间复杂度：$O(n)$，需要遍历数组⼀次来统计数字出现次数，再遍历 Map ⼀次找出出现两次的数字，整体为线性时间复杂度。
    空间复杂度：$O(k)$，$k$ 是数组中不同数字的个数，主要⽤于存储 Map 中的键值对。
### 35.3. 排序后遍历
- 先对数组进⾏排序，这样相同的数字会相邻。然后遍历排序后的数组，⽐较相邻元素，若相等且不等于前⼀对相等元素，将其添加到结果数组。
```javascript
function findDuplicatesBySorting(arr) {
    const sortedArr = arr.slice().sort((a, b) => a - b);
    const duplicates = [] 
        for (let i = 1; i < sortedArr.length; i++) {
            if (sortedArr[i] === sortedArr[i - 1]) {
                if (duplicates.length === 0 || sortedArr[i]!== duplicates[duplicates.length - 1]) {
                    duplicates.push(sortedArr[i]);
                }
            }
        }
    return duplicates;
}
// 测试
const array3 = [1, 2, 3, 2, 4, 3, 5];
console.log(findDuplicatesBySorting(array3));
```
- 复杂度分析
  - 时间复杂度：$O(n log n)$，主要是排序操作的时间复杂度，之后遍历数组的时间复杂度是 $O(n)$。 
  - 空间复杂度：$O(m)$，其中 $m$ 是重复出现两次的数字的个数，主要⽤于存储结果数组。

## 36. 睡眠函数 sleep() 隔1秒再打印
```html
<!-- type="module"：这个属性告诉浏览器，<script> 标签⾥的代码是⼀个 ES 模块，这
样就能⽀持顶层 await 特性了。 -->
<script type="module">
// sleep 函数⽤于创建⼀个 Promise，在指定时间后 resolve
async function sleep(timer) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(1);
        }, timer);
    });
}
// 先打印 1
console.log(1);
// 等待 1 秒
await sleep(1000);
// 打印 2
console.log(2);
</script>
```

# 七、移动端适配
## 1. 传统rem适配⽅案
- 核心原理
```JavaScript
// flexible.js 核心代码片段
document.documentElement.style.fontSize =
document.documentElement.clientWidth / 10 + 'px';
```
> rem：根元素字体⼤⼩的倍数单位（1rem = 根字体⼤⼩）
> 动态计算：通过JS实时计算屏幕宽度，设置 <html> 的 font-size
> 设计稿换算：使⽤PostCSS插件将设计稿像素转换为rem单位（如750px设计稿
1rem=75px）

- 实现流程
	1. 引⼊ lib-flexible 或⾃研动态计算脚本
	2. 使⽤PostCSS插件 postcss-pxtorem ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 16, // 根元素字体⼤⼩，这⾥设置为 16px，可根据实际情况调整
      propList: ['*'], // 转换所有属性
        selectorBlackList: [], // 需要忽略的选择器列表，可根据需求添加，如['body'] 表示 body 元素下的 px 不转换
        minPixelValue: 2, // 最⼩转换像素值，⼩于该值的 px 不转换
        exclude: /node_modules/i // 排除 node_modules ⽬录下的⽂件
    }
  }
}
```
- 配置解释
  - rootValue ：根元素的字体⼤⼩，这⾥设置为 16px，即 1rem 等于 16px。在实际开发中，你可以根据设计稿的尺⼨进⾏调整。 
  - propList ：指定哪些 CSS 属性需要进⾏ px 到 rem 的转换， ['*'] 表示所有属性都转换。 
  - selectorBlackList ：指定需要忽略的选择器，这些选择器下的 px 不会被转换。 
  - minPixelValue ：设置最⼩的转换像素值，⼩于该值的 px 不会被转换。 
  - exclude ：排除某些⽬录下的⽂件，通常会排除 node_modules ⽬录。
- 现在你可以在组件的 CSS 中正常使⽤ px 单位， postcss - pxtorem 会在构建过程中⾃动将其转换为 rem 单位

- 优势分析
> 兼容性好：⽀持到Android 4.4+ / iOS 6.1+
> 精细控制：通过JS可实现复杂逻辑（如区分横竖屏）
> 历史惯性：⽼项⽬维护⽅便

- 主要缺陷
> JS依赖：需要等待JS执⾏才能完成布局计算
> 缩放失真：某些Android机型存在rem计算精度问题
> 维护成本：需要维护两套单位系统（rem + px）

- 注意事项：
  - 设计稿与根字体⼤⼩的对应关系：在实际开发中，需要根据设计稿的尺⼨来确定rootValue 的值。例如，如果设计稿是 750px 宽度，通常可以将 rootValue 设置为 75，这样在设计稿上量取的 px 值可以直接写在 CSS 中，插件会⾃动转换为合适的 rem 值。
  - 虽然 rem 适配⽅案在⼤多数现代浏览器中都能正常⼯作，但在⼀些旧版本的浏览器中可能存在兼容性问题，需要进⾏适当的测试和处理。

## 2. 现代vw/vh适配⽅案
- vw是视窗宽度的百分⽐，vh是视窗⾼度的百分⽐。⽐如，1vw表示屏幕宽度的 1%，1vh表示屏幕⾼度的1%。使⽤vw/vh可以很⽅便地实现元素的宽度和⾼度根据屏幕尺⼨⾃适应。
- 优点是简单直观，能很好地适应不同屏幕宽度，缺点是在⼀些特殊布局或需要精确控制元素位置时可能不太⽅便，⽽且部分旧浏览器兼容性略差。

- 核心原理
```css
/* 直接使⽤视⼝单位 */
.box {
  width: 50vw; /* 视⼝宽度的50% */
  height: 30vh; /* 视⼝⾼度的30% */
}
```
> vw：视⼝宽度百分⽐（1vw = 1%视⼝宽度）
> vh：视⼝⾼度百分⽐（1vh = 1%视⼝⾼度）
> ⽆需JS：纯CSS原⽣⽀持

- 实现流程
	1. 使⽤PostCSS插件 postcss-px-to-viewport ⾃动转换单位
```JavaScript
// postcss.config.js 配置示例
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 750, // 设计稿宽度
      unitPrecision: 5, // 转换精度
      viewportUnit: 'vw', // ⽬标单位
      selectorBlackList: ['.no-vw'], // 忽略类名
      minPixelValue: 1 // 最⼩转换像素
    }
  }
}
```
- 优势分析
> 原⽣⽀持：现代浏览器100%⽀持（包括iOS 8+/Android 4.4+）
> 渲染性能：避免JS计算导致的布局抖动
> 开发友好：设计稿直转vw，⽆需⼿动计算
> 响应灵敏：⾃动响应窗⼝⼤⼩变化

- 注意事项
> ⾼度适配：建议使⽤ vh 时配合 calc 计算安全区域
> 字体控制：可混合使⽤rem控制字体⼤⼩

```css
/* 混合⽅案示例 */
.title {
  font-size: 1.2rem; /* 使⽤rem保持⽂字可读性 */
  margin: 0 4vw; /* 使⽤vw保持间距响应 */
}
```

## 3. 方案对比决策
| 维度 | rem方案 | vw/vh方案 |
| - | - | - |
| 实现复杂度 | 需要JS + 构建工具 | 仅需构建工具 |
| 布局精度 | 存在0.01rem误差 | 精确到小数点后5位 |
| 渲染性能 | 存在JS执行延误 | 首屏渲染更快 |
| 维护成本 | 需维护动态计算逻辑 | 纯CSS配置 |
| 未来兼容性 | 逐渐淘汰 | CSS标准持续支持 |

- 补充1：媒体查询
  - 可以根据不同的媒体类型（如屏幕、打印等）和媒体特性（如屏幕宽度、分辨率等）来应⽤不同的CSS样式。例如，可以针对不同的屏幕宽度区间设置不同
    的样式，以实现适配。 
  - 优点是可以针对特定的屏幕尺⼨范围进⾏精细的样式调整，缺点是需要编写⼤量的媒体查询代码，维护起来可能较复杂，⽽且如果屏幕尺⼨变化范围很⼴， 可能需要编写很多组媒体查询。
- 补充2：Flex布局
  - 是⼀种弹性布局模型，通过设置⽗元素为flex布局，可以⽅便地控制⼦元素的排列⽅式、对⻬⽅式和伸缩⽐例等，使⻚⾯在不同屏幕尺⼨下能⾃适应排列。 
  - 优点是强⼤且灵活，能轻松实现各种复杂的布局⾃适应，缺点是对⼀些旧浏览器的兼容性有限，⽽且在某些特殊布局需求下可能不够直观。

## 4. 现在最佳实践
- 推荐方案：vw为主 + rem辅助
```css
/* 根元素设置（可选） */
:root {
	--base-font-size: calc(16px+ 0.5vw); /* 基础字体响应式 */
}
/* 混合使⽤示例 */
.container {
  width: 90vw;
  max-width: 750px; /* 桌⾯端限制最⼤宽度 */
}
.text {
	font-size: 1.2rem; /* 保持⽂字可读性 */
}
```

- 关键配置技巧
```css
/*安全区域适配：使⽤ env(safe-area-inset-*) */
body {
	padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* 1px边框解决⽅案：结合 transform + viewport */
.border-1px {
  position: relative;
  &::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #ddd;
    transform: scaleY(0.5);
    transform-origin: 0 0;
  }
}
```

- 构建工具配置
```javascript
// 现代工程化配置示例（Vue/React通用）
module.exports = {
  plugins: [
    require('postcss-px-to-viewport')({
    viewportWidth: 750 ,
    viewportUnit: 'vw',
    fontViewportUnit: 'rem', // 字体单独使用rem
    require("postcss-flexbugs-fixes"),
    require('postcss-viewport-units') // ⾃动添加兼容前缀
  ]
},
```

## 5. 升级迁移策略
- 渐进式迁移
```css
/*新⻚⾯直接使⽤vw⽅案*/
/*旧⻚⾯通过 @media 逐步替换*/
/* 兼容代码示例 */
.old-box {
  width: 10rem;
  @media (min-width: 320px) {
  	width: 50vw;
  }
}
```
- 降级处理
```css
.modern-box {
  width: 50vw;
  width: 10rem; /* 旧浏览器回退 */
}
```
- 监控覆盖：
```JavaScript
/*使⽤ Modernizr 检测浏览器⽀持*/
if (!Modernizr.cssvwunit) {
	loadScript('legacy-rem-polyfill.js');
}
```

## 6. 总结建议
- 新项⽬⾸选： vw/vh + postcss-px-to-viewport ⽅案
- ⽼项⽬维护：继续使⽤rem⽅案保持稳定
- 混合场景：核⼼布局⽤vw，字体/间距⽤rem
- 特殊需求：结合CSS容器查询（ @container ）实现更智能响应
> 现代浏览器对viewport单位的⽀持已⾮常成熟，拥抱CSS原⽣⽅案能获得更好的性能表
现和开发体验。对于需要兼容极旧浏览器的特殊项⽬（如政府/银⾏系统），可考虑保留rem⽅案作为兜底。

## 7. 相关库和⼯具
- lib-flexible 
  - 是⼿淘团队开发的⼀个⽤于H5⻚⾯适配的库。它主要通过动态修改html元素的font-size来实现rem适配，并且能根据不同的屏幕宽度进⾏合理的计算和设置，简化了rem适配的开发过程。
- postcss-pxtorem 
  - 是⼀个PostCSS插件，它可以在构建过程中⾃动将CSS中的px单位转换为rem单位，⼤⼤提⾼了开发效率，减少了⼿动计算rem值的⼯作量。 
- Autoprefixer 
  - 是⼀个CSS⾃动添加浏览器前缀的⼯具。由于不同浏览器对CSS属性的⽀持和实现⽅式不同，有些CSS属性需要添加特定的浏览器前缀才能在不同浏览器中正常显示。Autoprefixer可以根据配置的浏览器兼容列表，⾃动为CSS属性添加相应的前缀，如-webkit-、-moz-、-ms-等，提⾼了CSS的兼容性。

# 八、框架部分
## 1. usestate 和 useref 区别？- React
-  useState 和 useRef 是 React Hooks 中的两个钩⼦。 useState ⽤于在函数组件中添加状态，当状态更新时，组件会重新渲染。 useRef 创建⼀个可变的对象，它的值在组件的整个⽣命周期内保持不变，并且修改它不会触发组件重新渲染。
```javascript
import React, { useState, useRef } from 'react';
function Example() {
    const [count, setCount] = useState(0);
    const refCount = useRef(0);
};
const incrementState = () => {
setCount(count + 1);
const incrementRef = () => {
    refCount.current++;
    console.log('Ref count:', refCount.current);
};
return (
    <div>
        <p>State count: {count}</p>
        <button onClick={incrementState}>Increment State</button>
        <button onClick={incrementRef}>Increment Ref</button>
    </div>
    );
}
export default Example;
```
- 代码细节： useState 返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染。 useRef 返回⼀个对象，通过 current 属性访问和修改其值。
- 案例应⽤： useState 适⽤于需要触发组件重新渲染的状态管理，如表单输⼊值、 计数器等。 useRef 适⽤于保存不需要触发重新渲染的值，如 DOM 节点引⽤、定时器 ID 等。

## 2. 为什么有 hooks？hooks 是⼲什么⽤的？
- 在 React 中，Hooks 是 React 16.8 引⼊的新特性，主要是为了解决类组件的⼀些问题，如代码复⽤困难、逻辑复杂时难以拆分等。Hooks 可以让你在不编写class 的情况下使⽤ state 以及其他 React 特性。
```javascript
import React, { useState } from'react';
function Counter() {
const [count, setCount] = useState(0);
return (
    <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
            Click me
        </button>
    </div>
);
}
export default Counter;
```
- 代码细节： useState 是⼀个 Hook，它返回⼀个数组，第⼀个元素是状态值，第⼆个元素是更新状态的函数。每次调⽤ setCount 时，组件会重新渲染并更新count 的显示值。 
- 案例应⽤：Hooks 使得函数组件可以有状态，并且可以将复杂的逻辑拆分成多个⼩的 Hook，提⾼代码的复⽤性和可维护性。例如在多个组件中复⽤表单验证逻辑、数据获取逻辑等。

## 3. 常⻅的 hooks？
- React 提供了多个内置的 Hooks，还有很多社区⾃定义的 Hooks，常⻅的内置 Hooks 可以帮助开发者在函数组件中使⽤不同的 React 特性。
```javascript
// useState ：⽤于在函数组件中添加状态。
import React, { useState } from'react';
function Example() {
    const [count, setCount] = useState(0);
    return (
        <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count +
        1)}>Increment</button>
        </div>
    );
}
// useEffect：⽤于处理副作⽤，如数据获取、订阅、DOM 操作等。
import React, { useState, useEffect } from'react';
function DataFetching() {
    const [data, setData] = useState(null);
    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []);
    return (
        <div>
            {data? 
                <p>{data.message}</p> : <p>Loading...</p>}
        </div>
    );
}
// useContext：⽤于在组件之间共享数据，避免层层传递 `props`。
import React, { createContext, useContext } from'react';
const ThemeContext = createContext();
function ThemeProvider({ children }) {
    const theme= 'dark';
    return (
        <ThemeContext.Provider value={theme}>
            {children}
        </ThemeContext.Provider>
            
    );
}
function ChildComponent() {
    const theme = useContext(ThemeContext);
    return <p>Current theme: {theme}</p>;
}
function App() {
    return (
        <ThemeProvider>
            <ChildComponent />
        </ThemeProvider>
    );
}
```
- 案例应⽤：不同的 Hooks 适⽤于不同的场景， useState ⽤于状态管理， useEffect ⽤于处理异步操作和副作⽤， useContext ⽤于组件间数据共享。

## 4. 原生的hooks
- 原⽣的 Hooks 指的是 React 官⽅提供的内置 Hooks，它们是 React 核⼼库的⼀部分，可以直接在 React 项⽬中使⽤。
- 常⻅原⽣ Hooks 总结：
  - useState ：管理组件的状态，允许函数组件有状态变化。 
  - useEffect ：处理副作⽤，如数据获取、订阅、DOM 操作等。在组件渲染后或依赖项变化时执⾏回调函数。 
  - useContext ：获取上下⽂对象，⽤于在组件树中共享数据。 
  - useReducer ：类似于 Redux 的 reducer 模式，⽤于管理复杂的状态逻辑。 
  - useCallback ：返回⼀个记忆化的回调函数，⽤于优化性能，避免不必要的函数重新创建。 
  - useMemo ：返回⼀个记忆化的值，⽤于优化性能，避免不必要的计算。 
  - useRef ：创建⼀个可变的引⽤对象，通常⽤于保存 DOM 节点或在组件的整个⽣命周期内保持值不变。 
  - useImperativeHandle ：⽤于⾃定义使⽤ ref 时暴露给⽗组件的实例值。 
  - useLayoutEffect ：与 useEffect 类似，但会在 DOM 更新后同步执⾏，常⽤于需要测量 DOM 布局的场景。 
  - useDebugValue ：⽤于在 React DevTools 中显示⾃定义 Hook 的调试信息。 
- 案例应⽤：在不同的开发场景中选择合适的原⽣ Hooks 可以提⾼开发效率和组件性能，例如在性能敏感的组件中使⽤ useCallback 和 useMemo 进⾏优化。

## 5. useContext 如何进⾏组件之间的传输？
- useContext 结合 createContext 和 Context.Provider 实现组件间的数据传输。 createContext 创建⼀个上下⽂对象， Context.Provider ⽤于提供数据， useContext ⽤于在组件中获取上下⽂对象中的数据。
```javascript
import React, { createContext, useContext } from'react';
// 创建上下⽂对象
const UserContext = createContext();
// 提供数据的组件
function UserProvider({ children }) {
    const user = { name: 'John', age: 30 };
    return (
        <UserContext.Provider value={user}>
            {children}
        </UserContext.Provider>
    );
}
// 接收数据的组件
function DisplayUser() {
    const user = useContext(UserContext);
    return (
        <div>
            <p>Name: {user.name}</p>
            <p>Age: {user.age}</p>
        </div>
    );
}
function App() {
    return (
        <UserProvider>
            <DisplayUser />
        </UserProvider>
    );
}
export default App;
```
- 代码细节：
  - 使⽤ createContext 创建 UserContext 。 
  - UserProvider 组件使⽤ UserContext.Provider 包裹⼦组件，并通过 value 属性提供数据。 
  - DisplayUser 组件使⽤ useContext(UserContext) 获取上下⽂对象中的数据并显示。
- 案例应⽤：在多层嵌套的组件结构中，当多个组件需要访问相同的数据时，使⽤useContext 可以避免通过 props 层层传递数据，提⾼代码的简洁性和可维护性。

## 6. 虚拟 DOM 的理解
- 虚拟 DOM（Virtual DOM）是⼀种轻量级的 JavaScript 对象，它是真实DOM 的抽象表示。当组件状态发⽣变化时，React 等框架会先计算虚拟 DOM 的差异（Diffing 算法），然后将差异批量更新到真实 DOM 上，这样可以减少直接操作真实 DOM 的次数，提⾼性能。
- 代码案例（简单模拟虚拟 DOM 更新）：
```javascript
// 虚拟 DOM 节点类
class VNode {
    constructor(tag, props, children) {
        this.tag = tag;
        this.props = props;
        this.children = children;
    }
}
// 创建虚拟 DOM
const oldVNode = new VNode('div', { id: 'old' }, ['Old content']);
const newVNode = new VNode('div', { id: 'new' }, ['New content']);
// 简单的 Diff 算法和更新函数
function diff(oldVNode, newVNode) {
    if (oldVNode.tag!== newVNode.tag || oldVNode.props.id!==newVNode.props.id) {
        // 这⾥简单模拟更新操作
        console.log('Update DOM');
    }
}
diff(oldVNode, newVNode);
```
- 代码细节：定义了⼀个 VNode 类来表示虚拟 DOM 节点。创建了旧的和新的虚拟DOM 节点，通过 diff 函数⽐较它们的差异，若有差异则进⾏更新操作。
- 案例应⽤：在 React、Vue 等前端框架中⼴泛使⽤虚拟 DOM 来优化 DOM 操作。例如在⼀个列表组件中，当列表数据更新时，框架会通过虚拟 DOM 计算差异，只更新需要更新的部分，⽽不是重新渲染整个列表。

## 7. Vue3，有哪些改进
- Vue3 在性能、开发体验、代码组织等⽅⾯进⾏了诸多改进。采⽤了 Proxy 实现响应式系统，提⾼了响应式的性能和功能；引⼊了组合式 API，使代码更易于复⽤和维护；重构了虚拟 DOM 实现，优化了渲染性能。
```vue
<template>
    <div>
      <p>{{ count }}</p>
      <button @click="increment">Increment</button>
    </div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(0);
const increment = () => {
    count.value++;
};
</script>
```
- 代码细节：使⽤ script setup 语法和组合式 API， ref 函数创建响应式数据 count ，通过 count.value 访问和修改其值。点击按钮时调⽤ increment 函数 更新 count 的值。
- 案例应⽤：组合式 API 使得代码逻辑可以按照功能进⾏分组，提⾼了代码的可读性和可维护性。例如在⼤型项⽬中，不同的功能模块可以独⽴封装和复⽤。

## 8. vue双向绑定原理
- Vue 的双向绑定是通过数据劫持结合发布 - 订阅模式实现的。在 Vue2 中，使⽤ Object.defineProperty() 对数据对象的属性进⾏劫持，当属性值发⽣变化时，触发 setter ⽅法通知所有订阅者更新视图；在 Vue3 中，使⽤ Proxy 对象进⾏数据劫持。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2 Two - way Binding</title>
</head>
<body>
<input type="text" id="input">
<p id="output"></p>
<script>
    const data = {message: ''};
    // 数据劫持
    Object.defineProperty(data, 'message', {
        get() {
            return this._message;
        },
        set(newValue) {
            this._message = newValue;
            document.getElementById('output').textContent = newValue;
        }})
    const input = document.getElementById('input');
    input.addEventListener('input', function () {
        data.message = this.value;
    });
    // 初始化输出
    document.getElementById('output').textContent = data.message;
</script>
</body>
</html>
```
- 代码细节：使⽤ Object.defineProperty 对 data 对象的 message 属性进⾏劫持，当 message 属性被赋值时， setter ⽅法会被触发，更新⻚⾯上的 p 元素内容。同时，给输⼊框添加 input 事件监听器，当输⼊框内容变化时，更新data.message 的值，从⽽实现双向绑定。
- 案例应⽤：在表单输⼊场景中，如⽤户登录、注册表单，通过双向绑定可以⽅便地将⽤户输⼊的数据同步到数据对象中，同时将数据对象的变化反映到⻚⾯上。

## 9.  在什么阶段进⾏ DOM 操作
- 在前端开发中，不同的框架和场景有不同的适合进⾏ DOM 操作的阶段。在原⽣ JavaScript 中，通常在 DOMContentLoaded 事件触发后进⾏ DOM 操作，确保⽂档已经解析完成。在 Vue 中，可以在 mounted ⽣命周期钩⼦中进⾏ DOM 操作，此时组件已经挂载到 DOM 上。在 React 中，可以使⽤ useEffect 钩⼦在组件渲染后进⾏ DOM 操作。
```vue
<template>
    <div>
      <p ref="myParagraph">This is a paragraph.</p>
    </div>
</template>
<script>
export default {
    mounted() {
        const paragraph = this.$refs.myParagraph;
        paragraph.style.color ='red';
    }
};
</script>
```
- 代码细节：在 Vue 组件的 mounted 钩⼦中，通过 this.$refs 获取到 p 元素的 引⽤，然后修改其样式。
- 案例应⽤：当需要对⻚⾯上的元素进⾏样式修改、添加事件监听器等操作时，选择合适的阶段进⾏ DOM 操作可以避免出现元素未加载完成的错误。

## 10. hash 模式和 history 模式有什么区别？
- Vue 路由（Vue Router）是 Vue.js 官⽅的路由管理器，它的实现基于单⻚⾯应⽤（SPA）的原理。主要通过监听浏览器的 URL 变化，根据配置的路由规则匹配相应的组件，并将组件渲染到指定的路由出⼝（ <router - view> ）中。
- hash路由模式
  - 原理：Hash 路由是基于 URL 中的哈希值（即 # 后⾯的部分）来实现的。当哈希值发⽣变化时，浏览器不会向服务器发送请求，⽽是触发 hashchange 事件，前端可以监听这个事件并根据不同的哈希值来渲染不同的⻚⾯内容。 
  - 示例： http://example.com/#/home ，其中 #/home 就是哈希值。当哈希值从 #/home 变为 #/about 时，前端代码会捕捉到这个变化并进⾏相应的⻚⾯切换。
- History 路由模式
  - 原理：History 路由模式利⽤ HTML5 的 History API 来实现。 History API 提供了 pushState 和 replaceState ⽅法，通过这两个⽅法可以改变浏览器的历史记录，同时更新 URL，但不会向服务器发送请求。当⽤户点击浏览器的前进、后退按钮或者调⽤相关的历史操作⽅法时，会触发 popstate 事件，前端可以监听这个事件并根据不同的 URL 来渲染不同的⻚⾯内容。 
  - 示例：使⽤ history.pushState(null, '', '/about') 可以将当前 URL 变为http://example.com/about ，并且在浏览器历史记录中添加⼀条新记录。
- 在前端路由中，hash 模式和 history 模式是两种不同的实现⽅式，主要区别在于 URL 的表现形式和浏览器历史记录的管理。
- URL 表现形式：
  - hash 模式：URL 中使⽤ # 符号来分隔路径，例如http://example.com/#/home。 # 后⾯的内容不会发送到服务器，浏览器只会根据 # 后⾯的路径进⾏前端路由匹配。 
  - history 模式：URL 看起来像正常的路径，例如http://example.com/home 。它使⽤ HTML5 的 History API 来管理浏 览器历史记录，路径会发送到服务器。
- 浏览器历史记录管理：
  - hash 模式：每次 # 后⾯的路径变化都会添加⼀条新的历史记录，通过浏览器的前进后退按钮可以在这些历史记录之间切换。 
  - history 模式：使⽤ pushState 和 replaceState ⽅法来操作浏览器历史记录，也可以实现前进后退功能，但需要服务器端的⽀持，因为服务器需要对不同的路径返回相同的 HTML ⽂件。
```javascript
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
Vue.use(VueRouter);
const routes = [
    {
        path: '/home',
        name: 'Home',
        component: Home
    },
    {
        path: '/about',
        name: 'About',
        component: About
    }
];
// hash 模式
const routerHash = new VueRouter({
    mode: 'hash',
    routes
});
// history 模式
const routerHistory = new VueRouter({
    mode: 'history',
    routes
});
```
- 案例应⽤：hash 模式适合简单的单⻚应⽤，不需要服务器端额外配置；history 模式适合对 URL 美观性有要求的应⽤，但需要服务器端进⾏相应的配置，如在Node.js 中使⽤ Express 框架时需要配置中间件来处理不同路径的请求。
- 应用场景：
  - 单⻚⾯应⽤（SPA）：如企业官⽹、后台管理系统等，通过 Vue Router 可以实现⻚⾯的切换和导航，给⽤户带来流畅的交互体验。
  - 多⻚⾯应⽤（MPA）：在⼀些复杂的多⻚⾯应⽤中，也可以使⽤ Vue Router 来管理局部的路由，实现局部⻚⾯的动态加载和切换。
```vue
<template>
<div id="app">
<router-link to="/">Home</router-link>
<router-link to="/about">About</router-link>
<router-view></router-view>
</div>
</template>
<script>
import Vue from 'vue';
import VueRouter from 'vue-router';
import Home from './views/Home.vue';
import About from './views/About.vue';
Vue.use(VueRouter);
const routes = [
    {
    path: '/',
    name: 'Home',
    component: Home
    },
    {
    path: '/about',
    name: 'About',
    component: About
    }
];
const router = new VueRouter({
    mode: 'hash',
    routes
});
new Vue({
    router,
    render: h => h('div', { id: 'app' })
}).$mount('#app');
</script>
```
- 解析：上述代码定义了⼀个简单的 Vue 应⽤，使⽤ Vue Router 实现了两个路由： / 和 /about 。通过 <router - link> 组件创建导航链接，点击链接时会改变 URL 的路径。 <router - view> 是路由出⼝，匹配到的组件会渲染到这个位置。在 main.js 中，⾸先引⼊ VueRouter 并使⽤ Vue.use(VueRouter) 安装插件。然后定义路由规则数组 routes ，每个规则包含路径 path 、路由名称 name 和对应的组件 component 。接着创建 VueRouter 实例，指定路由模式为 hash ，并将路由规则传 ⼊。最后将路由实例挂载到 Vue 实例上。
- 兼容性：
  - Hash 路由模式：兼容性⾮常好，⼏乎所有的浏览器都⽀持哈希值的变化和 hashchange 事件。因此，在需要兼容旧版本浏览器的项⽬中，Hash 路由是⼀个⽐较稳妥的选择。
  - History 路由模式：依赖于 HTML5 的 History API ，因此在⼀些旧版本的浏览器中可能不⽀持。在使⽤ History 路由模式时，需要考虑项⽬的⽬标⽤户群体，如果需要兼容旧版本浏览器，可能需要进⾏额外的处理或者降级到 Hash 路由模式。
- 浏览器历史记录管理
  - Hash 路由模式：哈希值的变化会在浏览器的历史记录中留下记录，⽤户可以通过点击浏览器的前进、后退按钮来切换不同的哈希值状态。但是，由于哈希值的变化不会向服务器发送请求，因此历史记录中的每个状态对应的⻚⾯内容实际上是由前端代码控制的。
  - History 路由模式：利⽤ History API 可以更加灵活地管理浏览器的历史记录。 pushState ⽅法可以在不刷新⻚⾯的情况下向历史记录中添加⼀条新记录， replaceState ⽅法可以替换当前的历史记录。这种⽅式可以实现更复杂的历史记录管理，例如在不影响⽤户操作的情况下修改 URL。

## 11. Vue的diff算法优化（Vue2和3之间做了什么优化）
- Vue2 的 Diff 算法：Vue2 采⽤的是基于虚拟 DOM 的双指针⽐较算法，使⽤snabbdom 库实现。它会对新旧虚拟 DOM 树进⾏深度优先遍历，通过⽐较新旧节点的 key、tag、data 等属性来判断节点是否需要更新。在更新⼦节点时，会采⽤双指针法，对新旧⼦节点数组进⾏⽐较，找到可复⽤的节点并进⾏移动、插⼊或删除操作。但这种算法在处理⼤规模列表更新时，由于需要频繁地进⾏全量⽐较，性能开销较⼤。
- Vue3 的 Diff 算法优化：Vue3 对 Diff 算法进⾏了多⽅⾯的优化。⾸先引⼊了静态标记（PatchFlag），对于模板中的静态节点会标记为静态节点，在 Diff 过程中直接跳过这些节点的⽐较，⼤⼤减少了⽐较的⼯作量。其次，在处理动态节点时，采⽤了快速 Diff 算法，结合最⻓递增⼦序列算法，能更⾼效地找到可复⽤的节点，减少节点的移动操作，提⾼了更新效率。
- 应用场景：
  - Vue2：适⽤于⼩型项⽬或者对性能要求不是特别⾼的项⽬，因为其 Diff 算法虽然在处理复杂更新时性能有限，但对于简单的⻚⾯更新已经⾜够。 
  - Vue3：更适合⼤型项⽬和需要频繁进⾏数据更新的场景，如实时数据展示、交互式应⽤等，其优化后的 Diff 算法能显著提升性能。
- 代码案例：以下是⼀个简单的 Vue2 和 Vue3 列表更新的示例，通过对⽐可以感受两者的差异，但由于 Diff 算法是底层实现，代码中不会直接体现其细节。
- Vue2示例：
```vue
<template>
<div>
<ul>
    <li v-for="item in list" :key="item.id">{{ item.name }}</li>
</ul>
    <button @click="updateList">Update List</button>
</div>
</template>
<script>
export default {
    data() {
        return {
        list: [
            { id: 1, name: 'Item 1' },
            { id: 2, name: 'Item 2' },
            { id: 3, name: 'Item 3' }
        ]
        };
    },
    methods: {
    updateList() {
        this.list = [
            { id: 3, name: 'Item 3' },
            { id: 1, name: 'Item 1' },
            { id: 2, name: 'Item 2' }
            ];
        }
    }
};
</script>
```
- Vue3示例：
```vue
<template>
<div>
<ul>
  <li v-for="item in list" :key="item.id">{{ item.name }}</li>
</ul>
  <button @click="updateList">Update List</button>
</div>
</template>
<script setup>
import { ref } from 'vue';
const list = ref([
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' }
]);
const updateList = () => {
    list.value = [
        { id: 3, name: 'Item 3' },
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' }
    ];
};
</script>
```
- 解析：在上述代码中，Vue2 和 Vue3 的模板和功能基本相同，都是展示⼀个列表并提供⼀个按钮⽤于更新列表。但在底层，Vue3 的 Diff 算法会更⾼效地处理列表的更新，尤其是当列表元素顺序发⽣变化时，能更快地完成节点的移动和更新操作。

## 12. 如何进⾏组件的⼆次封装
- 明确封装⽬的：在开始⼆次封装之前，要清楚为什么要进⾏封装。常⻅的⽬的包括：
  - 提⾼复⽤性：将⼀些常⽤的功能或样式封装成⼀个通⽤组件，⽅便在多个项⽬或⻚⾯中使⽤。 
  - 简化使⽤：对⼀些复杂的原⽣组件或第三⽅组件进⾏简化，使其使⽤起来更加⽅便快捷。 
  - 统⼀⻛格：确保项⽬中使⽤的组件具有统⼀的外观和交互⻛格。
- ⼆次封装的步骤
### 12.1. 选择合适的基础组件
> 可以是原⽣ HTML 元素、框架⾃带的组件，或者第三⽅开源组件。例如，在 Vue 项⽬中，可能会对 input 元素、 el - input （Element UI 组件）等进⾏⼆次封装。

### 12.2. 分析基础组件的属性、方法和事件
> 了解基础组件提供了哪些属性可以配置、哪些⽅法可以调⽤以及会触发哪些事件。这有助于在⼆次封装时进⾏合理的继承和扩展。

### 12.3. 定义新组建的属性、方法和事件
- 属性：根据封装⽬的，定义新组件需要接收的属性。可以对基础组件的属性进⾏筛选和扩展。例如，封装⼀个 Input 组件时，可以定义placeholder、 value 、 disabled 等属性，同时还可以添加⼀些⾃定义属性，如 maxLength 来限制输⼊的最⼤⻓度。
```vue
<template>
<input :value="value" :placeholder="placeholder" :disabled="disabled" @input="handleInput">
</template>
<script>
export default {
    props: {
        value: {
            type: String,
            default: ''
        },
        placeholder: {
            type: String,
            default: '请输⼊内容'
        },
        disabled: {
            type: Boolean,
            default: false
        },
        maxLength: {
            type: Number,
            default: 50
        }
    },
    methods: {
        handleInput(event) {
            this.$emit('input', event.target.value.slice(0, this.maxLength));
        }
    }
}
</script>
```
- ⽅法：可以定义新组件⾃⼰的⽅法，也可以对基础组件的⽅法进⾏封装和调⽤。例如，封装⼀个 Modal 组件时，可以定义 open 和 close ⽅法来控制模态框的显示和隐藏。
```vue
<template>
    <div v-if="visible" class="modal">
        <!-- 模态框内容 -->
        <button @click="close">关闭</button>
    </div>
</template>
<script>
export default {
    data() {
        return {
            visible: false
        };
    },
    methods: {
        open() {
            this.visible = true;
        },
        close() {
            this.visible = false;
        }
    }
}
</script>
```
- 事件：要处理好基础组件触发的事件，并可以根据需要触发新的⾃定义事件。例如，在封装 Input 组件时，将基础 input 元素的 input 事件进⾏处理后，触发⾃定义的 input 事件，⽅便⽗组件监听。
### 12.4. 样式定制
- 继承基础组件样式：可以通过 CSS 类名或样式绑定的⽅式继承基础组件的样式。例如，在封装 Button 组件时，可以使⽤基础按钮的类名，同时添加⾃定义的类名来修改样式。
```vue
<template>
  <button :class="['base-button', customClass]">{{ label }}</button>
</template>
<script>
export default {
    props: {
        label: {
            type: String,
            default: '按钮'
        },
        customClass: {
            type: String,
            default: ''
        }
    }
}
</script>
<style scoped>
    .base-button {
        /* 基础按钮样式 */
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
    }
</style>
```
- 提供样式配置选项：可以通过属性来控制组件的样式，使组件的外观更加灵活。例如，定义⼀个 size 属性，根据不同的值显示不同⼤⼩的按钮。
### 12.5. 测试和优化
- 对⼆次封装的组件进⾏全⾯的测试，确保其功能正常、样式符合预期，并且在不同的使⽤场景下都能稳定⼯作。 
- 根据测试结果进⾏优化，例如优化性能、修复 bug、改进⽤户体验等。
- ⼆次封装组件需要综合考虑属性、⽅法、事件和样式的设计，以实现提⾼复⽤性、简化使⽤和统⼀⻛格的⽬的。通过以上步骤，可以创建出⾼质量的⼆次封装组件。

## 13. Vue插槽slot
- 插槽（Slot）是 Vue 中⼀个⾮常实⽤的特性，它允许你在封装组件时为组件提供灵活的内容插⼊机制，让组件可以根据不同的使⽤场景插⼊不同的内容，提⾼组件的复⽤性和灵活性。下⾯从概念、分类、使⽤⽅法等⽅⾯详细介绍插槽。
- 比如，⼀个通⽤的卡⽚组件，这个卡⽚组件有固定的样式和布局，但卡⽚内部的具体内容可能会根据不同的⻚⾯需求⽽变化。插槽就像是在这个卡⽚组件上预留的“空位”，在使⽤这个卡⽚组件时，你可以往这些“空位”⾥插⼊⾃定义的内容，⽐如图⽚、⽂字、按钮等。
- 插槽的分类和使用方法
### 13.1. 匿名插槽（默认插槽）
- 匿名插槽是最基本的插槽类型，它没有具体的名称，⽤于在组件中插⼊单个默认的内容区域。
- 使用方法：
  - 定义组件：在组件模板中使⽤ <slot></slot> 标签来定义插槽位置。
```vue
<!-- CustomCard.vue -->
<template>
<div class="custom-card">
    <div class="card-header">卡⽚头部</div>
    <slot></slot> <!-- 匿名插槽 -->
    <div class="card-footer">卡⽚底部</div>
</div>
</template>
<style scoped>
    .custom-card {
    border: 1px solid #ccc;
    padding: 10px;
    }
    .card-header {
    font-weight: bold;
    }
    .card-footer {
    color: #999;
    }
</style>
```
  - 使⽤组件：在使⽤该组件时，直接在组件标签内插⼊要显示的内容，这些内容会被插⼊到插槽的位置。
```vue
<template>
<div>
    <CustomCard>
        <p>这是卡⽚的主体内容。</p>
    </CustomCard>
</div>
</template>
<script>
import CustomCard from './CustomCard.vue';
export default {
    components: {CustomCard}
};
</script>
```
### 13.2. 具名插槽
- 概念：当组件需要多个不同的内容插⼊位置时，就可以使⽤具名插槽。每个插槽有⼀个唯⼀的名称，通过名称来区分不同的插⼊位置。
- 使用方法
  - 定义组件：在组件模板中使⽤ <slot name="插槽名称"></slot> 标签来定义具名插槽。
```vue
<!-- CustomLayout.vue -->
<template>
<div class="custom-layout">
    <header>
        <slot name="header"></slot> <!-- 具名插槽：头部 -->
    </header>
    <main>
        <slot></slot> <!-- 匿名插槽：主体内容 -->
    </main>
    <footer>
        <slot name="footer"></slot> <!-- 具名插槽：底部 -->
    </footer>
</div>
</template>
<style scoped>
.custom-layout {
    display: flex;
    flex-direction: column;
    height: 100vh;
}
header {
    background-color: #333;
    color: white;
    padding: 10px;
}
main {
    flex: 1;
    padding: 20px;
}
footer {
    background-color: #333;
    color: white;
    padding: 10px;
    text-align: center;
}
</style>
```
  - 使⽤组件：在使⽤该组件时，使⽤ `<template #插槽名称>` （Vue 3 语法，Vue 2中使⽤ `<template slot="插槽名称">`）来指定要插⼊到哪个具名插槽中。
```vue
<template>
<div>
    <CustomLayout>
        <template #header>
            <h1>⻚⾯标题</h1>
        </template>
        <p>这是⻚⾯的主体内容。</p>
        <template #footer>
            <p>版权所有 &copy; 2024</p>
        </template>
    </CustomLayout>
</div>
</template>
<script>
import CustomLayout from './CustomLayout.vue';
export default {
components: {CustomLayout}
};
</script>
```
### 13.3. 作用域插槽
- 作⽤域插槽允许在⽗组件中访问⼦组件的数据。⼦组件可以将⾃⼰的数据通过插槽传递给⽗组件，⽗组件可以根据这些数据进⾏不同的渲染。
- 使用方法
  - 定义组件：在组件模板中，通过 <slot :数据名称="数据值"></slot> 的⽅式将数据传递给插槽。
```vue
<!-- UserList.vue -->
<template>
<ul>
    <li v-for="user in users" :key="user.id">
        <slot :user="user"></slot> <!-- 作⽤域插槽，传递 user 数据 -->
    </li>
</ul>
</template>

<script>
export default {
data() {
    return {
        users: [
            { id: 1, name: '张三' },
            { id: 2, name: '李四' },
            { id: 3, name: '王五' }
        ]
    }
}
}
</script>
```
  - 使⽤组件：在使⽤该组件时，通过 `<template #default="{ 数据名称 }">`（Vue 3 语法，Vue 2 中使⽤ `<template slot-scope="{ 数据名称 }">`）来接收⼦组件传递的数据，并使⽤这些数据进⾏渲染。
```vue
<template>
<div>
    <UserList>
        <template #default="{ user }">
            <span>{{ user.name }}</span>
        </template>
    </UserList>
</div>
</template>
<script>
import UserList from './UserList.vue';
export default {
components: {UserList}
};
</script>
```
- 总结：插槽是 Vue 中实现组件灵活复⽤的重要特性，通过匿名插槽、具名插槽和作⽤域插槽， 你可以在封装组件时为不同的内容插⼊需求提供解决⽅案，使组件更加通⽤和强⼤

## 14. 静态组件和动态组件区别
- 在 Vue 中，动态组件和静态组件的核⼼区别在于 组件的渲染时机和灵活性。以下是详细对⽐和实际应⽤场景分析：
### 14.1. 核心区别对比
| 特性 | 静态组件                           | 动态组件
| - |--------------------------------| - |
| 定义方式 | 在模板中直接使⽤组件标签（如\<ComponentA/> ） | 通过 \<component :is="variable"> 动态绑定 |
| 渲染时机 | 编译时确定，直接渲染 | 运行时根据条件动态决定渲染哪个组件 |
| 灵活性 | 固定，无法切换 | 高度灵活，可通过变量或逻辑动态切换 |
| 生命周期 | 初始化时创建，销毁时触发销毁钩子 | 切换时可能触发销毁或重建（除非使用<keep-alive>） |
| 性能影响 | 高效，无额外开销 | 频繁切换时可能产生性能开销（需配合缓存优化） |

### 14.2. 使用场景示例
- 静态组件：固定结构
```vue
<template>
    <!-- 明确的组件结构 -->
    <Header />
    <ProductList />
    <Footer />
    <!--  适⽤场景：⻚⾯的固定模块（如导航栏、底部信息）。-->
</template>
```
- 动态组件：条件渲染
```vue
<template>
    <!-- 根据状态动态切换组件 -->
    <component :is="currentTabComponent" />
</template>
<script>
export default {
data() {
    return {
        currentTab: 'Home',
        tabs: { Home: 'HomeComponent', About: 'AboutComponent' }
    };
},
computed: {
    currentTabComponent() {
        return this.tabs[this.currentTab];
    }
}
};
// 适⽤场景：
// 标签⻚切换（如不同功能的⼦⻚⾯）
// 根据权限显示不同组件（如管理员与普通⽤户视图）
// 动态加载异步组件（如按需加载弹窗）
</script>
```
### 14.3. 性能优化技巧
- 使⽤ <keep-alive> 缓存动态组件
```vue
<template>
<!-- 缓存组件状态，避免重复渲染 -->
<keep-alive>
    <component :is="currentComponent" />
</keep-alive>
</template>
<!--效果：保留组件状态（如表单输⼊内容），避免重复触发 created / mounted ⽣命周期。-->
```
- 按需加载异步组件
```javascript
// Vue 3 语法
const AsyncComponent = defineAsyncComponent(() => import('./AsyncComponent.vue'));
// 效果：减少初始加载体积，提升⾸屏速度。
```
### 14.4. 底层原理剖析
- 静态组件编译结果，静态组件在编译阶段会被直接解析为具体的组件引⽤：
```javascript
// 编译后的渲染函数
import ComponentA from './ComponentA.vue';
export function render() {
    return h(ComponentA);
}
```
- 动态组件编译结果，动态组件通过 resolveDynamicComponent 函数在运⾏时决定渲染内容：
```javascript
// 编译后的渲染函数
export function render() {
    return h(resolveDynamicComponent(this.currentComponent));
}
```
### 14.5. 面试回答模板
- 问题：动态组件和静态组件有什么区别？
- 回答示例：静态组件在编译时确定，直接通过标签引⽤（如 <Header /> ），适合结构固定的场景，性能更⾼。 动态组件通过 <component :is> 动态绑定变量，根据条件渲染不同组件（如标签⻚切换），灵活性更强。 为了优化动态组件性能，通常会结合 <keep-alive> 缓存组件状态，或使⽤异步组件按需加载。 例如，在管理后台项⽬中，我通过动态组件实现了权限适配的视图切换，结合keep-alive 缓存⾼频操作的⻚⾯，提升了⽤户体验。

## 15. Vue的SEO解决方案
- Vue 是⼀个⽤于构建⽤户界⾯的渐进式 JavaScript 框架，由于它构建的单⻚⾯应⽤（SPA）内容通常由 JavaScript 动态渲染，搜索引擎爬⾍可能难以抓取完整信息，因此需要采取⼀些 SEO 解决⽅案。以下是 5 个常⽤的 Vue SEO 解决⽅案：
### 15.1.  服务器端渲染（SSR）
- 原理：服务器端渲染是指在服务器端将 Vue 组件渲染成 HTML 字符串，再将完整的HTML ⻚⾯返回给客户端。搜索引擎爬⾍直接抓取服务器返回的 HTML ⻚⾯，就能获取到完整的⻚⾯内容。
- 实现⽅式：可以借助 Nuxt.js 框架，它基于 Vue.js，封装了许多复杂的 SSR 配置，让开发者能更便捷地实现服务器端渲染。例如，使⽤ Nuxt.js 创建项⽬后，编写⻚⾯组件，框架会⾃动处理服务器端渲染的流程。
- 优点：搜索引擎能够抓取到完整的⻚⾯内容，极⼤地有利于 SEO；同时，⾸屏加载速度快，⽤户体验好。 
- 缺点：开发和部署过程较为复杂，需要服务器具备⼀定的性能⽀持，会增加成本。
### 15.2. 静态站点⽣成（SSG）
- 原理：在项⽬构建阶段，提前⽣成所有⻚⾯的静态 HTML ⽂件。这些静态⽂件可以直接部署到静态⽂件服务器上，搜索引擎爬⾍可以轻松抓取。 
- 实现⽅式：使⽤ VitePress、VuePress 等⼯具。以 VuePress 为例，按照其规范编写⽂档和⻚⾯，执⾏构建命令，就会⽣成静态站点。 
- 优点：⽣成的静态⻚⾯加载速度快，对服务器要求低，部署简单；静态⽂件便于搜索引擎爬⾍抓取。 
- 缺点：不适合内容实时更新的场景，每次内容更新都需要重新构建和部署。
### 15.3.  预渲染（Prerendering）
- 原理：在项⽬构建过程中，针对特定的路由⽣成对应的静态 HTML ⽂件。这些⽂件会被存放在构建输出⽬录中，供搜索引擎爬⾍抓取。 
- 实现⽅式：使⽤ prerender - spa - plugin 插件。在 vue.config.js 中进⾏配置，指定需要预渲染的路由和渲染参数，构建时插件会⾃动⽣成静态 HTML ⽂件。 
- 优点：实现相对简单，不需要复杂的服务器配置；⽣成的静态⽂件可部署到任意静态⽂件服务器。 
- 缺点：只适⽤于内容不经常变动的⻚⾯；如果路由过多，构建时间会变⻓。
### 15.4.  动态元标签管理
- 原理：合理设置⻚⾯的元数据，如 title （⻚⾯标题）、 meta description （⻚⾯描述）、 meta keywords （⻚⾯关键词）等，有助于搜索引擎更好地理解⻚⾯内容，从⽽在搜索结果中更准确地展示⻚⾯。 
- 实现⽅式：使⽤ vue - meta 插件。在 Vue 组件中通过 metaInfo 属性来设置元数据，例如：
```javascript
export default {
    metaInfo: {
    title: '这是⻚⾯标题',
    meta: [
        {
            name: 'description',
            content: '这是⻚⾯的详细描述'
        },
        {
            name: 'keywords',
            content: '关键词1, 关键词2'
        }
    ]
    }
};
```
- 优点：实现简单，能有效提升⻚⾯在搜索引擎中的展示效果。 
- 缺点：只能优化元数据，⽆法解决爬⾍⽆法获取动态内容的问题，需要结合其他SEO ⽅法使⽤。
### 15.5. 结构化数据标记
- 原理：利⽤结构化数据标记（如 JSON - LD、Microdata 等）向搜索引擎提供更详细的⻚⾯内容信息，帮助搜索引擎更好地理解⻚⾯的主题和结构，进⽽在搜索结果中展示更丰富的信息。 
- 实现⽅式：在 Vue 组件中添加结构化数据标记。例如使⽤ JSON - LD：
```vue
<template>
<div>
<!-- ⻚⾯内容 -->
</div>
</template>
<script>
export default {
    mounted() {
        const script = document.createElement('script');
        script.type = 'application/ld+json';
        script.textContent = JSON.stringify({
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": "⽂章标题",
            "datePublished": "2024-01-01",
            "author": {
                "@type": "Person",
                "name": "作者姓名"
            }
        });
        document.head.appendChild(script);
    }
};
</script>
```
- 优点：可以提⾼⻚⾯在搜索结果中的展示效果，如显示富媒体搜索结果。 
- 缺点：需要开发者了解结构化数据标记的规范，不同搜索引擎对结构化数据的⽀持可能存在差异。

## 16. Vuex浏览器刷新数据丢失的解决⽅法
- 在 Vuex 中，Vuex浏览器刷新数据丢失是由于其数据存储在内存中，⽽浏览器刷新会销毁内存中的实例。这主要和 Vuex 的数据存储机制以及浏览器刷新的特性有关，下⾯为详细分析：
### 16.1. Vuex 数据存储在内存中
- 原理：Vuex 是⼀个专为 Vue.js 应⽤程序开发的状态管理模式。它采⽤集中式存储应⽤的所有组件的状态，并以相应的规则保证状态以⼀种可预测的⽅式发⽣变化。Vuex 的数据是存储在 JavaScript 对象中，⽽这个对象是保存在浏览器的内存⾥。
- 示例：
```javascript
import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
export default new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment(state) {
            state.count++;
        }
    }
});
// 在上述代码中， state ⾥的 count 数据存储在内存中。
```
### 16.2.  浏览器刷新的影响
- 原理：当⽤户刷新浏览器时，浏览器会重新加载⻚⾯。这个过程会销毁当前⻚⾯的所有 JavaScript 实例，包括 Vue 实例和 Vuex 实例。由于 Vuex 的数据存储在内存中的 JavaScript 对象⾥，随着实例的销毁，内存中的数据也会被清除。 
- 解释：刷新浏览器相当于重新启动了整个前端应⽤程序，所有之前在内存中保存的临时数据（如 Vuex 中的状态）都会丢失，然后重新初始化应⽤，Vuex 也会重新创建⼀个初始状态的实例。
- 解决方案：
  - 使⽤本地存储（LocalStorage 或 SessionStorage），本地存储可以将数据存储在浏览器中，即使⻚⾯刷新，数据依然存在。可以在 Vuex 的 mutations 或者 actions 中监听状态的变化，将数据存储到本地存储中；在应⽤初始化时，从本地存储中读取数据并恢复到 Vuex 的状态中。
```javascript
import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment(state) {
            state.count++;
            localStorage.setItem('vuexState', JSON.stringify(state));
        }
    }
});
// 初始化时从本地存储恢复数据
const savedState = localStorage.getItem('vuexState');
if (savedState) {
    store.replaceState(JSON.parse(savedState));
}
export default store;
```
  - 使⽤ Vuex 插件（如 vuex-persistedstate）,是⼀个专⻔⽤于解决 Vuex 数据持久化问题的插件。它可以⾃动将 Vuex 的状态存储到本地存储、会话存储或者其他存储引擎中，并在应⽤初始化时⾃动恢复状态。
```javascript
// 安装 npm install vuex-persistedstate
import Vue from 'vue';
import Vuex from 'vuex';
import createPersistedState from 'vuex-persistedstate';
Vue.use(Vuex);
export default new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment(state) {
            state.count++;
        },
    },
    plugins: [createPersistedState()]
});
// 通过以上分析可知，Vuex 浏览器刷新数据丢失是由于其数据存储在内存中，⽽浏览器刷新会销毁内存中的实例，不过可以采⽤本地存储或相关插件来解决数据持久化问题。
```

## 17. keep-alive
- keep-alive 是 Vue.js 提供的⼀个内置组件，⽤于缓存动态组件或路由组件，避免重复渲染，从⽽提⾼应⽤的性能和响应速度。
- keep-alive 是⼀个抽象组件，它⾃身不会渲染⼀个 DOM 元素，也不会出现在⽗组件链中。它的主要作⽤是包裹动态组件时，会缓存不活动的组件实例，⽽不是销毁它们。
### 17.1. 使用场景
- 频繁切换的组件：在⼀些需要频繁切换显示的组件场景中，⽐如 Tab 切换组件，使⽤ keep-alive 可以避免每次切换时都重新创建和销毁组件实例，提⾼切换的流畅度。 
- 需要保留状态的组件：当组件中有⼀些⽤户输⼊或滚动位置等状态，在组件隐藏后再次显示时需要保留这些状态，使⽤ keep-alive 可以很好地满⾜需求。例如，在⼀个电商应⽤中，商品列表⻚⾯滚动到⼀定位置后切换到商品详情⻚，再返回商品列表⻚时能保持之前的滚动位置。
### 17.2. 使用方式
- 包裹动态组件
```vue
<template>
<div>
    <button @click="toggleComponent">切换组件</button>
    <!-- 使⽤ keep-alive 包裹动态组件 -->
    <keep-alive>
        <component :is="currentComponent"></component>
    </keep-alive>
</div>
</template>
<script>
import ComponentA from './ComponentA.vue';
import ComponentB from './ComponentB.vue';
export default {
    components: {ComponentA, ComponentB},
    data() {
        return {
            currentComponent: 'ComponentA'
        };
    },
    methods: {
        toggleComponent() {
            this.currentComponent = this.currentComponent === 'ComponentA' ? 'ComponentB' : 'ComponentA';
        }
    }
}
</script>
```
- 结合路由使用
```vue
<template>
<div id="app">
<!-- 使⽤ keep-alive 包裹路由视图 -->
    <keep-alive>
        <router-view></router-view>
    </keep-alive>
</div>
</template>
<script>
export default {name: 'App'};
</script>
```
### 17.3. 生命周期钩子
- 当组件被 keep-alive 缓存时，其⽣命周期钩⼦会发⽣变化，除了常规的created 、 mounted 等钩⼦外，还会新增两个钩⼦：
  - activated：被缓存的组件激活时调⽤。 
  - deactivated：被缓存的组件停⽤时调⽤。
```vue
<template>
    <div>
    <!-- 组件内容 -->
    </div>
</template>
<script>
export default {
    activated() {
        console.log('组件被激活');
    },
    deactivated() {
        console.log('组件停⽤');
    }
};
</script>
```
### 17.4. 原理
- keep-alive 内部通过⼀个 cache 对象来存储缓存的组件实例，使⽤组件的 key 作为键。当组件被切换时，会先判断该组件是否已经存在于 cache 中，如果存在则直接从缓存中获取并渲染，⽽不是重新创建组件实例；如果不存在，则创建新的组件实例并添加到 cache 中。
### 17.5. 注意事项
- include 和 exclude 属性：可以使⽤ include 和 exclude 属性来指定哪些组件需要被缓存或排除缓存。 include 表示只有匹配的组件会被缓存， exclude 表示匹配的组件不会被缓存。例如：
```vue
<keep-alive include="ComponentA,ComponentB">
    <component :is="currentComponent"></component>
</keep-alive>
```
- max 属性：可以使⽤ max 属性来限制缓存组件的最⼤数量。当缓存的组件数量超过 max 时，会按照 LRU（最近最少使⽤）策略淘汰最久未使⽤的组件。例如：
```vue
<keep-alive max="3">
    <component :is="currentComponent"></component>
</keep-alive>
```

# 九、工程化
## 1. webpack 的作⽤，说说你对他的理解
- Webpack 是⼀个模块打包⼯具，它可以将各种类型的模块（如 JavaScript、CSS、图⽚等）打包成⼀个或多个⽂件，主要⽤于优化前端项⽬的资源管理和性能。
- 主要作用：
  - 模块打包：Webpack 可以处理项⽬中的各种模块依赖关系，将所有的模块打包成⼀个或多个⽂件，减少浏览器的请求次数，提⾼⻚⾯加载速度。例如，⼀个项⽬中有多个 JavaScript ⽂件和 CSS ⽂件，Webpack 可以将它们打包成⼀个或⼏个⽂件。
  - 资源处理：通过使⽤不同的 loader 和 plugin，Webpack 可以处理各种类型的资源，如将 Sass 或 Less 转换为 CSS，压缩图⽚，处理字体⽂件等。
  - 代码分割：Webpack ⽀持代码分割，可以将项⽬代码分割成多个⼩块，实现按需加载。例如，将不同⻚⾯的代码分割成不同的⽂件，当⽤户访问某个⻚⾯时，只加载该⻚⾯所需的代码。
```javascript
// 代码案例（简单配置示例）：
const path = require('path');
module.exports = {
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            }
        ]
    }
};
```
- 代码细节：
  - entry ：指定项⽬的⼊⼝⽂件，Webpack 会从该⽂件开始分析模块依赖关系。 
  - output ：指定打包后的⽂件输出路径和⽂件名。 
  - module.rules ：配置不同类型⽂件的 loader，例如对于 .css ⽂件，使⽤style-loader 和 css-loader 进⾏处理。
- 案例应⽤：在⼤型前端项⽬中，Webpack 可以帮助开发者更好地管理项⽬的资源和依赖关系，提⾼开发效率和项⽬性能。例如，在 React 或 Vue 项⽬中，通常会使⽤Webpack 进⾏打包和构建。

## 2. webpack的⽣命周期
### 2.1. 初始化阶段
- entry-option ：在 webpack 选项中的 entry 配置项处理完成之后执⾏。这个钩⼦允许你在⼊⼝配置确定后做⼀些额外的操作，⽐如动态修改⼊⼝⽂件。
```javascript
const webpack = require('webpack');
const compiler = webpack({ 
    // webpack 配置
});

compiler.hooks.entryOption.tap('MyPlugin', (context, entry)=> {
    console.log('Entry options have been processed:', entry);
    // 可以在这⾥动态修改 entry
    return true;
});
```
- after-plugins ：在所有配置的插件都被应⽤之后执⾏。此时可以对已经应⽤的插件进⾏⼀些检查或其他操作。
```javascript
compiler.hooks.afterPlugins.tap('MyPlugin', (compiler)=> {
    console.log('All plugins have been applied.');
});
```
- after-resolvers ：在解析器（resolver）设置完成之后执⾏。解析器⽤于解析模块路径，这个钩⼦可⽤于⾃定义解析器的⾏为。
```javascript
compiler.hooks.afterResolvers.tap('MyPlugin', (compiler) => {
    console.log('Resolvers have been set up.');
});
```
### 2.2. 编译阶段
- compile ：在开始编译之前触发。可以在这⾥做⼀些编译前的准备⼯作，⽐如初始化⼀些变量。
```javascript
compiler.hooks.compile.tap('MyPlugin', (params) => {
    console.log('Compilation is about to start.');
});
```
- make ：开始构建模块之前触发。这个钩⼦允许你在模块构建开始前对模块进⾏⼀些预处理。
```javascript
compiler.hooks.make.tapAsync('MyPlugin', (compilation, callback) => {
    console.log('Module building is about to start.');
    callback();
});
```
- after-compile ：编译完成之后触发。此时可以对编译后的结果进⾏⼀些检查或处理。
```javascript
compiler.hooks.afterCompile.tap('MyPlugin', (compilation) => {
    console.log('Compilation is finished.');
});
```
### 2.3. 生成资源阶段
- should-emit ：在资源⽣成之后、输出之前触发。可以在这⾥决定是否要输出这些资源。
```javascript
compiler.hooks.shouldEmit.tap('MyPlugin', (compilation) => {
    // 根据某些条件决定是否输出资源
    return true;
});
```
- emit ：在⽣成资源并即将输出到⽂件系统之前触发。可以在这⾥对⽣成的资源进⾏最后的修改。
```javascript
compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
    console.log('About to emit assets.');
    // 可以修改 compilation.assets 中的资源
    callback();
});
```
- after-emit ：在资源输出到⽂件系统之后触发。可以在这⾥做⼀些资源输出后的清理或记录⼯作。
```javascript
compiler.hooks.afterEmit.tapAsync('MyPlugin', (compilation, callback) => {
    console.log('Assets have been emitted.');
    callback();
});
```
### 2.4. 完成阶段
- done ：整个打包过程完成之后触发。可以在这⾥做⼀些打包完成后的操作，⽐如发送通知。
```javascript
compiler.hooks.done.tap('MyPlugin', (stats) => {
    console.log('Webpack build is done.');
});
```
- failed ：如果打包过程中出现错误，这个钩⼦会被触发。可以在这⾥进⾏错误处理和记录。
```javascript
compiler.hooks.failed.tap('MyPlugin', (error) => {
    console.error('Webpack build failed:', error);
});
```
- 总结：Webpack 的⽣命周期钩⼦提供了丰富的扩展点，开发者可以根据⾃⼰的需求在不同的阶段插⼊⾃定义逻辑，从⽽实现各种功能，如代码分割、资源压缩、⾃定义构建流程等。通过监听这些钩⼦，开发者能够更好地控制 Webpack 的打包过程。

## 3. Webpack 的缓存机制是如何⼯作的？
- Webpack 的缓存机制旨在提⾼构建性能，避免在每次构建时重复处理未发⽣变化的模块，从⽽显著减少构建时间。下⾯详细介绍 Webpack 缓存机制的⼯作原理、相关配置及不同类型的缓存。
### 3.0. 工作原理概述
- Webpack 缓存机制的核⼼思想是识别哪些模块在两次构建之间没有发⽣变化，然后直接复⽤之前构建的结果，⽽不是重新处理这些模块。它通过以下⼏个关键步骤来实现：
  - 记录模块信息：在⾸次构建时，Webpack 会记录每个模块的相关信息，如模块的内容哈希值、依赖关系等。 
  - 对⽐模块信息：在后续构建时，Webpack 会重新计算模块的信息，并与之前记录的信息进⾏对⽐。 
  - 复⽤缓存结果：如果某个模块的信息没有变化，Webpack 会直接使⽤之前缓存的构建结果，⽽不需要重新编译该模块。
### 3.1. 缓存类型及配置
#### 3.1.1 持久化缓存（Persistent Caching）
- 从 Webpack 5 开始，引⼊了持久化缓存机制，它将构建结果存储在磁盘上，使得在不同的构建会话之间也能复⽤缓存。
```javascript
// webpack.config.js
module.exports = {
    // 开启持久化缓存
    type: 'filesystem', // 使⽤⽂件系统存储缓存
    cache: {
        // 当 webpack 配置⽂件发⽣变化时，缓存将失效
        buildDependencies: {
            config: [__filename]
        }
    }
};
```
- 工作原理：
  - 缓存存储：Webpack 会将每个模块的编译结果和相关元数据存储在磁盘的特定⽬录中。默认情况下，缓存⽬录位于 node_modules/.cache/webpack。 
  - 缓存验证：在每次构建开始时，Webpack 会检查每个模块的内容哈希值。如果哈希值与缓存中的值相同，则认为该模块没有变化，直接使⽤缓存结果。 
  - 缓存失效：当模块的内容发⽣变化、Webpack 配置⽂件修改或buildDependencies 中指定的⽂件发⽣变化时，相关的缓存将失效，Webpack 会重新编译这些模块。
#### 3.1.2 内存缓存（In - Memory Caching）
- Webpack 在内存中也会维护⼀个缓存，⽤于在同⼀次构建过程中复⽤已经处理过的模块。
- 工作原理：
  - 模块处理：当 Webpack 处理⼀个模块时，它会⾸先检查内存缓存中是否已经存在该模块的处理结果。 
  - 缓存命中：如果命中缓存，Webpack 会直接使⽤内存中的结果，避免重复处理。这种缓存机制在处理⼤型项⽬时特别有效，因为它可以减少模块处理的时间开销。
### 3.2. 缓存与模块处理流程的结合
- 当 Webpack 开始构建项⽬时，会按照以下流程处理模块并利⽤缓存：
  - 模块解析：Webpack ⾸先解析模块的路径，确定模块的位置。在这个过程中，内存缓存可以帮助快速定位已经解析过的模块。 
  - 模块加载：对于每个模块，Webpack 会检查磁盘缓存和内存缓存。如果缓存命中， 直接使⽤缓存结果；否则，加载模块的源代码。 
  - 模块转换：如果模块需要进⾏转换（如使⽤ Babel 进⾏代码转换），Webpack 会对模块进⾏转换，并将转换结果存储在缓存中，以便后续复⽤。 
  - 模块打包：最后，Webpack 将处理好的模块打包成最终的⽂件。
### 3.3. 总结
- Webpack 的缓存机制通过持久化缓存和内存缓存的结合，有效地减少了构建时间。持久化缓存允许在不同构建会话之间复⽤缓存结果，⽽内存缓存则在同⼀次构建中提⾼了模块处理的效率。通过合理配置缓存选项，开发者可以进⼀步优化构建性能。

## 4. webpack 热更新原理常见问题及整合回答
### 4.1. 什么是 Webpack 热更新？
- Webpack 热更新（Hot Module Replacement，HMR）是⼀种在应⽤运⾏时动态替换、 添加或删除模块，⽽⽆需完全刷新整个⻚⾯的技术。它能显著提升开发效率，因为开发者修改代码后，⻚⾯能快速反映这些更改，同时保留应⽤的当前状态，⽐如表单输⼊、滚动位置等。
### 4.2. Webpack 热更新和⾃动刷新有什么区别？
- ⾃动刷新：当⽂件发⽣变化时，浏览器会重新加载整个⻚⾯，这意味着⻚⾯上的所有状态都会丢失，⽐如⽤户在表单中输⼊的数据、⻚⾯滚动位置等都需要重新设置。 
- 热更新：仅更新发⽣变化的模块，⽽不刷新整个⻚⾯，能够保留应⽤的当前状态，让开发者更⾼效地进⾏开发和调试。
### 4.3. 请简要描述 Webpack 热更新的原理。
- Webpack 热更新的原理主要分为以下⼏个步骤： 
  - 初始化与监听：项⽬启动时，Webpack 读取配置并添加热更新相关的插件和加载器，构建模块依赖图并为每个模块分配唯⼀ ID。 webpack - dev - server 启动，创建 Webpack 编译器实例，同时在浏览器和服务器之间建⽴ WebSocket 连接，⽤于实时通信。 
  - ⽂件变化检测与编译：Webpack 持续监听项⽬⽂件系统，当检测到⽂件变化时，重新编译受影响的模块，并⽣成包含变化模块信息和更新代码的补丁⽂件。 
  - 更新信息推送：服务器通过 WebSocket 连接将更新补丁的相关信息发送给浏览器。 
  - 模块更新处理：浏览器端的 HMR 运⾏时接收到消息后，下载更新补丁⽂件，找到需要更新的模块，调⽤其 update ⽅法（如果模块提供）来更新模块内容，同时尽可能保留模块的状态，更新完成后执⾏回调函数通知开发者。
### 4. WebSocket 在 Webpack 热更新中起到什么作⽤？
- WebSocket 在 Webpack 热更新中扮演着关键的通信桥梁⻆⾊。它为服务器和浏览器之间提供了实时、双向的通信通道。具体作⽤如下：
  - 实时通知：当⽂件发⽣变化，Webpack 重新编译⽣成更新补丁后，服务器可以通过WebSocket ⽴即将更新信息（如变化模块的 ID、补丁⽂件的路径等）推送给浏览器。 
  - ⾼效通信：相⽐传统的 HTTP 请求，WebSocket 连接建⽴后可以持续保持，避免了每次通信都要重新建⽴连接的开销，使得更新信息能够快速、⾼效地传输。
### 4.5. 热更新时，如何处理模块之间的依赖关系？
- Webpack 在构建模块依赖图时，会记录每个模块的依赖信息。当某个模块发⽣变化时：
  - 重新编译：Webpack 会重新编译受影响的模块及其依赖的模块。 
  - 更新依赖：在更新模块时，HMR 运⾏时会根据模块依赖图，递归地更新所有依赖该模块的其他模块，确保整个应⽤的依赖关系保持⼀致。例如，如果模块 A 依赖模块 B，当模块 B 发⽣变化时，模块 A 也会被更新以反映模块 B 的变化。
### 4.6. 如何在 Webpack 中配置热更新？
- 要在 Webpack 中配置热更新，需要完成以下两个主要步骤：
  - 开启热更新选项：在 webpack.config.js 的 devServer 配置中，将 hot 属性设置为 true ，表示开启热更新功能。示例如下：
```javascript
module.exports = {
    // 其他配置...
    devServer: {
        hot: true
    }
}
```
  - 引⼊热更新插件：在 plugins 数组中添加webpack.HotModuleReplacementPlugin 插件。示例如下：
```javascript
const webpack = require('webpack'); 
module.exports = {
    // 其他配置...
    plugins: [new webpack.HotModuleReplacementPlugin() ]
};
```
### 4.7. 在模块中如何⽀持热更新？
- 在需要⽀持热更新的模块中，可以使⽤ module.hot.accept ⽅法来处理模块更新。示例代码如下：
```javascript
// 模块代码
const someFunction = () => { console.log('This is a function.'); };
someFunction();
// ⽀持热更新
if (module.hot) {
    module.hot.accept(() => {
        // 模块更新后的处理逻辑
        console.log('Module updated!');
    });
}
// 在上述代码中， if (module.hot) ⽤于检查当前环境是否⽀持热更新， module.hot.accept ⽅法中的回调函数会在模块更新时被执⾏。
```
### 4.8. Webpack 热更新不⽣效可能有哪些原因
- 配置错误：未正确配置 devServer.hot 为 true 或未引⼊ HotModuleReplacementPlugin 插件。 
- 模块代码问题：模块中没有正确使⽤ module.hot.accept ⽅法处理更新，或者处理逻辑存在错误。 
- 版本兼容性问题：Webpack、 webpack - dev - server 以及相关加载器和插件的版本不兼容，可能导致热更新功能⽆法正常⼯作。 
- ⽂件监听问题：某些环境下，⽂件系统的监听可能出现问题，导致 Webpack ⽆法及时检测到⽂件变化。可以尝试调整 watchOptions 配置来解决。
### 4.9. 如何调试 Webpack 热更新问题？
- 查看控制台⽇志：在浏览器和终端的控制台查看详细的⽇志信息，了解热更新过程中是否有错误或警告信息。 
- 检查配置⽂件：仔细检查 webpack.config.js ⽂件，确保热更新相关的配置正确⽆误。 
- 使⽤调试⼯具：可以使⽤浏览器的开发者⼯具（如 Chrome DevTools）来调试模块更新的过程，查看更新补丁的下载和应⽤情况。 
- 版本检查：确保 Webpack、 webpack - dev - server 以及相关插件的版本兼容。可以尝试更新到最新稳定版本或回退到已知兼容的版本。

## 5. WebSocket通信实现模块更新的⽅式
### 5.1. 建⽴ WebSocket 连接
- 在项⽬启动阶段，当使⽤ webpack-dev-server 且开启热更新功能（ hot: true ）时， webpack-dev-server 会在浏览器和服务器之间建⽴ WebSocket 连接。
  - 服务器端： webpack-dev-server 启动⼀个 WebSocket 服务器，等待浏览器的连接请求。这个服务器会持续监听⽂件系统的变化，并在⽂件更新时准备发送更新信息。 
  - 浏览器端：浏览器中的 HMR 运⾏时（Hot Module Replacement Runtime）会主动发起 WebSocket 连接请求，与服务器建⽴双向通信通道。⼀旦连接成功，双⽅就可以实时交换数据。
### 5.2. ⽂件变化监听与编译
- ⽂件监听：Webpack 会对项⽬中的⽂件系统进⾏监听，当检测到⽂件发⽣变化时， 会重新编译受影响的模块。 
- ⽣成更新补丁：重新编译后，Webpack 会⽣成⼀个更新补丁，这个补丁包含了发⽣变化的模块信息（如模块 ID、更新后的代码等）以及更新所需的元数据。
### 5.3. 服务器发送更新消息
- 封装消息：服务器将⽣成的更新补丁信息封装成特定格式的消息，通常包含变化模块的 ID 列表、补丁⽂件的 URL 等。
- 发送消息：通过已建⽴的 WebSocket 连接，服务器将封装好的更新消息发送给浏览器。例如，消息可能是⼀个 JSON 对象，如下所示：其中， type 表示消息类型为热更新， hash 是本次更新的唯⼀标识， modules 数组列出了发⽣变化的模块及其对应的补丁⽂件 URL。
```json
{
"type": "hot-update",
"hash": "123456abcdef",
"modules": [
  {
    "id": 1,
    "url": "/hot-update/1.js"
  }
]}
```
### 5.4. 浏览器接收并处理更新消息
- 接收消息：浏览器端的 HMR 运⾏时通过 WebSocket 接收到服务器发送的更新消息。 
- 解析消息：对收到的消息进⾏解析，提取出变化模块的信息和补丁⽂件的 URL。 
- 下载补丁⽂件：根据补丁⽂件的 URL，浏览器使⽤ HTTP 请求下载更新补丁⽂件。 
- 更新模块： 
  - 查找模块：HMR 运⾏时根据模块 ID 找到需要更新的模块。 
  - 替换模块：⽤下载的更新补丁⽂件中的代码替换原模块的代码。 
  - 处理依赖：递归地更新所有依赖该模块的其他模块，确保整个应⽤的依赖关系保持⼀致。 
  - 执⾏回调：如果模块中定义了 module.hot.accept ⽅法，在模块更新完成后，会执⾏该⽅法中的回调函数，开发者可以在回调函数中编写⼀些额外的处理逻辑，如重新初始化组件状态等。
### 5.5. 模块更新完成通知
- 执⾏回调：模块更新完成后，HMR 运⾏时会执⾏⼀些内置的回调函数，同时也会触发开发者在 module.hot.accept 中定义的回调函数，通知开发者模块已经成功更新。 
- 界⾯更新：浏览器会根据更新后的模块代码，动态更新⻚⾯上的相关内容，实现模块的热更新效果，且⽆需刷新整个⻚⾯。
> 通过以上基于 WebSocket 通信的⽅式，Webpack 实现了模块的实时更新，⼤⼤提⾼了开发效率。

## 6. 前端工程化
- 端⼯程化是指将软件开发的⼯程⽅法应⽤于前端开发，通过⼀系列⼯具、流程和规范来提⾼前端开发的效率、质量和可维护性。
- 主要方面：
  - 模块化开发：将项⽬拆分成多个⼩的模块，每个模块具有独⽴的功能和职责，提⾼代码的复⽤性和可维护性。例如，使⽤ ES6 的模块语法（ import 和 export ）或 CommonJS 规范进⾏模块开发。 
  - ⾃动化构建：使⽤构建⼯具（如 Webpack、Gulp 等）⾃动完成代码的编译、 打包、压缩、合并等任务，减少⼈⼯操作，提⾼开发效率。 
  - 代码规范：制定统⼀的代码规范和⻛格指南，如 ESLint、Prettier 等⼯具可以帮助开发者检查和修复代码中的语法错误和⻛格问题，保证代码的⼀致性。 
  - 版本控制：使⽤版本控制系统（如 Git）来管理项⽬的代码，⽅便团队协作和代码的回溯、分⽀管理等。 
  - 测试和部署：建⽴⾃动化测试流程，使⽤测试框架（如 Jest、Mocha 等）对代码进⾏单元测试、集成测试等，确保代码的质量。同时，实现⾃动化部署，将代码部署到⽣产环境。
- 案例应⽤：在⼀个多⼈协作的前端项⽬中，通过前端⼯程化的⽅法，可以规范开发流程，提⾼团队协作效率，减少代码冲突和错误，同时提⾼项⽬的可维护性和性能。

## 7. vite 和 webpack 的区别
- Vite 和 Webpack 都是前端构建⼯具，但它们的实现原理和适⽤场景有所不同。
- 启动速度
  - Vite：基于原⽣ ES 模块，在开发环境下采⽤按需加载的⽅式，不需要像Webpack 那样对整个项⽬进⾏打包，因此启动速度⾮常快。当修改代码时，Vite 可以实现快速的热更新，只更新修改的模块。 
  - Webpack：在启动时需要对整个项⽬进⾏打包，分析模块依赖关系，因此启动速度相对较慢，尤其是在⼤型项⽬中。
- 构建⽅式：
  - Vite：开发环境下利⽤浏览器的原⽣ ES 模块⽀持，直接在浏览器中加载模块。⽣产环境下使⽤ Rollup 进⾏打包，将代码打包成适合⽣产环境的⽂ 件。 
  - Webpack：使⽤⾃⼰的打包机制，通过 loader 和 plugin 处理各种类型的模块，将所有模块打包成⼀个或多个⽂件。
- 配置复杂度
  - Vite：配置相对简单，默认提供了很多常⽤的配置，对于⼩型项⽬可以快速上⼿。例如，只需要配置⼊⼝⽂件和输出路径等基本信息。 
  - Webpack：配置相对复杂，需要根据项⽬的需求配置各种 loader 和 plugin，对于初学者来说有⼀定的学习成本。
- 适用场景
  - Vite：适⽤于⼩型项⽬和快速迭代的项⽬，能够提供快速的开发体验。例如，⼀些简单的静态⽹站、原型项⽬等。 
  - Webpack：适⽤于⼤型项⽬和复杂的项⽬，具有强⼤的功能和丰富的插件⽣态系统。例如，企业级的 Web 应⽤、⼤型电商⽹站等。

## 8. Vite相较于Webpack的优势
### 8.1. 开发服务器启动速度快
- Vite 原理：Vite 利⽤现代浏览器原⽣ ES 模块的⽀持，在开发环境下⽆需打包，直接启动⼀个开发服务器。当浏览器请求模块时，Vite 会按需编译并提供这些模块。 例如，在⼀个⼤型项⽬中，Vite 可以在瞬间启动开发服务器，让开发者⽴即开始编码和调试。 
- Webpack 情况：Webpack 在启动开发服务器时，需要对整个项⽬进⾏打包处理， 将所有的模块打包成⼀个或多个⽂件。对于⼤型项⽬，这个过程可能会⾮常耗时，有时甚⾄需要等待⼏⼗秒到⼏分钟。
### 8.2. 热更新速度快
- Vite 原理：Vite 的热更新（HMR）是基于 ES 模块的，当⼀个模块发⽣变化时， Vite 可以精确地更新该模块，⽽不需要重新构建整个应⽤。这使得热更新的速度极快，⼏乎是瞬间完成，开发者可以⽴即看到代码修改后的效果。 
- Webpack 情况：Webpack 的热更新需要重新构建受影响的模块及其依赖项，对于复杂的项⽬，热更新可能会有明显的延迟，影响开发效率。
### 8.3. 按需编译
- Vite 原理：Vite 采⽤按需编译的⽅式，只有当浏览器请求某个模块时，才会对该模块进⾏编译。这种⽅式减少了不必要的编译⼯作，提⾼了开发效率。例如，在开发⼀个包含⼤量⻚⾯的应⽤时，开发者可能只关注当前正在开发的⻚⾯，Vite 只会编译该⻚⾯所依赖的模块。 
- Webpack 情况：Webpack 在开发环境下通常会对整个项⽬进⾏预编译，即使某些模块在当前开发过程中并不会被使⽤，这会浪费⼀定的时间和资源。
### 8.4. 简单的配置
- Vite 原理：Vite 的配置相对简单，对于⼤多数项⽬，只需要进⾏少量的配置即可满⾜需求。它提供了⼀些默认的配置选项，并且⽀持使⽤ JavaScript 或 TypeScript进⾏配置。例如，在创建⼀个 Vue 项⽬时，Vite 只需要⼏⾏配置就可以完成基本的项⽬搭建。 
- Webpack 情况：Webpack 的配置相对复杂，需要了解⼤量的概念和配置项，如loader、plugin 等。对于初学者来说，配置 Webpack 可能是⼀个挑战，⽽且在项⽬规模增⼤时，配置⽂件会变得越来越复杂，难以维护。
### 8.5. 原⽣⽀持 ES 模块
- Vite 原理：Vite 原⽣⽀持 ES 模块，这使得它能够更好地与现代 JavaScript ⽣态系统集成。开发者可以直接使⽤ ES 模块的语法进⾏开发，⽆需额外的转换。 
- Webpack 情况：Webpack 虽然也⽀持 ES 模块，但在处理 ES 模块时需要使⽤特定的 loader 进⾏转换，这增加了配置的复杂性。
### 8.6. 对不同框架的支持友好
- Vite 原理：Vite 对多种前端框架（如 Vue、React、Svelte 等）提供了良好的⽀持，并且针对不同框架有专⻔的插件和模板。开发者可以快速搭建不同框架的项⽬，并且享受到 Vite 的⾼性能开发体验。 
- Webpack 情况：Webpack 虽然也可以⽤于各种前端框架的开发，但需要针对不同的框架进⾏相应的配置和调整，相对来说不够便捷。

## 9. vite项目怎么部署到线上
- 将 Vite 项⽬部署到线上需要完成项⽬的构建、服务器配置和⽂件上传等步骤，确保项⽬在⽣产环境中能够正常运⾏。
- 部署步骤：
  - 项⽬构建：在本地项⽬根⽬录下运⾏ npm run build 命令，Vite 会根据配置⽂件将项⽬打包成⽣产环境可⽤的⽂件，通常会⽣成⼀个 dist ⽬录，包含打包后的 HTML、CSS、JavaScript 等⽂件。
  - 服务器选择：选择合适的服务器来部署项⽬，常⻅的服务器有 Nginx、Apache等。可以选择云服务器（如阿⾥云、腾讯云等）或⾃⼰搭建服务器。
```java
// 服务器配置， Nginx 配置示例：
server {
    listen 80;
    server_name yourdomain.com;
    root /path/to/your/dist;
    index index.html;
    location / {
        try_files $uri $uri/ /index.html;
    }
}
// 上述配置中，`listen` 指定监听的端⼝，`server_name` 指定域名，`root` 指定项⽬打包后的⽂件路径，`location` 配置⽤于处理路由，确保单⻚应⽤的路由正常⼯作。
// ⽂件上传：将本地 `dist` ⽬录下的所有⽂件上传到服务器的指定⽬录。可以使⽤FTP、SFTP 等⼯具进⾏⽂件上传。
// 域名配置：如果使⽤⾃定义域名，需要将域名解析到服务器的 IP 地址。在域名管理平台上添加相应的 DNS 记录。
```
- 案例应⽤：将⼀个使⽤ Vite 构建的 React 或 Vue 单⻚应⽤部署到线上，让⽤户可以通过域名访问该应⽤。

## 10. 进程之间如何进⾏通信？说⼀下应⽤场景？
- 进程间通信（IPC，Inter - Process Communication）是指在不同进程之间传播或交换信息的机制。常⻅的进程间通信⽅式有以下⼏种：
  - 管道（Pipe）：管道是⼀种半双⼯的通信⽅式，数据只能在⼀个⽅向上流动，通常⽤于⽗⼦进程之间的通信。管道本质上是⼀个内核缓冲区，写⼊管道的数据会被内核缓存，读取进程可以从管道中读取数据
  - 消息队列（Message Queue）：消息队列是⼀种消息的链表，存放在内核中并由消息队列标识符标识。消息队列允许⼀个或多个进程向它写⼊或读取消息，进程可以按照⼀定的规则从消息队列中获取消息，⽽不需要与其他进程保持同步。
  - 共享内存（Shared Memory）：共享内存是指多个进程可以访问同⼀块物理内存区域，这是最快的⼀种 IPC ⽅式。进程可以直接对共享内存进⾏读写操作，避免了数据的复制，但需要使⽤同步机制（如信号量）来避免竞态条件。
  - 信号量（Semaphore）：信号量是⼀种计数器，⽤于控制对共享资源的访问。它可以⽤来实现进程之间的同步和互斥，通过 P（等待）和 V（释放）操作来改变信号量的值。
  - 套接字（Socket）：套接字可以实现不同主机之间的进程通信，也可以⽤于同⼀主机上的进程通信。它提供了⼀种⽹络编程接⼝，通过⽹络协议进⾏数据传输。
- 应用场景：
  - 管道：常⽤于 shell 脚本中，例如将⼀个命令的输出作为另⼀个命令的输⼊，如 ls| grep test。
  - 消息队列：适⽤于需要异步通信的场景，如任务调度系统，⽣产者进程将任务消息放⼊消息队列，消费者进程从队列中取出任务进⾏处理。
  - 共享内存：在需要频繁交换⼤量数据的场景中⾮常有⽤，如图形处理、数据库管理系统等，多个进程可以同时访问共享内存中的数据。
  - 信号量：⽤于解决进程间的同步和互斥问题，如多个进程同时访问⼀个共享资源时，使⽤信号量来保证资源的互斥访问。
  - 套接字：⼴泛应⽤于⽹络编程，如 Web 服务器与客户端之间的通信、即时通讯软件等。
- 代码案例（Python 中使⽤管道进⾏进程间通信）
```python
import os
# 创建管道
r, w = os.pipe()
# 创建⼦进程
pid = os.fork()
if pid == 0:
    # ⼦进程关闭写端
    os.close(w)
    # 从管道读取数据
    r = os.fdopen(r)
    print(f"Child process received: {r.read()}")
    r.close()
else:
    # ⽗进程关闭读端
    os.close(r)
    w = os.fdopen(w, 'w')
    # 向管道写⼊数据
    w.write("Hello from parent process!")
    w.close()
    # 等待⼦进程结束
    os.wait()
```
- 解析：在上述代码中，⾸先使⽤ os.pipe() 创建了⼀个管道，返回两个⽂件描述符 r 和 w 分别⽤于读取和写⼊。然后使⽤ os.fork() 创建了⼀个⼦进程。⽗进程关闭读端，向管道写⼊数据；⼦进程关闭写端，从管道读取数据。通过这种⽅式实现了⽗⼦进程之间的通信。

## 11. 前端性能优化
- 前端性能优化的核⼼⽬标是提⾼⽹⻚的加载速度和响应速度，提升⽤户体验。主要从以下⼏个⽅⾯进⾏优化：
  - 压缩代码：对 HTML、CSS、JavaScript 代码进⾏压缩，去除不必要的空格、注释和换⾏符，减少⽂件⼤⼩，从⽽加快⽂件的下载速度。 
  - 合并⽂件：将多个 CSS ⽂件和 JavaScript ⽂件合并成⼀个⽂件，减少浏览器的请求次数，因为每次请求都有⼀定的开销。 
  - 图⽚优化：选择合适的图⽚格式（如 JPEG、PNG、WebP），对图⽚进⾏压缩，降低图⽚的分辨率和质量，同时可以采⽤图⽚懒加载技术，只在图⽚进⼊可视区域时才加载，减少初始加载的资源量。 
  - 缓存机制：利⽤浏览器的缓存机制，设置合理的缓存策略，如使⽤ Cache - Control 、 Expires 等 HTTP 头信息，让浏览器缓存静态资源，避免重复下载。 
  - CDN（内容分发⽹络）：使⽤ CDN 来分发静态资源，CDN 节点分布在全球各地， 可以将资源缓存到离⽤户最近的节点，减少数据传输的距离，提⾼资源的加载速 度。 
  - 优化 DOM 操作：减少 DOM 操作的次数，因为 DOM 操作会触发浏览器的重排和重绘，影响性能。可以使⽤⽂档⽚段（DocumentFragment）来批量操作 DOM，减少重排和重绘的次数。 
- 应⽤场景 
  - 电商⽹站：⽤户在浏览商品列表和详情⻚时，希望⻚⾯能够快速加载，因此需要进⾏前端性能优化，提⾼⽤户的购物体验。 
  - 新闻资讯⽹站：⼤量的图⽚和⽂章内容需要快速加载，以满⾜⽤户获取信息的需求，性能优化可以提⾼⽤户的留存率。 
  - 在线游戏：需要实时响应⽤户的操作，优化前端性能可以减少游戏的卡顿现象，提 ⾼游戏的流畅度。
- 代码案例（使⽤ Gulp 进⾏代码压缩和合并）
```javascript
const gulp = require('gulp');
const uglify = require('gulp-uglify');
const concat = require('gulp-concat');
const cssnano = require('gulp-cssnano');
// 压缩和合并 JavaScript ⽂件
gulp.task('scripts', function () {
    return gulp.src('src/js/*.js')
        .pipe(concat('all.js'))
        .pipe(uglify())
        .pipe(gulp.dest('dist/js'));
});
// 压缩和合并 CSS ⽂件
gulp.task('styles', function () {
    return gulp.src('src/css/*.css')
        .pipe(concat('all.css'))
        .pipe(cssnano())
        .pipe(gulp.dest('dist/css'));
});
// 默认任务
gulp.task('default', gulp.parallel('scripts', 'styles'));
```
- 解析：上述代码使⽤ Gulp 构建⼯具，通过 gulp-uglify 插件对 JavaScript ⽂件进⾏压缩， gulp-concat 插件将多个 JavaScript ⽂件合并成⼀个⽂件， gulp-cssnano 插件对 CSS ⽂件进⾏压缩和合并。最后定义了⼀个默认任务，同时执⾏ JavaScript 和 CSS 的处理任务。

## 12. JS和客户端交互方法
### 12.1. 原⽣WebView注⼊对象交互
- 在iOS和Android等客户端的WebView（⽤于在移动应⽤中显示⽹⻚内容的组件）中，可以向⽹⻚注⼊原⽣对象。这样在⽹⻚中的JavaScript代码就能直接调⽤这些原⽣对象的⽅法，实现与客户端的交互。
- Android端
```java
// java代码
webView.addJavascriptInterface(new JsInterface(), "AndroidObj");
public class JsInterface {
    @JavascriptInterface
    public void showToast(String message) {
        Toast.makeText(MainActivity.this, message,
        Toast.LENGTH_SHORT).show();
    }
}
```
```javascript
// 在JavaScript中调用
// 调⽤Android注⼊的对象⽅法
window.AndroidObj.showToast('Hello from JS');
```
- IOS端
```C
// Objective - C代码
WKUserContentController *userContentController =[[WKUserContentController alloc] init];
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.userContentController = userContentController;
WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];
[userContentController addScriptMessageHandler:self name:@"iOSObj"];
- (void)userContentController:(WKUserContentController*)userContentController didReceiveScriptMessage:(WKScriptMessage*)message {
    if ([message.name isEqualToString:@"iOSObj"]) {
        NSString *msg = message.body;
        NSLog(@"Received message from JS: %@", msg);
    }
}
```
```javascript
// 调⽤iOS注⼊的对象⽅法
window.webkit.messageHandlers.iOSObj.postMessage('Hello from JS');
```
### 12.2. 通过URL Scheme交互
- URL Scheme是⼀种类似于URL的链接格式，⽤于在应⽤间进⾏跳转和传递数据。JavaScript可以通过修改当前⻚⾯的URL为特定的URL Scheme，客户端的WebView捕获到这个URL Scheme后，进⾏相应的处理。
```javascript
// 在JavaScript中触发URL Scheme：
function callNativeFunction() {
    window.location.href = 'myapp://action?param1=value1&param2=value2';
}
```
- 客户端捕获URL Scheme并处理：
- Android端：在WebViewClient的 shouldOverrideUrlLoading ⽅法中拦截URL Scheme进⾏处理。
```java
webView.setWebViewClient(new WebViewClient() {
@Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        if (url.startsWith("myapp://")) {
        // 解析URL参数并处理
            return true;
        }
    return super.shouldOverrideUrlLoading(view, url);
    }
});
```
- iOS端：在WKUIDelegate的 webView:decidePolicyForNavigationAction:decisionHandler: ⽅法中拦截URL Scheme进⾏处理。
```C
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:
(WKNavigationAction *)navigationAction decisionHandler:(void (^)
(WKNavigationActionPolicy))decisionHandler {
    NSURL *url = navigationAction.request.URL;
    if ([url.scheme isEqualToString:@"myapp"]) {
        // 解析URL参数并处理
        decisionHandler(WKNavigationActionPolicyCancel);
        return;
    }
decisionHandler(WKNavigationActionPolicyAllow);
}
```
### 12.3. 消息传递机制（如postMessage）
- HTML5提供了 window.postMessage ⽅法，可⽤于在不同窗⼝或框架之间传递消息。在客户端WebView和⽹⻚之间也能借助这个机制进⾏通信。客户端可以监听⽹⻚发送的消息，⽹⻚也能监听客户端发送的消息。
```javascript
// 网页向客户端发送消息
window.postMessage({type: 'share', data: 'Some share data'},'*');
// 客户端监听消息（以Android为例）：
webView.evaluateJavascript("window.addEventListener('message',function(event) { console.log('Received message from client: ' +JSON.stringify(event.data)); });", null);
```

## 13. 封装axios接⼝与⽹关的调⽤，包装请求参数、处理错误码、添加接⼝签名、⽩名单功能
### 13.1. 项目准备：⾸先，确保你已经安装了 Axios，如果使用npm，可以npm install axios
### 13.2. 封装Axios
- 创建⼀个 axiosWrapper.js ⽂件，⽤于封装 Axios 并实现所需功能。
```javascript
import axios from 'axios';
import CryptoJS from 'crypto-js'; // ⽤于⽣成签名，可根据实际需求替换为其他加密库
// 配置信息
const config = {
    baseURL: 'https://your-gateway-url.com', // ⽹关基础 URL
    timeout: 5000, // 请求超时时间
    secretKey: 'your-secret-key', // ⽤于接⼝签名的密钥
    whiteList: ['/public/api1', '/public/api2'] // ⽩名单接⼝列表
};
// 创建 Axios 实例
const instance = axios.create({
    baseURL: config.baseURL,
    timeout: config.timeout
})
// ⽣成接⼝签名
const generateSignature = (data, secretKey) => {
    const sortedKeys = Object.keys(data).sort();
    let signStr = '';
    sortedKeys.forEach(key => {
        signStr += `${key}=${data[key]}&`
    });
    signStr += `secret=${secretKey}`;
    return CryptoJS.MD5(signStr).toString();
}
// 请求拦截器
instance.interceptors.request.use(config => {
    const { url, data = {} } = config
    // 检查是否在白名单
    const isInWhiteList = config.whiteList.some(item => url.includes(item))
    if(isInWhiteList) {
        // 添加公共参数
        const timestamp = new Date().getTime();
        const newData = { ...data, timestamp }
        // ⽣成签名
        const signature = generateSignature(newData, config.secretKey);
        newData.signature = signature;
        config.data = newData;
    }
    return config;
}, error => {
    console.error('请求拦截器错误:', error);
    return Promise.reject(error);
})
// 响应拦截器
instance.interceptors.response.use(response => {
    const { data } = response;
    // 处理错误码
    if(data.code !== 200) {
        switch (data.code) {
            case 401:
                console.error('未授权，请重新登录');
                break;
            case 403:
                console.error('禁⽌访问');
                break;
            case 500:
                console.error('服务器内部错误');
                break;
            default:
                console.error(`未知错误码: ${data.code}`);
        }
        return Promise.reject(new Error(data.message || '请求失败'));
    }
    return data;
}, error => {
    console.error('响应拦截器错误:', error);
    return Promise.reject(error);
})
// 封装请求方法
const request = {
    get(url, params = {}) {
        return instance.get(url, { params });
    },
    post(url, data= {}) {
        return instance.post(url, data)
    },
    put(url, data = {}) {
        return instance.put(url, data);
    },
    delete(url, params = {}) {
        return instance.delete(url, { params });
    }
}
export default request;
```
### 13.3. 使用封装的Axios
- 在需要调⽤接⼝的地⽅引⼊封装好的 request 对象并使⽤。
```javascript
import request from './axiosWrapper';
// 示例：发送GET请求
request.get('/api/getData', {id: 1}).then(response => {
    console.log('请求成功:', response);
}).catch(error => {
    console.error('请求失败:', error);
})
// 示例：发送POST请求
request.post('/api/submitData', { name: 'John', age: 30 })
    .then(response => {
        console.log('请求成功:', response);
    })
    .catch(error => {
        console.error('请求失败:', error);
    });
```
- 代码解释
  - 配置信息：定义了⽹关的基础 URL、超时时间、签名密钥和⽩名单接⼝列表。 
  - Axios 实例：使⽤ axios.create 创建⼀个 Axios 实例，并设置基础 URL 和超时时间。 
  - 请求拦截器： 
    - 检查请求的 URL 是否在⽩名单中。 
    - 如果不在⽩名单，添加公共参数（如时间戳），并⽣成接⼝签名。 
    - 将签名和公共参数添加到请求数据中。
  - 响应拦截器： 
    - 检查响应数据的错误码。 
    - 根据不同的错误码进⾏相应的处理，并抛出错误。 
  - 封装请求⽅法：提供 get、 post、 put 和 delete ⽅法，⽅便调⽤。 
  - 通过以上步骤，你可以实现⼀个功能完善的 Axios 封装，⽤于与⽹关进⾏接⼝调⽤。
### 13.4. 全局挂载 Axios 实例（可选）
- 如果你希望在所有 Vue 组件中都能⽅便地使⽤ Axios 实例，可以将其全局挂载到 Vue 实例上。
```javascript
// main.js
import Vue from 'vue';
import App from './App.vue';
import service from './axios';
// 全局挂载 Axios 实例
Vue.prototype.$http = service;
new Vue({ 
    render: h => h(App)
}).$mount('#app');
```
- 在 Vue 组件中使⽤全局挂载的 Axios 实例：
```vue
<template>
<div>
  <button @click="fetchData">获取数据</button>
</div>
</template>
<script>
  export default {
    methods: {
      async fetchData() {
        try {
          const response = await this.$http.get('/data');
          console.log('请求成功:', response);
        } catch (error) {
        // 错误已在拦截器中处理
        }
      }
    }
  };
</script>
```

## 14. Tree Shaking原理
- Tree Shaking 是⼀种在打包⼯具（如 Webpack、Rollup 等）中⽤于消除未使⽤代码（dead code）的技术，它可以显著减⼩打包后的⽂件体积，提⾼应⽤的加载性能。下⾯将详细介绍如何进⾏ Tree Shaking 以及其⼯作原理。
### 14.1. 如何进行Tree Shaking
- 使用ES6模块语法：Tree Shaking 依赖于 ES6 模块的静态结构特性，即模块之间的导⼊和导出关系在编译时是确定的。因此，要确保你的代码使⽤ ES6 的 import 和 export 语法，⽽不是CommonJS 的 require 和 module.exports。
```javascript
// utils.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
// main.js
import { add } from './utils.js';
console.log(add(1, 2));
```
- 配置打包工具，以webpack为例，需要进行以下配置
  - 设置mode为production：在 Webpack 4 及以上版本中，将 mode 设置为 production 会⾃动开启⼀些优化，包括 Tree Shaking。
```javascript
// webpack.config.js
module.exports = {
    mode: 'production',
    // 其他配置...
};
```
  - 确保 package.json 中的 sideEffects 字段正确设置： sideEffects 字段⽤于告诉打包⼯具哪些⽂件有副作⽤（即执⾏代码会产⽣除导出变量之外的其他影响，如修改全局变量、执⾏⼀些初始化操作等）。如果你的代码没有副作⽤，可以将 sideEffects 设置为 false ，这样打包⼯具可以更激进地进⾏ Tree Shaking。
```json
{
    "name": "my-app",
    "sideEffects": false
}
```
  - 如果部分文件有副作用，可以列出这些文件的路径：
```json
{
    "name": "my-app",
    "sideEffects": [
        "./src/some-file-with-side-effects.js",
        "*.css"
    ]
}
```
- 使⽤⽀持 Tree Shaking 的第三⽅库，选择使⽤以 ES6 模块形式发布的第三⽅库，这样才能保证打包⼯具可以对其进⾏ Tree Shaking。例如，Lodash 提供了⽀持 Tree Shaking 的版本 lodash-es 。
```javascript
// 使⽤ lodash-es 进⾏ Tree Shaking
import { cloneDeep } from 'lodash-es';
const obj = { a: 1 }
const clonedObj = cloneDeep(obj);
```
### 14.2. Tree Shaking的原理
- 1.静态分析：Tree Shaking 的核⼼是对 ES6 模块进⾏静态分析，即在不执⾏代码的情况下，分析模块之间的导⼊和导出关系。打包⼯具会解析模块⽂件，识别出哪些变量被导出，哪些变量被导⼊和使⽤。例如，对于以下代码：
```javascript
// utils.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
// main.js
import { add } from './utils.js';
console.log(add(1, 2));
// 打包⼯具在静态分析时会发现， main.js 只导⼊并使⽤了 utils.js 中的 add 函数，⽽ subtract 函数没有被使⽤。
```
- 2.标记未使用的代码：在静态分析完成后，打包⼯具会标记出那些未被使⽤的导出变量和代码块。在上述例⼦中， subtract 函数会被标记为未使⽤。
- 3.消除未使用的代码：最后，打包⼯具在⽣成最终的打包⽂件时，会移除那些被标记为未使⽤的代码，从⽽实现 Tree Shaking 的效果。经过 Tree Shaking 处理后，最终的打包⽂件中不会包含subtract 函数的代码。
- 需要注意的是，Tree Shaking 只能处理 ES6 模块中静态可分析的代码，对于动态导⼊（如 import() ）和⼀些复杂的运⾏时依赖，Tree Shaking 的效果可能会受到限制。此外，代码中的副作⽤也会影响 Tree Shaking 的结果，因此需要正确设置 sideEffects 字段。


## 15. 前端工程化-补
- 前端⼯程化是指运⽤⼯程的理念、⽅法和技术来管理和组织前端开发流程，将前端开发从传统的⼿⼯式、零散式开发转变为规范化、标准化、⾃动化的开发模式，以提⾼开发效率、保证代码质量、降低维护成本。
### 15.1. 项目架构设计
- 分层架构设计
  - 视图层：负责⻚⾯的展示，如使⽤ Vue、React 等前端框架构建组件化的视图。以 Vue 为例，创建⼀个个独⽴的 Vue 组件，每个组件负责特定的 UI 部分，提⾼代码的可维护性和复⽤性。 
  - 业务逻辑层：处理业务逻辑，将视图层和数据层解耦。例如在⼀个电商项⽬中，商品列表的筛选、排序等逻辑可以放在业务逻辑层处理。 
  - 数据访问层：负责与后端 API 进⾏交互，获取和处理数据。可以使⽤ Axios 等⼯具发送 HTTP 请求，封装请求逻辑，⽅便统⼀管理。
- 目录结构规范
  - 制定清晰的⽬录结构，如 src ⽬录存放源代码， public ⽬录存放静态资源， build 或 dist ⽬录存放打包后的⽂件。 
  - 在 src ⽬录下，可以进⼀步细分，如 components 存放组件， views 存放⻚⾯视图， store 存放状态管理代码（如果使⽤ Vuex 或 Redux）， utils 存放⼯具函数等。
### 15.2. 模块化开发
- 代码模块化：将代码拆分成多个独⽴的模块，每个模块具有单⼀的功能和职责，提⾼代码的可复⽤性和可维护性。例如使⽤ ES6 的 import 和 export 语法实现JavaScript 模块的导⼊和导出。 
- 样式模块化：通过 CSS Modules、Sass、Less 等技术实现样式的模块化，避免样式冲突。例如在 CSS Modules 中，每个 CSS ⽂件都是⼀个独⽴的模块，类名会被⾃动转换为唯⼀的哈希值。
### 15.3. 自动化构建
- 打包⼯具：使⽤ Webpack、Rollup、Parcel 等打包⼯具将多个模块打包成⼀个或多个⽂件，减少浏览器的请求次数，提⾼⻚⾯加载速度。例如 Webpack 可以处理各种类型的模块，如 JavaScript、CSS、图⽚等，并对它们进⾏优化和处理。 
- ⾃动化任务：借助 Gulp、Grunt 等⼯具实现⾃动化任务，如代码压缩、⽂件合并、图⽚优化、代码检查等。例如使⽤ Gulp 可以⾃动压缩 CSS 和 JavaScript ⽂件，减少⽂件体积。
### 15.4. 版本控制与团队协作
- 版本控制系统：使⽤ Git 等版本控制系统对代码进⾏管理，⽅便团队成员协作开发、跟踪代码变更和回滚历史版本。例如团队成员可以在不同的分⽀上进⾏开发，完成后再合并到主分⽀。 
- 代码审查：建⽴代码审查机制，团队成员对提交的代码进⾏审查，确保代码符合规范和质量要求。例如在 GitHub 上可以通过 Pull Request 进⾏代码审查。
### 15.5. 测试与部署
- 单元测试：编写单元测试⽤例，对代码的各个模块进⾏独⽴测试，确保代码的正确性。常⽤的测试框架有 Jest、Mocha 等。例如使⽤ Jest 可以对 JavaScript 函数进⾏单元测试。 
- 集成测试：对多个模块进⾏集成测试，验证它们之间的协作是否正常。 
- ⾃动化部署：使⽤ Jenkins、GitLab CI/CD 等⼯具实现⾃动化部署，将代码部署到⽣产环境。例如当代码推送到 Git 仓库时，⾃动触发部署流程，将代码部署到服务器上。

## 16. 前端模块化
- 前端模块化是指将⼀个复杂的前端应⽤拆分成多个独⽴的、可复⽤的模块，每个模块具有明确的功能和职责，模块之间通过特定的⽅式进⾏交互和通信。
### 16.1. 早期的模块化尝试
- ⽂件划分：早期开发者通过将不同功能的代码放在不同的⽂件中，实现简单的模块化。但这种⽅式存在全局变量污染、依赖管理困难等问题。 
- 命名空间模式：通过创建全局对象，将相关的函数和变量挂载到该对象上，避免全局变量冲突。例如：
```javascript
var myModule = {
    func1: function() {
        // 函数实现
    },
    func2: function() {
        // 函数实现
    }
}
```
### 16.2. CommonJS 规范
- 服务器端模块化：CommonJS 是服务器端模块规范，主要⽤于 Node.js 环境。它使⽤ require 函数引⼊模块，使⽤ module.exports 或 exports 导出模块。例如：
```javascript
// math.js
exports.add = function(a, b) {
    return a + b;
};
// main.js
const math = require('./math.js');
console.log(math.add(1, 2));
```
### 16.3. AMD 规范（Asynchronous Module Definition）
- 异步模块加载：AMD 是浏览器端的异步模块加载规范，主要通过 define 函数定义模块，使⽤ require 函数加载模块。例如使⽤ RequireJS 实现 AMD 规范：
```javascript
// math.js
define(function() {
    return {
        add: function(a, b) {
            return a + b;
        }
    };
});
// main.js
require(['math'], function(math) {
    console.log(math.add(1, 2));
});
```
### 16.4. CMD 规范（Common Module Definition）
- 延迟执⾏：CMD 也是⼀种浏览器端的模块规范，与 AMD 类似，但更强调延迟执⾏。Sea.js 是实现 CMD 规范的典型库。
```javascript
// math.js
define(function(require, exports, module) {
    exports.add = function(a, b) {
        return a + b;
    };
});
// main.js
seajs.use(['math'], function(math) {
    console.log(math.add(1, 2));
});
```
### 16.5. ES6 模块化
- 官⽅标准：ES6 引⼊了原⽣的模块化语法，使⽤ import 和 export 关键字实现模块的导⼊和导出。例如：
```javascript
// math.js
export const add = (a, b) => a + b  
// main.js
import { add } from './math.js';
console.log(add(1, 2));
```
### 16.6. 模块化的优势
- 可维护性：模块具有单⼀的功能和职责，当某个模块出现问题时，只需要修改该模块，不会影响其他模块。 
- 可复⽤性：模块可以在不同的项⽬或同⼀项⽬的不同地⽅重复使⽤，提⾼开发效率。 
- 依赖管理：模块化系统可以清晰地管理模块之间的依赖关系，避免依赖冲突。 
- 性能优化：通过按需加载模块，减少⾸屏加载时间，提⾼⻚⾯性能。

## 17. 前端模块化 和 组件化 的区别
### 17.1. 概念差异
- 前端模块化
  - 模块化是指将⼀个复杂的前端应⽤拆分成多个独⽴的、可复⽤的模块，每个模块具有明确的功能和职责，模块之间通过特定的⽅式进⾏交互和通信。它更侧重于代码逻辑的组织和管理，将不同功能的代码封装在不同的模块中，使得代码结构清晰，便于开发和维护。 
  - 例如，在 JavaScript 中，使⽤ ES6 的 import 和 export 语法可以实现模块的导⼊和导出，⼀个模块可以是⼀个函数库、⼀个数据处理模块等。
- 前端组件化
  - 组件化是将⻚⾯中可复⽤的 UI 部分封装成独⽴的组件，每个组件包含⾃⼰的HTML 结构、CSS 样式和 JavaScript 逻辑，组件之间可以嵌套和组合，形成完整的⻚⾯。它强调的是 UI 界⾯的拆分和复⽤，通过组件化开发可以提⾼ UI 开发的效率和质量。 
  - ⽐如，在 Vue.js 或 React 等框架中，⼀个按钮、⼀个表单、⼀个导航栏都可以封装成⼀个组件。
### 17.2. 粒度差异
- 前端模块化
  - 模块化的粒度相对较细，它可以是一个函数、一个类或者一组相关的函数和数据的集合。一个模块可以只负责完成一个特定的小功能，例如一个处理日期格式化的模块，或者一个进行数学计算的模块。
- 前端组件化
  - 组件化的粒度相对较粗，通常是一个具有完整UI功能的单元。一个组件可能包含多个模块，例如一个商品列表组件，它可能会使用到数据获取模块、数据处理模块、模板渲染模块等。
### 17.3. 关注点差异
- 前端模块化
  - 主要关注代码的逻辑结构和复⽤性，通过将代码拆分成多个模块，使得每个模块的功能单⼀且明确，便于代码的维护和测试。模块之间的依赖关系清晰，修改⼀个模块不会对其他模块产⽣过多的影响。 
  - 例如，在⼀个电商项⽬中，商品数据的获取和处理可以分别封装成不同的模块，这样在需要修改数据获取⽅式时，只需要修改数据获取模块，⽽不会影响到数据处理模块。
- 前端组件化
  - 更关注 UI 的设计和交互，将⻚⾯拆分成多个组件，每个组件有⾃⼰的样式和交互逻辑。组件可以独⽴开发、测试和部署，提⾼了 UI 开发的效率和可维护性。 
  - 例如，在设计⼀个社交⽹站时，将评论区封装成⼀个组件，这个组件包含评论的展示、发布、删除等功能，并且有⾃⼰的样式，这样在不同的⻚⾯中都可以复⽤这个评论组件。
### 17.4. 使用场景差异
- 前端模块化
  - 适⽤于处理复杂的业务逻辑，当项⽬中有⼤量的代码需要组织和管理时，模块化可以使代码结构更加清晰。例如，在⼀个⼤型的 JavaScript 应⽤中，将不同的业务逻辑封装成不同的模块，⽅便团队成员分⼯协作开发。 
  - 也适⽤于代码复⽤，当多个地⽅需要使⽤相同的功能时，可以将这些功能封装成模块，在需要的地⽅进⾏导⼊和使⽤。
- 前端组件化
  - 适⽤于构建复杂的 UI 界⾯，当⻚⾯中有多个重复的 UI 元素时，组件化可以提⾼开发效率。例如，在开发⼀个管理系统时，将表格、表单等常⽤的 UI 元素封装成组件，在不同的⻚⾯中复⽤这些组件。 
  - 也适⽤于快速迭代开发，当需要对 UI 进⾏修改时，只需要修改相应的组件，⽽不会影响到其他部分的代码。


## 18. 前端代码部署流程
### 18.1. 代码的管理与提交
- 版本控制：团队成员使⽤版本控制系统（如 Git）管理前端代码。⼀般会在本地开发分⽀上进⾏代码编写，完成功能开发或问题修复后，将代码提交到本地仓库。 
- 代码审查：开发⼈员将本地代码推送到远程仓库的特定分⽀（如 feature 分⽀）后，发起代码审查（Pull Request）。团队中的其他成员对代码进⾏审查，检查代码质量、功能实现、是否符合规范等，确保代码的正确性和可维护性。
- 合并代码：代码审查通过后，将开发分⽀的代码合并到主分⽀（如 master 或 main ）。
### 18.2. 触发⾃动化部署
- 配置持续集成/持续部署（CI/CD）⼯具：常⻅的 CI/CD ⼯具有 Jenkins、GitLab CI/CD、GitHub Actions 等。在项⽬中配置这些⼯具，当代码发⽣特定事件（如代码推送到主分⽀、创建新的标签等）时，⾃动触发部署流程。 
- 事件监听：CI/CD ⼯具会持续监听代码仓库的变化。以 GitHub Actions 为例，在项⽬的 .github/workflows ⽬录下创建 YAML 配置⽂件，定义触发条件和部署步骤。例如：
```terminal
name: Frontend Deployment
on:
    push:
        branches:
        - main
jobs:
    build-and-deploy:
        runs-on: ubuntu-latest
        steps:
        # 后续步骤将在此处定义
```
### 18.3. 环境准备
- 拉取代码：CI/CD ⼯具接收到触发事件后，⾸先会从代码仓库中拉取最新的代码到构建环境。在 GitHub Actions 的配置⽂件中添加如下步骤：
```terminal
steps:
    - name: Checkout code
    uses: actions/checkout@v2
```
- 安装依赖：根据项⽬的 package.json ⽂件，安装项⽬所需的依赖。对于前端项⽬，通常使⽤ npm 或 yarn 进⾏安装。
```terminal
name: Install dependencies
run: npm install
```
### 18.4. 代码构建
- 打包优化：使⽤构建⼯具（如 Webpack、Vite 等）对前端代码进⾏打包优化，将多个模块打包成⼀个或多个⽂件，压缩代码体积，提⾼加载速度。以 Vue 项⽬为例：
```terminal
name: Build project
run: npm run build
```
- 代码检查：在构建过程中，可以进⾏代码检查，如使⽤ ESLint 检查 JavaScript 代码的语法和⻛格错误，使⽤ Stylelint 检查 CSS 代码的规范。
```terminal
name: Lint code
run: npm run lint
```
### 18.5. 测试
- 单元测试：编写单元测试⽤例，使⽤测试框架（如 Jest、Mocha 等）对代码的各个模块进⾏独⽴测试，确保代码的正确性。
```terminal
name: Run unit tests
run: npm test
```
- 集成测试：对多个模块进⾏集成测试，验证它们之间的协作是否正常。可以使⽤Cypress、TestCafe 等⼯具进⾏端到端测试。
### 18.6. 部署到目标环境
- 选择⽬标环境：⽬标环境可以是开发环境、测试环境、预发布环境或⽣产环境。根据不同的需求和配置，将打包好的代码部署到相应的环境中。 
- 上传代码：将构建好的静态⽂件上传到服务器或静态⽹站托管服务。如果使⽤云服务器，可以使⽤ scp 或 rsync 命令上传⽂件；如果使⽤静态⽹站托管服务，按照其提供的 API 或界⾯进⾏上传。
```terminal
name: Deploy to server
uses: appleboy/ssh-action@master
with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USERNAME }}
    password: ${{ secrets.SERVER_PASSWORD }}
    script: |
        rm -rf /path/to/deploy/*
        scp -r dist/ /path/to/deploy
```
- 配置服务器：在服务器上配置 Web 服务器（如 Nginx、Apache），确保静态⽂件能够正确访问。
### 18.7. 监控与反馈
- 监控系统：部署完成后，使⽤监控系统（如 Prometheus、Grafana 等）对应⽤的性能、可⽤性等进⾏监控，及时发现和处理问题。 
- 反馈机制：建⽴反馈机制，将部署结果（成功或失败）通知相关⼈员。可以通过邮件、Slack 等⽅式发送通知。

# 十、Git
## 1.Git，主要作用
- Git 是⼀个分布式版本控制系统，⽤于跟踪⽂件的变化、管理项⽬的版本历史，⽀持多⼈协作开发。其主要作⽤包括：
  - 版本控制：记录项⽬⽂件的每⼀次修改，⽅便开发者随时查看历史版本，回溯到之前的某个状态。 
  - 团队协作：多个开发者可以同时在⼀个项⽬上进⾏开发，Git 能有效处理代码的合并与冲突，确保团队协作的⾼效性。 
  - 分⽀管理：允许开发者创建不同的分⽀进⾏独⽴开发，如开发新功能、修复 bug 等，开发完成后再将分⽀合并到主分⽀。

## 2. 简述 Git 的基本⼯作流程
- 克隆仓库：使⽤ git clone <repository-url> 命令将远程仓库复制到本地。 
- 创建分⽀：使⽤ git branch <branch-name> 创建新分⽀，使⽤ git checkout<branch-name> 切换到该分⽀，也可以使⽤ git checkout -b <branch-name>⼀步完成创建并切换分⽀。 
- 开发与提交：在分⽀上进⾏代码开发，使⽤ git add <file> 将修改的⽂件添加到暂存区，使⽤ git commit -m "commit message" 将暂存区的内容提交到本地仓库。 
- 同步远程仓库：使⽤ git pull 从远程仓库拉取最新代码并合并到本地分⽀，使⽤ git push 将本地分⽀的代码推送到远程仓库。 
- 合并分⽀：开发完成后，切换到主分⽀（如 master 或 main ），使⽤ git merge <branch-name> 将开发分⽀合并到主分⽀。

## 3.  Git 中 HEAD、⼯作区、暂存区和本地仓库分别是什么，它们之间有什么关系？
- HEAD：指向当前所在的分⽀的最新提交，是当前分⽀指针的引⽤。 
- ⼯作区：即你在本地计算机上实际进⾏⽂件编辑的⽬录，是你能直接看到和修改的⽂件区域。 
- 暂存区：也叫索引（index），是⼀个中间区域，⽤于临时保存你所做的修改，你可以选择将部分或全部修改添加到暂存区。 
- 本地仓库：存储了项⽬的所有版本历史信息，包括提交记录、分⽀信息等。 
- 它们之间的关系是：你在⼯作区对⽂件进⾏修改后，使⽤ git add 命令将修改添加到暂存区，使⽤ git commit 命令将暂存区的内容提交到本地仓库。 HEAD 始终指向当前分⽀的最新提交。

## 4. 如何解决 Git 合并冲突？
- 当合并分⽀时，如果两个分⽀对同⼀⽂件的同⼀部分进⾏了不同的修改，就会产⽣合并冲突。解决步骤如下： 
  - 查看冲突⽂件：使⽤ git status 命令查看哪些⽂件发⽣了冲突。 
  - 编辑冲突⽂件：打开冲突⽂件，会看到类似下⾯的标记：
```text
<<<<<<< HEAD
// 当前分⽀的代码
=======
// 要合并的分⽀的代码
>>>>>>> branch-name
```
- ⼿动选择保留哪部分代码，或者将两部分代码进⾏整合，然后删除冲突标记。 
  - 标记冲突已解决：使⽤ git add <file> 将解决冲突后的⽂件添加到暂存区。 
  - 完成合并：使⽤ git commit 完成合并操作。

## 5. 简述 Git 分⽀管理策略
- 常⻅的分⽀管理策略有 GitFlow 和 GitHub Flow。
  - GitFlow：包含主分⽀（ master 或 main ）、开发分⽀（ develop ）、功能分⽀ （ feature/* ）、发布分⽀（ release/* ）和热修复分⽀（ hotfix/* ）。主分⽀⽤于⽣产环境代码，开发分⽀是所有开发的基础，功能分⽀从开发分⽀创建，⽤于开发新功能，开发完成后合并回开发分⽀；发布分⽀从开发分⽀创建，⽤于准备新版本发布，测试完成后合并到主分⽀和开发分⽀；热修复分⽀从主分⽀创建，⽤于紧急修复⽣产环境的 bug，修复完成后合并到主分⽀和开发分⽀。 
  - GitHub Flow：相对简单，只有主分⽀（ master 或 main ）和功能分⽀。所有的新功能都在功能分⽀上开发，开发完成后通过 Pull Request 合并到主分⽀。主分⽀的代码始终是可部署的。

## 6. 如何撤销 Git 中的某次提交？
- 使⽤ git revert ：如果想撤销某次提交，但保留该提交之后的所有提交记录，可以使⽤ git revert <commit-hash> 。这个命令会创建⼀个新的提交，该提交的内容是撤销指定提交所做的修改。 
- 使⽤ git reset ：如果想彻底删除某次提交及其之后的所有提交记录，可以使⽤ git reset <commit-hash>。 git reset 有三种模式：
  - --soft ：只移动 HEAD 指针，不改变暂存区和⼯作区的内容。 
  - --mixed （默认）：移动 HEAD 指针，并重置暂存区，但不改变⼯作区的内容。 
  - --hard ：移动 HEAD 指针，重置暂存区和⼯作区的内容，使其与指定提交⼀致。

## 7. 如何查看Git的提交历史
- 使⽤ git log ：显示提交历史记录，默认按时间倒序排列，每条记录包含提交哈希、作者、提交⽇期和提交信息。 
- 常⽤参数：
  - --oneline ：将每条提交记录显示为⼀⾏，只显示提交哈希的前⼏位和提交信息。 
  - --graph ：以图形化的⽅式显示分⽀和合并历史。 
  - --author=<author-name> ：只显示指定作者的提交记录。 
  - --since=<date> 和 --until=<date> ：显示指定⽇期范围内的提交记录。

## 8. 什么是 Git 的标签（Tag），如何使⽤？
- Git 标签是指向某个提交的引⽤，⽤于标记项⽬的重要版本，如发布版本。标签分为轻量标签和附注标签。
  - 创建轻量标签：使⽤ git tag <tag-name> 在当前提交上创建轻量标签。 
  - 创建附注标签：使⽤ git tag -a <tag-name> -m "tag message" 创建附注标签，附注标签包含更多的元信息，如标签信息、作者等。 
  - 查看标签：使⽤ git tag 查看所有标签，使⽤ git show <tag-name> 查看某个标签的详细信息。 
  - 推送标签到远程仓库：使⽤ git push origin <tag-name> 推送单个标签，使⽤git push origin --tags 推送所有标签。

## 9. git rebase
### 9.1. 和get merge的区别
- git rebase 是 Git 中⽤于整合分⽀的⼀种⽅式，它将⼀个分⽀的修改应⽤到另⼀个分⽀上，通过将提交历史以线性的⽅式重新排列，使得提交历史看起来更加简洁、清晰。主要区别如下：
- 提交历史展示
  - git merge ：会创建⼀个新的合并提交，将两个分⽀的历史合并在⼀起，提交历史呈现出分叉的状态，能够清晰地看到分⽀的合并点，但可能会使提交历史变得复杂。 
  - git rebase ：将⼀个分⽀的提交依次应⽤到另⼀个分⽀上，使提交历史呈现线性，更加简洁直观。
- 操作过程
  - git merge ：操作相对简单，直接将两个分⽀合并，处理冲突时在合并提交中解决。 
  - git rebase ：操作过程中会逐个应⽤提交，遇到冲突需要在每个提交上解决，完成冲突解决后继续 rebase 操作。
### 9.2. 如何使用 git rebase
- 切换到需要被合并的分⽀：假设你在 feature 分⽀上进⾏开发，想要将feature 分⽀的修改应⽤到 master 分⽀上，⾸先切换到 feature 分⽀。git checkout feature
- 执⾏ rebase 操作：将 feature 分⽀的提交应⽤到 master 分⽀上。git rebase master
- 处理冲突（如果有）：在 rebase 过程中，如果遇到冲突，Git 会暂停 rebase 操作并提示你解决冲突。解决冲突后，使⽤ git add 将解决冲突的⽂件添加到暂存区，然后使⽤ git rebase --continue 继续 rebase 操作。
```text
# 解决冲突后
git add <file>
git rebase --continue
```
- 完成 rebase ：当所有提交都成功应⽤后， rebase 操作完成。此时， feature 分⽀的提交已经线性排列在 master 分⽀之后。
### 9.3. git rebase有哪些应用场景
- 保持提交历史线性：在团队协作中，为了使提交历史更加清晰、易于理解和审查，使⽤ git rebase 可以将开发分⽀的提交以线性⽅式整合到主分⽀上。 
- 清理提交历史：在开发过程中，可能会产⽣⼀些临时提交或不必要的提交。使⽤git rebase -i （交互式 rebase ）可以合并、修改或删除这些提交，使提交历史更加简洁。例如，将多个⼩的提交合并成⼀个有意义的提交：
```text
git rebase -i HEAD~3 # 对最近的 3 个提交进⾏交互式 rebase
```
- 在弹出的编辑器中，可以选择 pick （保留提交）、 squash （将提交合并到前⼀个提交）等操作。
### 9.4. git rebase有什么风险
- 数据丢失⻛险：如果在 rebase 过程中操作不当，例如强制覆盖已经推送到远程仓库的提交，可能会导致数据丢失，其他开发者可能会遇到难以解决的冲突。 
- 破坏公共分⽀历史：不建议在公共分⽀（如 master ）上进⾏ rebase 操作，因为这会改变公共分⽀的提交历史，可能会影响其他开发者的⼯作。如果需要在公共分⽀上应⽤ rebase ，应该先与团队成员沟通，确保⼤家都能正确处理。

## 10. git cherry-pick
### 10.1. 定义
- git cherry - pick 是 Git 中的⼀个命令，它允许你从⼀个或多个提交中挑选出特定的提交，并将这些提交所做的更改应⽤到当前分⽀上。这就好⽐从众多的樱桃（提交）⾥挑选出你想要的那⼏颗，然后把它们“种”到当前分⽀。它提供了⼀种细粒度的提交合并⽅式，与 git merge 和 git rebase 不同，后两者通常是合并整个分⽀的更改，⽽git cherry - pick 可以只选择部分提交进⾏合并。
### 10.2. 如何使用git cherry-pick
- 挑选单个提交：假设你有两个分⽀ master 和 feature ， feature 分⽀上有⼀个提交（提交哈希为 abc123 ），你想把这个提交应⽤到 master 分⽀上，操作步骤如下：

```git
# 切换到⽬标分⽀
git checkout master
# 执⾏ cherry - pick 操作
git cherry - pick abc123
# 如果在应⽤提交的过程中没有冲突，Git 会⾃动创建⼀个新的提交，这个新提交的内容和 abc123 提交的内容⼀样，但提交哈希不同。
```
- 挑选多个提交：如果要挑选多个连续的提交，可以使⽤以下语法：
```git
git cherry - pick start_commit..end_commit
```
> 这⾥的 start_commit 是起始提交的哈希， end_commit 是结束提交的哈希，但需要注意，这种⽅式不包含 start_commit 本身，只包含从 start_commit 之后到end_commit 的所有提交。如果要包含 start_commit ，可以使⽤：

```git
git cherry - pick start_commit^..end_commit
```
- 挑选不连续的提交：如果要挑选不连续的多个提交，只需依次列出提交的哈希值即可：
```git
git cherry - pick commit1 commit2 commit3
```
### 10.3. 处理git cherry - pick 过程中的冲突
- 当执⾏ git cherry - pick 时，如果提交所做的更改与当前分⽀的内容发⽣冲突，Git会暂停 cherry - pick 操作并提示你解决冲突。解决冲突的步骤如下： 
- 查看冲突⽂件：使⽤ git status 命令查看哪些⽂件发⽣了冲突。 
- 编辑冲突⽂件：打开冲突⽂件，⼿动解决冲突内容，删除冲突标记。 
- 标记冲突已解决：使⽤ git add 命令将解决冲突后的⽂件添加到暂存区。 
- 继续 cherry - pick ：使⽤ git cherry - pick --continue 命令继续 cherry - pick 操作。如果想要放弃本次 cherry - pick ，可以使⽤ git cherry - pick --abort 命令。
### 10.4. git cherry - pick 的应⽤场景
- 修复特定版本的 bug：假设在 release 版本分⽀上发现了⼀个 bug，⽽这个 bug 的修复已经在 develop 分⽀的某个提交中完成。这时可以使⽤ git cherry - pick 将该提交应⽤到 release 分⽀上，⽽不需要合并整个 develop 分⽀。 
- 同步部分功能：当你只需要将某个分⽀上的部分功能同步到另⼀个分⽀时， git cherry - pick 可以帮助你精确地选择需要的提交进⾏合并。
### 10.5. git cherry - pick 的潜在问题
- 重复提交问题：如果多次对同⼀个提交执⾏ cherry - pick ，可能会在⽬标分⽀上产⽣重复的提交内容。所以在使⽤前要确保不会出现这种情况。 
- 提交历史混乱：过度使⽤ git cherry - pick 可能会导致提交历史变得复杂和难以理解，因为提交的顺序和逻辑可能会被打乱。因此，在使⽤时需要谨慎考虑，确保提交历史的可读性和可维护性。

# 十一、常见问题和解决方案
## 1. 性能优化相关问题
### 1.1.  页面加载速度慢
- 具体表现：在访问⻚⾯时，需要等待较⻓时间才能看到完整内容，尤其是在⽹络状况不佳或⻚⾯资源较多的情况下，这种延迟更为明显。 
- 可能原因：⻚⾯中包含⼤量未压缩的图⽚、CSS 和 JavaScript ⽂件；过多的 HTTP请求；没有合理利⽤缓存机制。 
- 解决⽅案 
  - 压缩资源：使⽤⼯具对图⽚、CSS 和 JavaScript ⽂件进⾏压缩。例如，使⽤ TinyPNG 压缩图⽚，使⽤ UglifyJS 压缩 JavaScript，使⽤ cssnano 压缩 CSS。 
  - 合并⽂件：将多个 CSS 和 JavaScript ⽂件合并成⼀个，减少 HTTP 请求次数。同时，使⽤代码分割技术，按需加载⾮关键资源。 
  - 缓存机制：设置合理的缓存策略，利⽤浏览器的强缓存和协商缓存。对于静态资源，可以设置较⻓的缓存时间；对于动态数据，可以使⽤ ETag 和 Last - Modified 进⾏协商缓存。
### 1.2. 动画卡顿
- 具体表现：⻚⾯中的动画效果不流畅，出现明显的卡顿、掉帧现象，影响⽤户体验。 
- 可能原因：动画使⽤了会触发重排和重绘的 CSS 属性，如 width 、 height 等；JavaScript 代码执⾏时间过⻓，阻塞了⻚⾯渲染。 
- 解决⽅案 
- 使⽤ transform 和 opacity：优先使⽤ transform 和 opacity 进⾏动画效果的实现，因为它们不会触发重排和重绘，性能更好。 
- 优化 JavaScript 代码：避免在动画过程中进⾏⼤量的计算和 DOM 操作。可以使⽤ requestAnimationFrame 来优化动画的执⾏，确保动画在浏览器的渲染帧中进⾏。

## 2. 兼容性问题
### 2.1. 不同浏览器显示不⼀致
- 具体表现：⻚⾯在不同浏览器（如 Chrome、Firefox、Safari 等）或同⼀浏览器的不同版本中显示效果存在差异，布局错乱、样式缺失等。 
- 可能原因：不同浏览器对 CSS 和 HTML 标准的⽀持程度不同，⼀些新的 CSS 属性和 JavaScript 特性在旧版本浏览器中可能不被⽀持。 
- 解决⽅案 
  - 使⽤浏览器前缀：对于⼀些新的 CSS 属性，使⽤浏览器前缀（如 -webkit-、 -moz - 、 -ms - 等）来确保在不同浏览器中都能正常显示。
  - 使⽤ Polyfill：对于⼀些新的 JavaScript 特性，使⽤ Polyfill 库（如 Babel Polyfill、core - js 等）来在旧版本浏览器中提供兼容⽀持。 
  - 进⾏多浏览器测试：在开发过程中，使⽤ BrowserStack、Sauce Labs 等⼯具对不同浏览器和版本进⾏测试，及时发现并解决兼容性问题。
### 2.2. 移动端和桌⾯端显示差异⼤
- 具体表现：⻚⾯在移动端和桌⾯端的布局、交互效果等⽅⾯存在较⼤差异，影响⽤户在不同设备上的使⽤体验。 
- 可能原因：没有进⾏响应式设计，⻚⾯布局和样式没有根据设备屏幕尺⼨进⾏调整；⼀些桌⾯端的交互⽅式（如⿏标悬停）在移动端⽆法正常使⽤。 
- 解决⽅案 
  - 响应式设计：使⽤媒体查询、弹性布局（Flexbox）和⽹格布局（Grid）等技术进⾏响应式设计，确保⻚⾯在不同设备上都能有良好的显示效果。 
  - 触摸事件处理：在移动端，使⽤触摸事件（如touchstart 、 touchmove 、 touchend 等）替代⿏标事件，提供更符合移动端操作习惯的交互⽅式。

## 3. 交互体验问题
### 3.1. 表单提交后无反馈
- 具体表现：⽤户提交表单后，⻚⾯没有任何反馈信息，⽤户不知道表单是否提交成功，容易造成重复提交。 
- 可能原因：没有在表单提交时添加相应的提示信息或状态更新；表单提交过程中出现错误，但没有给⽤户明确的错误提示。 
- 解决⽅案 
  - 添加加载提示：在表单提交时，显示加载动画或提示信息，告知⽤户表单正在处理中。例如，使⽤模态框显示“正在提交，请稍候... ” 。 
  - 反馈提交结果：根据表单提交的结果，给⽤户相应的反馈信息。如果提交成 功，显示成功提示；如果提交失败，显示具体的错误信息，帮助⽤户排查问题。
### 3.2. 滚动加载性能差
- 具体表现：在实现滚动加载数据时，⻚⾯滚动不流畅，出现卡顿现象，尤其是在加载⼤量数据时更为明显。 
- 可能原因：每次滚动加载时，⼀次性加载过多的数据，导致 DOM 操作频繁，影响⻚⾯性能；没有对滚动事件进⾏节流处理，导致事件处理函数频繁触发。 
- 解决⽅案 
  - 分⻚加载：采⽤分⻚加载的⽅式，每次只加载适量的数据，减少 DOM 操作的负担。可以根据⽤户的滚动位置，动态加载下⼀⻚的数据。 
  - 节流处理：使⽤节流函数对滚动事件进⾏处理，减少事件处理函数的执⾏次数。例如，使⽤ throttle 函数，设置⼀个固定的时间间隔，在该时间间隔内只执⾏⼀次事件处理函数。

## 4. 安全问题
### 4.1. XSS攻击
- 具体表现：攻击者通过在⽹⻚中注⼊恶意脚本，当⽤户访问该⻚⾯时，恶意脚本会在⽤户的浏览器中执⾏，从⽽获取⽤户的敏感信息或进⾏其他恶意操作。 
- 可能原因：在渲染⽤户输⼊的内容时，没有进⾏适当的过滤和转义，导致恶意脚本被直接执⾏。 
- 解决⽅案 
  - 输⼊验证和过滤：在前端和后端对⽤户输⼊的内容进⾏验证和过滤，只允许合法的字符和格式。例如，使⽤正则表达式对输⼊内容进⾏验证。 
  - HTML 转义：在渲染⽤户输⼊的内容时，对特殊字符进⾏ HTML 转义，防⽌恶意脚本的执⾏。可以使⽤库如 DOMPurify 来进⾏ HTML 净化。
### 4.2. CSRF 攻击
- 具体表现：攻击者通过诱导⽤户在已登录的⽹站上执⾏恶意操作，利⽤⽤户的身份信息完成⾮法请求。 
- 可能原因：⽹站没有对请求进⾏有效的身份验证和令牌验证，导致攻击者可以伪造请求。 
- 解决⽅案 
  - 使⽤ CSRF 令牌：在表单提交或 AJAX 请求中添加 CSRF 令牌，服务器在处理请求时验证令牌的有效性。可以在表单中隐藏⼀个包含 CSRF 令牌的字段，或者在请求头中添加令牌信息。 
  - 同源策略：确保所有的请求都来⾃同源的⻚⾯，防⽌跨站请求伪造。可以通过设置 CSP（Content Security Policy）来限制⻚⾯可以加载的资源和执⾏的脚本来源。

## 5. 数据交互难题
### 5.1. 跨越问题
- 表现：由于浏览器的同源策略，当⻚⾯从⼀个域名下的⻚⾯向另⼀个域名下的服务器发送请求时，会受到跨域限制，导致请求被阻⽌。常⻅的跨域场景包括前后端分离项⽬中前端⻚⾯和后端 API 不在同⼀个域名下。 
- 解决办法：可以使⽤ CORS（跨域资源共享），在服务器端设置响应头，允许指定的域名进⾏跨域请求。也可以使⽤ JSONP（JSON with Padding），它是⼀种古⽼的跨域解决⽅案，但只⽀持 GET 请求。另外，还可以使⽤代理服务器，在同源的服务器上转发请求到⽬标服务器。
### 5.2. 数据格式和编码问题
- 表现：在前后端数据交互过程中，可能会出现数据格式不匹配、编码不⼀致的问题。例如，前端发送的数据格式为 JSON，但后端期望的是 XML 格式；或者在传输过程中出现字符编码问题，导致数据显示乱码。 
- 解决办法：前后端约定统⼀的数据格式，通常使⽤ JSON 作为数据交换格式。在传 输数据时，确保使⽤统⼀的字符编码（如 UTF - 8）。在前端发送请求和后端接收请求时，进⾏必要的数据格式转换和编码处理。

## 6. 项目亮点话术示例
### 6.1. 移动端项⽬：从 Vue 2 到 Vue 3 的升级主导
- 我曾从 0 到 1 主导了⼀个移动端项⽬的开发，该项⽬原本基于 Vue 2 构建，我决定将其升级为 Vue 3 进⾏开发。
  - 技术创新与⾼效应⽤：引⼊ Vue 3 及其组合式 API，这⼀转变让代码结构更加清晰模块化，逻辑复⽤变得轻⽽易举。⽐如，在处理复杂的表单验证逻辑时，通过组合式 API 将验证逻辑封装成独⽴的函数，在多个组件中复⽤，⼤⼤提⾼了开发效率。同时，搭配 TypeScript，利⽤其静态类型检查特性，在开发阶段就捕获并解决了许 多潜在的代码错误，显著提升了代码的稳定性和可维护性。 
  - 性能优化成效显著：针对移动端设备的性能特点，我运⽤ Webpack 进⾏代码分割和压缩，减少了初始加载的代码量。采⽤图⽚懒加载和 CDN 加速技术，⼤幅加快了图⽚资源的加载速度。经过⼀系列优化，⻚⾯⾸屏加载时间缩短了 40%，有效提升了⽤户体验。 
  - 团队协作与⾼效开发：在项⽬中采⽤敏捷开发流程，每周进⾏迭代和回顾。组织团队成员进⾏ Vue 3 技术培训，帮助⼤家快速掌握新技术。通过 Git 进⾏版本控制，使⽤项⽬管理⼯具进⾏任务跟踪和进度监控，确保团队成员之间沟通顺畅、协作⾼效，项⽬按时⾼质量交付。
### 6.2. App 内 H5 活动⻚⾯项⽬：动画驱动流量增⻓
- 在 App 内 H5 活动⻚⾯项⽬中，我聚焦于打造出⾊的动画效果，以吸引⽤户参与，最终实现了 PV 和 UV 的显著增⻓。这是团队协作的结果，ui⽼师的设计图，产品⽼师的点⼦，还有⼤家⼀起想出来的动画效果等；
  - 数据驱动活动优化：在活动上线后，密切关注数据指标，通过埋点统计 PV、UV、⽤户停留时间等数据。根据数据分析结果，对活动⻚⾯进⾏针对性优化，如调整动画展示位置、优化活动规则说明等。经过优化，活动的 PV 增⻓了 60%，UV 增⻓了 50%，取得了显著的营销效果。
