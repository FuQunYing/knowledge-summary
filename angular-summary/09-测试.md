# 测试
## 一、准备工作
  AngularCLI互下载并在牛黄使用Jasmine测试框架，测试Angular应用时所需的一切。使用CLI创建的项目可以立即用于测试，运行 ng test 命令即可。
  ng test命令在监视模式下构建应用，并启动karma测试运行器，它的控制台输出一般是这样的：
```txt
10% building modules 1/1 modules 0 active
...INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/
...INFO [launcher]: Launching browser Chrome ...
...INFO [launcher]: Starting browser Chrome
...INFO [Chrome ...]: Connected on socket ... 
Chrome ...: Executed 3 of 3 SUCCESS (0.135 secs / 0.205 secs)
```
  最后一行的信息很重要，它表示karma运行了三个测试，而且这些测试都通过了。它还会打开Chrome浏览器并在 Jasmine HTML报告显示测试输出。测试了一下这个运维平台的项目，浏览器里面显示的好好的，一启动测试，一堆错误。
  大多数人觉得浏览器中的报告比控制台中的日志更容易阅读。可以点击一行测试，来单独重跑这个测试，或者点击一行描述信息来重跑所选测试组（“测试套件”）中的那些测试。同时，ng test命令还会监听这些变化。要查看它的实际效果，就对app.component.ts做一个小修改，并保存它，这些测试就会重新运行，浏览器也会刷新，然后新的测试结果就出现了。
### 1.配置
  CLI会生成Jasmine和Karma的配置文件。不过也可以通过编辑 src/目录下的karma.conf.js和test.ts文件来微调很多选项。karma.conf.js问价是karma配置文件的一部分，CLI会基于angular.json文件中指定的项目结构和karma.conf.js文件，来在内存中构建出完整的运行时配置。
### 2.其它测试框架
  还可以使用其它的测试库和测试运行器来对Angular应用进行单元测试。每个库和运行器都有自己特有的安装过程、配置项和语法
### 3.测试文件名及其位置
  查看src/app文件夹。CLI为AppComponent生成了一个名叫app.component.spec.ts的测试文件。
  测试文件的扩展名必须是.spec.ts，这样工具才能识别出它是一个测试文件，也叫规约（spec）文件。
  app.component.ts和app.component.spec.ts文件位于同一个文件夹中，而且相邻，其根文件名部分（app.component）都是一样的。
### 4.对服务的测试
  服务通常是单元测试中最简单的文件类型。下面是一些针对ValueService的同步和异步单元测试，编写它们时没有借助来自Angular测试工具集的任何协助。
```typescript
// Straight Jasmine testing without Angular's testing support
describe('ValueService', () => {
  let service: ValueService;
  beforeEach(() => { service = new ValueService(); });

  it('#getValue should return real value', () => {
    expect(service.getValue()).toBe('real value');
  });

  it('#getObservableValue should return value from observable',
    (done: DoneFn) => {
    service.getObservableValue().subscribe(value => {
      expect(value).toBe('observable value');
      done();
    });
  });

  it('#getPromiseValue should return value from a promise',
    (done: DoneFn) => {
    service.getPromiseValue().then(value => {
      expect(value).toBe('promise value');
      done();
    });
  });
});
```
### 5.带有依赖的服务
  服务通常会依赖于一些Angular注入到其构造函数中的其它服务。多数情况下，创建并在调用该服务的构造函数时，手工创建并注入这些依赖也是很容易的。MasterService就是一个简单的例子：
```typescript
@Injectable()
export class MasterServie{
    constructor(private valuerService:ValueSeervice){}
    getValue(){return this.valueService.getValue()}
}
```
  MasterService把它唯一的方法getValue委托给了注入进来的ValueService。
  这里是几种测试它的方法：
```typescript
describe('MasterService without Angular testing support', () => {
  let masterService: MasterService;

  it('#getValue should return real value from the real service', () => {
    masterService = new MasterService(new ValueService());
    expect(masterService.getValue()).toBe('real value');
  });

  it('#getValue should return faked value from a fakeService', () => {
    masterService = new MasterService(new FakeValueService());
    expect(masterService.getValue()).toBe('faked service value');
  });

  it('#getValue should return faked value from a fake object', () => {
    const fake =  { getValue: () => 'fake value' };
    masterService = new MasterService(fake as ValueService);
    expect(masterService.getValue()).toBe('fake value');
  });

  it('#getValue should return stubbed value from a spy', () => {
    // create `getValue` spy on an object representing the ValueService
    const valueServiceSpy =
      jasmine.createSpyObj('ValueService', ['getValue']);

    // set the value to return when the `getValue` spy is called.
    const stubValue = 'stub value';
    valueServiceSpy.getValue.and.returnValue(stubValue);

    masterService = new MasterService(valueServiceSpy);

    expect(masterService.getValue())
      .toBe(stubValue, 'service returned stub value');
    expect(valueServiceSpy.getValue.calls.count())
      .toBe(1, 'spy method was called once');
    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
      .toBe(stubValue);
  });
});
```
  第一个测试使用了new创建了ValueService，然后把它传给了MasterService的构造函数。不过，对于大多数没这么容易创建和控制的依赖项来说，注入真实的服务很容易出问题。可以改用模拟依赖的方式，可以使用虚值或相关的服务方法上创建一个spy。
  **优先使用spy，因为它们通常是Mock服务时最简单的方式**
  这些标准的测试技巧对于在隔离的环境下对服务进行单元测试非常重要。不过几乎迟早要用Angular的依赖注入机制来把服务注入到应用类中去，而且应该已经有了这类测试。Angular的测试工具集可以轻松探查这种注入服务的工作方式。
### 6.使用TestBed（测试机床）测试服务
  应用中会依赖Angular的依赖注入来创建服务。当某个服务依赖于另一个服务时，依赖注入就会找到或创建那个被依赖的服务。如果那个被依赖的服务还有它自己的依赖，依赖注入也同样会找到或创建它们。
  作为服务的消费方，我并不需要关心这些细节。不用关心构造函数中的参数顺序或如何创建它们。但对于服务的测试方来说，就至少要考虑服务的第一级依赖了，不过我可以让AngularDI来负责服务的创建工作，但是当使用TestBed测试工具来提供和创建服务时，仍然需要关心构造函数中的参数顺序。
### 7.Angular  TestBed
  TestBed是Angular测试工具中最重要的部分。TestBed会动态创建一个用来模拟@NgModule的Angular测试模块。TestBed.configureTestingModule()方法接收一个元数据对象，其中具有@NgModule中的绝大多数属性。要测试某个服务，就要在元数据的providers属性中指定一个将要进行测试或模拟的相关服务数组。
```typescript
let service: ValueService;

beforeEach(() => {
  TestBed.configureTestingModule({ providers: [ValueService] });
});
```
  然后通过调用 TestBed.get()（参数为该服务类）把它注入到一个测试中。
```typescript
it('should use ValueService', () => {
  service = TestBed.get(ValueService);
  expect(service.getValue()).toBe('real value');
});
```
  或者，如果你更倾向于把该服务作为环境准备过程的一部分，就把它放在 beforeEach() 中。
```typescript
beforeEach(() => {
  TestBed.configureTestingModule({ providers: [ValueService] });
  service = TestBed.get(ValueService);
});
```
  如果要测试一个带有依赖项的服务，那就把模拟对象放在 providers 数组中。在下面的例子中，模拟对象是一个间谍（spy）对象。
```typescript
let masterService: MasterService;
let valueServiceSpy: jasmine.SpyObj<ValueService>;

beforeEach(() => {
  const spy = jasmine.createSpyObj('ValueService', ['getValue']);

  TestBed.configureTestingModule({
    // Provide both the service-to-test and its (spy) dependency
    providers: [
      MasterService,
      { provide: ValueService, useValue: spy }
    ]
  });
  // Inject both the service-to-test and its (spy) dependency
  masterService = TestBed.get(MasterService);
  valueServiceSpy = TestBed.get(ValueService);
});
```
  该测试会像以前一样消费这个spy对象：
```typescript
it('#getValue should return stubbed value from a spy', () => {
  const stubValue = 'stub value';
  valueServiceSpy.getValue.and.returnValue(stubValue);

  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});
```
### 8.不使用beforeEach进行测试
  本节中的大多数测试套件都会调用beforeEach()来为每个it()测试准备前置条件，并依赖TestBed来创建类和注入服务。看一下如何把MasterService的测试改写成那种风格。通过把可复用的准备代码放进一个单独的setup函数来代替beforeEach():
```typescript
function setup() {
  const valueServiceSpy =
    jasmine.createSpyObj('ValueService', ['getValue']);
  const stubValue = 'stub value';
  const masterService = new MasterService(valueServiceSpy);

  valueServiceSpy.getValue.and.returnValue(stubValue);
  return { masterService, stubValue, valueServiceSpy };
}
```
  setup()函数返回一个带有一些变量的对象字面量，比如masterService，测试中可以引用它。这样就不用在describe()中定义一些半全局性的变量了（比如let masterService:MasterService)。
  然后每个测试都会在第一行调用setup()，然后再操纵被测主体以及对期望值进行断言：
```typescript
it('#getValue should return stubbed value from a spy', () => {
  const { masterService, stubValue, valueServiceSpy } = setup();
  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});
```
  注意这些测试是如何使用解构赋值来提取出所需变量的：
```typescript
const { masterService, stubValue, valueServiceSpy } = setup();
```
  很多开发者觉得这种方式相比传统的beforeEach()风格更加干净、更加明确。
### 9.测试HTTP服务
  那些会向远端服务器发起的HTPP调用的数据服务，通常会注入Angular的HttpClient服务并委托它进行XHR调用。我可以像测试其它依赖的服务那样，通过注入一个HttpClient Spy来测试这种数据服务：
```typescript
let httpClientSpy: { get: jasmine.Spy };
let heroService: HeroService;

beforeEach(() => {
  // TODO: spy on other methods too
  httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);
  heroService = new HeroService(<any> httpClientSpy);
});

it('should return expected heroes (HttpClient called once)', () => {
  const expectedHeroes: Hero[] =
    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];

  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));

  heroService.getHeroes().subscribe(
    heroes => expect(heroes).toEqual(expectedHeroes, 'expected heroes'),
    fail
  );
  expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');
});

it('should return an error when the server returns a 404', () => {
  const errorResponse = new HttpErrorResponse({
    error: 'test 404 error',
    status: 404, statusText: 'Not Found'
  });

  httpClientSpy.get.and.returnValue(asyncError(errorResponse));

  heroService.getHeroes().subscribe(
    heroes => fail('expected an error, not heroes'),
    error  => expect(error.message).toContain('test 404 error')
  );
});
```






















