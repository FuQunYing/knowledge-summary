#Day29
## 十二、Angular模块的常见问题
### 12.forRoot()方法是什么？
	静态方法forRoot()是一个约定，可以让开发人员更轻松的配置模块的提供商。
	RouterModule.forRoot()就是一个很好的例子，应用把一个Routes对象传给RouterModule.forRoot(),为的就是使用路由配置全应用级的Router服务，RouterModule.forRoot()返回一个ModuleWithProviders对象，然后把这个结果添加到根模块的AppModule的imports数组中。只能在应用的根模块AppModule中调用并导入.forRoot()的结果，在其它模块中导入它，特别是惰性加载中，是违反设计目标的并会导致运行时错误。
	RouterModule也提供了静态方法forChild，用于配置惰性加载模块的路由。forRoot和forChild都是约定俗称的方法名，它们分别用于在根模块和特性模块中配置服务。
### 13.为什么服务提供商在特性模块中的任何地方都是可见的？
	列在引导模块的@NgModule的providers中的服务提供商具有全应用级作用域，往NgModule的providers中添加服务提供商将导致该服务被发布到整个应用中。当我导入一个模块时，Angular就会把该模块的服务提供商也就是providers列表中的内容加入该应用的根注入器中。这会让该提供商对应用中所有知道该提供商token的类都可见。
	Angular就是如此设计的，通过模块导入来实现可扩展性是Angular模块系统的主要设计目标。把模块的提供商并入应用程序的注入器可以让库模块使用新的服务来强化应用程序来变得更容易。只要添加一次HttpClientModule，那么应用中的每个组件都可以发起http请求了。不过如果我期望模块的服务只对那个特定模块内部声明的组件可见，那么这可能会带来一些讨厌的意外，如果PersonModule提供了PersonService，并且根模块AppModule导入了PersonModule，那么任何知道PersonService类型的类都可能注入该服务，而不仅是在PersonModule中声明的那些类。
### 14.为什么在惰性加载模块中声明的服务提供商只对该模块自身可见？
	和启动时就加载的模块中的提供商不同，惰性加载模块中的提供商是局限于模块的。当Angular路由器惰性加载一个模块时，它创建了一个新的运行环境，那个环境拥有自己的注入器，它是应用注入器的直属子级。路由器把该惰性加载模块的提供商和它导入的模块的提供商添加到这个子注入器中。
	这些提供商不会被拥有相同token的应用级别提供商的变化所影响。当路由器在惰性加载环境中创建组件时，Angular优先使用惰性加载模块中的服务实例，而不是来自应用的根注入器。
### 15.如果两个模块提供了同一个服务会怎么样？
	当同时加载了两个导入的模块，它们都列出了使用同一个token的提供商时，后导入的模块会被用到，这是因为这两个提供商都被添加到了同一个注入器中。当Angular尝试根据token注入服务的时候，就会使用第二个提供商来创建并交付服务的实例。
	每个注入了该服务的类获得的都是由第二个提供商创建的实例，即使是声明在第一个模块中的类，它取得的实例也是来自第二个服务提供商。如果模块A提供了一个使用token“X"的服务，并且导入的模块B也用token”X“提供了一个服务，那么就是模块A的服务会被使用。由AppModule提供的的服务相对于所导入的模块中提供的服务有优先权。
### 16.如何把服务的范围限制到模块中？
	如果一个模块在应用程序启动时就加载，它的@NgModule的provides具有全应用级作用域。它们也可用于整个应用的注入中。导入的提供商很容易被由其它导入模块中的提供商替换掉，虽然设计是这样设计的，但是很有肯能导致一些以外的结果。作为一个通用的规则，应该只导入一次带提供商的的模块，最好在应用的根模块中，那里也是配置、包装和改写这些服务的地方。
	假设模块需要一个定制过的HttpBackend，它为所有的Http请求添加一个特别的请求头，如果应用中其它地方的另一个模块也定制了HttpBackend或仅仅导入了HttpClientModule，他就会改写当前模块的HttpBackend提供商，丢掉了这个特别的请求头，这样服务器就会拒绝来自该模块的请求。要消除这个问题就只能在应用的根模块AppModule中导入了HttpClientModule，如果必须防范这种提供商腐化现象，那就不要依赖于启动时加载模块的providers。只要可能就让模块惰性加载，Angular给了惰性加载模块自己的子注入器。该模块中的提供商只对由该注入器创建的组件树可见。如果有的时候我必须在应用程序启动的时候主动加载该模块，就改成在组件中提供该服务。
	假如有个模块真的需要一个私有的自定义的HttpBackend。那就创建一个顶级组件来扮演该模块中所有组件的根，把这个自定义的HttpBackend提供商添加到这个顶级组件的providers列表里面，而不是该模块的providers。那么，Angular会为每一个组件实例创建一个子注入器，并使用组件自己的providers来配置这个注入器。当该组件的子组件想要一个HttpBackend服务时，Angular会提供一个局部的HttpBackend服务，而不是应用的根注入器创建的那个。子组件将正确发起http请求，而不管其它模块对HttpBackend做了什么。
	确保把模块中的组件都创建成这个顶级组件的子组件。我就可以把这些子组件都嵌在顶级组件的模板中，或者给顶级组件一个<router-outlet>，让它作为路由的宿主，定义子路由，并让路由器把模块中的组件加载进该路由出口中。
### 17.全应用级的提供商应该加到根模块还是根组件?
	都说了是全应用级，当然是加进根模块AppModule了。惰性加载模块及其组件可以注入AppModule中的服务，却不能注入AppComponent中的。
	只有当该服务必须对AppComponent组件树之外的组件不可见时，才能把服务注册进AppComponent的providers中，但是这个方法就比较异类了，所以一般情况下，优先把提供商注册进模块中，而不是组件中。
	ps：
	Angular把所有启动期模块的提供商都注册进了应用的根注入器中，这些服务是由根注入器中的提供商创建的并且在整个应用中都可用，它们具有应用级作用域。某些服务比如Router只有当注册进应用的根注入器时才能正常工作。
	相反，Angular使用AppComponent自己的注入器注册了AppComponent的提供商，AppComponent服务只在该组件及其子组件树中才能使用，它们具有组件级作用域。AppComponent的注入器是根注入器的子级，注入器层次中的下一级。这对于没有路由器的应用来说几乎是整个应用了。但对于那些带路由的应用，路由器操作位于顶层，哪里不存在AppComponent的服务。这意味着惰性加载模块不能使用它们。
### 18.其它的提供商注册到模块中还是组件中？
	通常优先把模块中具体的特性的提供商注册到模块中（@NgModule.providers），而不是组件中（@Component.providers）。当必须把服务实例的范围限制到某个组件及其子组件树时，就把提供商注册到该组件中，指令的提供商也同样照此处理。
	比如如果人物编辑组件需要自己私有的缓存人物服务实例，那就应该把PersonService注册进PersonEditorComponent里面。这样每个新的PersonEditorComponent的实例都会得到自己的缓存服务实例，编辑器的改动只会作用域他自己的服务，而不会影响到应用中其它地方的人物实例。总是在根模块AppModule中注册全应用级服务，而不要在根组件AppComponent里面。
### 19.为什么在共享模块中不能为惰性加载模块提供服务？
####19.1 立即加载的场景
	当立即加载的模块提供了服务时，比如UserService，该服务是在全应用级可用的，如果根模块提供了UserService，并导入了另一个也提供了同一个UserService的模块，Angular就会把它们中的一个注册进应用的根注入器中，并交付这个全应用级的单例服务。这样不会出现问题。
#### 19.2 惰性加载的场景
	现在，有PersonModule的说，它是惰性加载的。当路由器准备惰性加载PersonModule的时候，它会创建一个子注入器，并且把UserService的提供商注册到那个子注入器中。子注入器和根注入器是不同的。当Angular创建一个惰性加载的PersonComponent时，它必须注入一个UserService。这次，它会从惰性加载模块的子注入器中查找UserService的提供商，并用它创建一个UserService的实例，这个UserService实例与Angular在主动加载的组件中注入的那个全应用级单例对象是不一样的。这个场景导致应用每次都创建一个新的服务实例，而不是使用单例的服务。
### 20.为什么惰性加载模块会创建一个子注入器？
	Angular会把@NgModule.providers中的提供商添加到应用的根注入器中，除非该模块是惰性加载的，这种情况下，它会创建一子注入器，并且把该模块的提供商添加到这个子注入器中。这意味这模块的行为将取决于它是在应用启动期间加载的还是后来惰性加载的。
	所以那么是为什么Angular不能像主动加载模块那样把惰性加载模块的提供商也添加到应用程序的根注入器中呢？为啥出现这种不一致呢？
	归根结底，这来自于 Angular 依赖注入系统的一个基本特征： 在注入器还没有被第一次使用之前，可以不断为其添加提供商。 一旦注入器已经创建和开始交付服务，它的提供商列表就被冻结了，不再接受新的提供商。当应用启动时，Angular 会首先使用所有主动加载模块中的提供商来配置根注入器，这发生在它创建第一个组件以及注入任何服务之前。 一旦应用开始工作，应用的根注入器就不再接受新的提供商了。之后，应用逻辑开始惰性加载某个模块。 Angular 必须把这个惰性加载模块中的提供商添加到某个注入器中。 但是它无法将它们添加到应用的根注入器中，因为根注入器已经不再接受新的提供商了。 于是，Angular 在惰性加载模块的上下文中创建了一个新的子注入器。
### 21.如何知道一个模块或者服务是否已经加载过了？
	某些模块及其服务只能被根模块AppModule加载一次。在惰性加载模块中再次导入这个模块会导致错误行为，而且这个错误可能非常难于检测和诊断。
	为了防范这种风险，可以写一个构造函数，它会尝试从应用的根注入器中注入该模块或服务。如果这种注入成功了，那就说明这个类是被第二次加载的，就可以抛出一个错误，或者萃取一些其它措施。
**core.module.ts**
```typescript
constructor （@Optional() @SkipSelf() parentModule: CoreModule） {
  if(parentModule) {
    throw new Error("CoreModule 已经加载过了，只需要在AppModule里面引入即可")
  }
}
```
### 22.什么是入口组件？
	Angular根据其类型不可避免的加载的组件就是入口组件。而通过组件选择器声明式加载的组件则不是入口组件。
	大多数应用组件都是声明式加载的，Angular使用该组件的选择器在模板中定位元素，然后创建变现该组件的HTML，并把它插入DOM中所选元素的内部，它们不是入口组件。而用于引导的根AppComponent则是一个入口组件，虽然它的选择器匹配了index.html中的一个元素，但是index.html并不是组件模板，而且AppComponent选择器也不回在任何组件模板中出现。在路由定义中用到的组件也同样是入口组件。路由定义根据类型来引导组件。路由定义格局类型来引用组件。路由器会忽略路由组件的选择器即使它是有选择器的，并且把该组件动态加载到RouterOutlet中。
### 23.引导组件和入口组件有什么不同？
	引导组件是入口组件的一种，它是被Angular的引导过程加载到DOM中的入口组件，其它入口组件则是被其它方式动态加载的，比如被路由器加载。@NgModule.bootstrap属性告诉编译器这是一个入口组件，同时它应该生成一些代码来用改组加你引导此应用。
	不需要把组件同时列在bootstrap和entrycomponent列表中。
### 24.什么时候应该把组件加载entryComponents里面？
	大多数是不需要把组件添加到entryComponents中。Angular会自动把恰当的组件添加到入口组件中。列在@NgModule.bootstrap中的组件会自动加入。由路由器配置引用到的组件会被自动加入。用这两种机制添加的组件在入口组件中占了绝大多数。
	如果我的应用要用其它手段来根据类型引导或动态加载组件，那就得把它显式添加到entryComponents中。虽然把组件加到这个列表中没什么坏处，但是最好还是只添加真正的入口组件。不要添加那些被其它组件的模板引用过的组件。
### 25.为啥Angular需要入口组件？
	原因在于优化，对于产品化的应用，就想加载尽可能小而快的代码。代码中应该仅仅包括那些实际用到的类。它应该排除那些从未用过的组件，无论该组件是否被声明过。事实上，大多数库中声明和导出的组件都用不到。如果从未引用它们，那么优化器就会从最终的代码中把这些组价砍掉。
	如果Angular编译器为每个声明的组件都生成了代码，那么优化器的作用就没有了。所以，编译器转而采用一种递归策略，它只为我用到的那些组价生成代码。编译器从入口组件开始工作，为它在入口组件的模板中找到的那些组件生成代码，然后又为在这些组件中的模板发现的组件生成代码，以此类推，当这个过程结束时，它就已经为每个入口组件以及从入口组件可以抵达的每个组件生成了代码。如果该组件不是入口组件或者没有在任何模板中发现过，就会被编译器忽略。
### 26.有哪些类型的模块？应该如何使用？
####26.1 SharedModule
	为那些可能会在应用中到处使用的组件、指令和管道创建SharedModule，这种模块应该只包含declarations，并且应该导出几乎所有的declarations里面的声明。SharedModule可以重新导出其它小部件模块，比如CommonModule，FormsModule和提供给我广泛使用的UI控件的那些模块。
	前面说到SharedModule不应该带有providers，它的导入或者重新导出的模块中也不应该有providers。在任何特性模块中，不论是在应用启动时主动加载的模块还是之后惰性加载的模块，都可以随意导入这个SharedModule。
#### 26.2 CoreModule
	为我要在应用启动时加载的那些服务创建一个带providers的CoreModule。也可以CoreModule做成一个没有declarations的纯服务模块
#### 26.3 特性模块
	特性模块就是我围绕特定的应用业务领域创建的模块，比如用户工作流、小工具集等。它们包含指定的特性，并为我的应用提供支持，比如路由、服务、窗口部件等。要对我的应用中可能会有哪些特性模块有个概念，考虑如果要把与特定功能有关的文件放进一个目录下，该目录的内容就可能就是一个名叫XXXModule的特性模块。它将会包含构成某某特定功能的全部组件、路由和模板。
### 27.在NgModule和JavaScript模块之间有什么不同？
	在Angular应用中，NgModule会和JavaScript的模块一起工作。在现在的JavaScript中，每个文件都是模块。在每个文件中，要写一个export的语句将模块的一部分公开。
	Angular模块是一个带有@NgModule装饰器的类，而JavaScript模块则没有。Angular的NgModule有自己的imports和exports来达到类似的目的。我可以导入其它Angular模块，以便在当前模块的组件模板中使用它们导出的类，我也可以导出当前Angular模块中的类，以便其它模块可以导入它们，并用在自己的组件模板中。
### 28.Angular如何查找模板中的组件、指令和管道？什么是模板引用？
	Angular编译器在组件模板内查找其它组件、指令和管道。一旦找到了，那就是一个模板引用。Angular编译器通过在一个模板的HTML中匹配组件或指令的选择器，来查找组件或指令。编译器通过分析模板HTML中的管道语法中是否出现了特定的管道名来查找对应的管道。Angular只查询两种组件、指令或管道：那些在当前模块中声明过的以及那些被当前模块导入的模块所导出的。
### 29.什么是Angular编译器？
	Angular编译器会把我所编写的应用代码转换成高性能的JavaScript代码，在编译过程中，@NgModule的元数据就扮演了很重要的角色。自己写的代码是无法直接执行的。比如组件，组件有一个模板，其中包含了自定义元素、属性型指令、Angular绑定声明和一些不属于原生HTML的语法啥的。
	Angular编译器读取模板的HTML，把它和相应的组件类代码组合在一起，并产出组件工厂。组件工厂为创建纯粹的、100%JavaScript的表示形式，它包含了@Component元数据中的描述的一切：HTML、绑定指令、附属的样式等。由于指令和管道都出现在组件模板中，Angular编译器也同样会把它们组合到编译成的组件代码中，@NgModule元数据告诉Angular编译器要为当前模块编译那些组件，以及如何把当前模块和其它模块连接起来。
### 30.凑个整数....

























