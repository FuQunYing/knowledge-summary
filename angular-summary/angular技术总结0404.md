#Day29
## 十二、Angular模块的常见问题
### 12.forRoot()方法是什么？
	静态方法forRoot()是一个约定，可以让开发人员更轻松的配置模块的提供商。
	RouterModule.forRoot()就是一个很好的例子，应用把一个Routes对象传给RouterModule.forRoot(),为的就是使用路由配置全应用级的Router服务，RouterModule.forRoot()返回一个ModuleWithProviders对象，然后把这个结果添加到根模块的AppModule的imports数组中。只能在应用的根模块AppModule中调用并导入.forRoot()的结果，在其它模块中导入它，特别是惰性加载中，是违反设计目标的并会导致运行时错误。
	RouterModule也提供了静态方法forChild，用于配置惰性加载模块的路由。forRoot和forChild都是约定俗称的方法名，它们分别用于在根模块和特性模块中配置服务。
### 13.为什么服务提供商在特性模块中的任何地方都是可见的？
	列在引导模块的@NgModule的providers中的服务提供商具有全应用级作用域，往NgModule的providers中添加服务提供商将导致该服务被发布到整个应用中。当我导入一个模块时，Angular就会把该模块的服务提供商也就是providers列表中的内容加入该应用的根注入器中。这会让该提供商对应用中所有知道该提供商token的类都可见。
	Angular就是如此设计的，通过模块导入来实现可扩展性是Angular模块系统的主要设计目标。把模块的提供商并入应用程序的注入器可以让库模块使用新的服务来强化应用程序来变得更容易。只要添加一次HttpClientModule，那么应用中的每个组件都可以发起http请求了。不过如果我期望模块的服务只对那个特定模块内部声明的组件可见，那么这可能会带来一些讨厌的意外，如果PersonModule提供了PersonService，并且根模块AppModule导入了PersonModule，那么任何知道PersonService类型的类都可能注入该服务，而不仅是在PersonModule中声明的那些类。
### 14.为什么在惰性加载模块中声明的服务提供商只对该模块自身可见？
	和启动时就加载的模块中的提供商不同，惰性加载模块中的提供商是局限于模块的。当Angular路由器惰性加载一个模块时，它创建了一个新的运行环境，那个环境拥有自己的注入器，它是应用注入器的直属子级。路由器把该惰性加载模块的提供商和它导入的模块的提供商添加到这个子注入器中。
	这些提供商不会被拥有相同token的应用级别提供商的变化所影响。当路由器在惰性加载环境中创建组件时，Angular优先使用惰性加载模块中的服务实例，而不是来自应用的根注入器。
### 15.如果两个模块提供了同一个服务会怎么样？
	当同时加载了两个导入的模块，它们都列出了使用同一个token的提供商时，后导入的模块会被用到，这是因为这两个提供商都被添加到了同一个注入器中。当Angular尝试根据token注入服务的时候，就会使用第二个提供商来创建并交付服务的实例。
	每个注入了该服务的类获得的都是由第二个提供商创建的实例，即使是声明在第一个模块中的类，它取得的实例也是来自第二个服务提供商。如果模块A提供了一个使用token“X"的服务，并且导入的模块B也用token”X“提供了一个服务，那么就是模块A的服务会被使用。由AppModule提供的的服务相对于所导入的模块中提供的服务有优先权。
### 16.如何把服务的范围限制到模块中？
	如果一个模块在应用程序启动时就加载，它的@NgModule的provides具有全应用级作用域。它们也可用于整个应用的注入中。导入的提供商很容易被由其它导入模块中的提供商替换掉，虽然设计是这样设计的，但是很有肯能导致一些以外的结果。作为一个通用的规则，应该只导入一次带提供商的的模块，最好在应用的根模块中，那里也是配置、包装和改写这些服务的地方。
	假设模块需要一个定制过的HttpBackend，它为所有的Http请求添加一个特别的请求头，如果应用中其它地方的另一个模块也定制了HttpBackend或仅仅导入了HttpClientModule，他就会改写当前模块的HttpBackend提供商，丢掉了这个特别的请求头，这样服务器就会拒绝来自该模块的请求。要消除这个问题就只能在应用的根模块AppModule中导入了HttpClientModule，如果必须防范这种提供商腐化现象，那就不要依赖于启动时加载模块的providers。只要可能就让模块惰性加载，Angular给了惰性加载模块自己的子注入器。该模块中的提供商只对由该注入器创建的组件树可见。如果有的时候我必须在应用程序启动的时候主动加载该模块，就改成在组件中提供该服务。
	假如有个模块真的需要一个私有的自定义的HttpBackend。那就创建一个顶级组件来扮演该模块中所有组件的根，把这个自定义的HttpBackend提供商添加到这个顶级组件的providers列表里面，而不是该模块的providers。那么，Angular会为每一个组件实例创建一个子注入器，并使用组件自己的providers来配置这个注入器。当该组件的子组件想要一个HttpBackend服务时，Angular会提供一个局部的HttpBackend服务，而不是应用的根注入器创建的那个。子组件将正确发起http请求，而不管其它模块对HttpBackend做了什么。
	确保把模块中的组件都创建成这个顶级组件的子组件。我就可以把这些子组件都嵌在顶级组件的模板中，或者给顶级组件一个<router-outlet>，让它作为路由的宿主，定义子路由，并让路由器把模块中的组件加载进该路由出口中。
### 17.全应用级的提供商应该加到根模块还是根组件?
	都说了是全应用级，当然是加进根模块AppModule了。惰性加载模块及其组件可以注入AppModule中的服务，却不能注入AppComponent中的。
	只有当该服务必须对AppComponent组件树之外的组件不可见时，才能把服务注册进AppComponent的providers中，但是这个方法就比较异类了，所以一般情况下，优先把提供商注册进模块中，而不是组件中。
	ps：
	Angular把所有启动期模块的提供商都注册进了应用的根注入器中，这些服务是由根注入器中的提供商创建的并且在整个应用中都可用，它们具有应用级作用域。某些服务比如Router只有当注册进应用的根注入器时才能正常工作。
	相反，Angular使用AppComponent自己的注入器注册了AppComponent的提供商，AppComponent服务只在该组件及其子组件树中才能使用，它们具有组件级作用域。AppComponent的注入器是根注入器的子级，注入器层次中的下一级。这对于没有路由器的应用来说几乎是整个应用了。但对于那些带路由的应用，路由器操作位于顶层，哪里不存在AppComponent的服务。这意味着惰性加载模块不能使用它们。
### 18.其它的提供商注册到模块中还是组件中？
	通常优先把模块中具体的特性的提供商注册到模块中（@NgModule.providers），而不是组件中（@Component.providers）。当必须把服务实例的范围限制到某个组件及其子组件树时，就把提供商注册到该组件中，指令的提供商也同样照此处理。
	比如如果人物编辑组件需要自己私有的缓存人物服务实例，那就应该把PersonService注册进PersonEditorComponent里面。这样每个新的PersonEditorComponent的实例都会得到自己的缓存服务实例，编辑器的改动只会作用域他自己的服务，而不会影响到应用中其它地方的人物实例。总是在根模块AppModule中注册全应用级服务，而不要在根组件AppComponent里面。
### 19.为什么在共享模块中不能为惰性加载模块提供服务？
####19.1 立即加载的场景
	当立即加载的模块提供了服务时，比如UserService，该服务是在全应用级可用的，如果根模块提供了UserService，并导入了另一个也提供了同一个UserService的模块，Angular就会把它们中的一个注册进应用的根注入器中，并交付这个全应用级的单例服务。这样不会出现问题。
#### 19.2 惰性加载的场景
	现在，有PersonModule的说，它是惰性加载的。当路由器准备惰性加载PersonModule的时候，它会创建一个子注入器，并且把UserService的提供商注册到那个子注入器中。子注入器和根注入器是不同的。当Angular创建一个惰性加载的PersonComponent时，它必须注入一个UserService。这次，它会从惰性加载模块的子注入器中查找UserService的提供商，并用它创建一个UserService的实例，这个UserService实例与Angular在主动加载的组件中注入的那个全应用级单例对象是不一样的。这个场景导致应用每次都创建一个新的服务实例，而不是使用单例的服务。
### 20.为什么惰性加载模块会创建一个子注入器？
	Angular会把@NgModule.providers中的提供商添加到应用的根注入器中，除非该模块是惰性加载的，这种情况下，它会创建一子注入器，并且把该模块的提供商添加到这个子注入器中。这意味这模块的行为将取决于它是在应用启动期间加载的还是后来惰性加载的。
	所以那么是为什么Angular不能像主动加载模块那样把惰性加载模块的提供商也添加到应用程序的根注入器中呢？为啥出现这种不一致呢？
	归根结底，这来自于 Angular 依赖注入系统的一个基本特征： 在注入器还没有被第一次使用之前，可以不断为其添加提供商。 一旦注入器已经创建和开始交付服务，它的提供商列表就被冻结了，不再接受新的提供商。当应用启动时，Angular 会首先使用所有主动加载模块中的提供商来配置根注入器，这发生在它创建第一个组件以及注入任何服务之前。 一旦应用开始工作，应用的根注入器就不再接受新的提供商了。之后，应用逻辑开始惰性加载某个模块。 Angular 必须把这个惰性加载模块中的提供商添加到某个注入器中。 但是它无法将它们添加到应用的根注入器中，因为根注入器已经不再接受新的提供商了。 于是，Angular 在惰性加载模块的上下文中创建了一个新的子注入器。
### 21.如何知道一个模块或者服务是否已经加载过了？
	某些模块及其服务只能被根模块AppModule加载一次。在惰性加载模块中再次导入这个模块会导致错误行为，而且这个错误可能非常难于检测和诊断。
	为了防范这种风险，可以写一个构造函数，它会尝试从应用的根注入器中注入该模块或服务。如果这种注入成功了，那就说明这个类是被第二次加载的，就可以抛出一个错误，或者萃取一些其它措施。
**core.module.ts**
```typescript
constructor （@Optional() @SkipSelf() parentModule: CoreModule） {
  if(parentModule) {
    throw new Error("CoreModule 已经加载过了，只需要在AppModule里面引入即可")
  }
}
```
### 22.什么是入口组件？
	Angular根据其类型不可避免的加载的组件就是入口组件。而通过组件选择器声明式加载的组件则不是入口组件

























