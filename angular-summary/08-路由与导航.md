# 路由与导航
## 一、概览
 浏览器具有熟悉的导航模式：
 - 在地址栏输入URL，浏览器就会导航到响应的页面
 - 在页面中点击链接，浏览器就会导航到一个新的页面
 - 点击浏览器的前进和后退按钮，浏览器就会在我的浏览历史中向前或向后导航
    Angular的Router借鉴了这个模型，他把浏览器中的URL看做一个操作指南，据此导航到一个客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。我可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。当用户点击按钮、从下拉框中选取，或响应来自任何地方的事件时，我也可以在代码控制下进行导航。路由器还在浏览器的历史日志中记录下这些活动，这样浏览器的前进和后退按钮也能照常工作。
## 二、基础知识
### 1.<base href> 元素
  大多数带路由的应用都要在index.html的<head>标签下先添加一个<base>元素，来告诉路由器该如何合成导航用的URL。如果app文件夹是该应用的根目录，那就把href的值设置为这样：
```html
<base href='/'>
```
### 2.从路由库中导入
  Angular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。它并不是Angular核心库的一部分，而是在它自己的@angular/router包中，像其它Angular包一样，我可以从它导入所需的一切：
```typescript
import {RouterModule,Routes} from '@angular/router'
```
### 3.配置
  ，每个带路由的Angular应用都有一个Router服务的单例对象。当浏览器的URL变化时，路由器会查找对应的Route，并据此决定该显示哪个组件。
  路由器需要先配置才会有路由信息。下面的例子创建了四个路由定义，并用RouterModule.forRoot方法来配置路由器，并把它的返回值添加到AppModule的imports数组中：
```typescript
const appRoutes:Routes=[
    {path: 'crisis-center', component: CrisisListComponent},
    {path: 'person/:id', component: PersonDetailCompoennt},
    {path: 'persons': component:PersonListComponent,data: {title:'Persons List'}},
    {path: '',redirectTo:'/persons',pathMatchL'full'},
    {path: '**', component: PageNotFoundComponet}
];
@NgModule({
    imports:[
        RouterModule.forRoot(
          appRoutes,
          {enableTracing:true}// 仅调试用
        )
        //其它引入接着往后放就行
    ],
    ...
})
export class AppModule{}
```
  这里的路由数组appRoutes描述如何进行导航。把它传给RouterModule.forRoot方法并传给本模块的imports数组就可以配置路由器。每个Route都会把一个URL的path映射到一个组件。注意，path不能以 / 开头。路由器会为加息和构建最终的URL，这样当我的应用在多个视图之间导航时，可以任意使用相对路径和绝对路径。
  第二个路由中的:id是一个路由参数的token，比如/person/01这个URL中，01就是id参数的值，此URL对应的PersonDetailComponent组件将据此查找和展现id为42的人物。第三个路由中的data属性用来存放每个具体路由有关的任意信息。该数据可以被任何一个激活路由与访问，并能用来保存诸如页标题、面包屑以及其它静态只读数据。第四个个路由中的空路径表示应用的默认路径，当URL为空时就会访问那里，因此它通常会作为起点。这个默认路由会重定向到URL/persons，并显示PersonsListComponent。最后一个路由中的\*\*路径是一个通配符。当所请求的URL不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。这个特性可以用于显示404-not found 页，或自动重定向到其它路由。
  这些路由的定义顺序是刻意如此设计的。路由器使用先匹配者优先的策略来匹配路由，所以具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由，而通配符路由被放在最后面，这是因为它能匹配上每一个URL，因此应该只有在前面找不到其它能匹配的路由时才匹配它。
  如果想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的enableTracing选项。它会把每个导航生命周期中的事件输出到浏览器的控制台，这应该只用于调试。我只需要把enableTracing:true选项作为第二个参数传给RouterModule.forRoot()方法就可以了。
### 4.路由出口
  有了这份配置，当本应用在浏览器中的URL变为/persons时，路由器就会匹配到path为persons的Route，并在宿主视图中的RouterOutlet之后显示PersonListComponent组件：
```html
<router-outlet></router-outlet>
<!--有这个容器，来放置组件-->
```
### 5.路由器链接
  现在我已经有了配置好的一些路由，还找到了渲染的地方，那应该如何导航过去。猿类直接从地址栏输入URL就行，但是大多数情况下，导航是某些用户操作的结果，比如点击了一个A标签：
```typescript
template:`
	<nav>
		<a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
		<a routerLink="/persons" routerLinkActive="active">Perons</a>
	</nav>
	<router-outlet></router-outlet>
`
```
  a标签上的RouterLink指令让路由器得以控制这个a元素，这里的导航路径是固定的，因此可以把一个字符串赋给routerLink。如果需要更加动态的导航路径，那就把它绑定到一个返回链接参数数组的模板表达式。路由器会把这个数组解析成完整的URL。每个a标签上的RouterLinkActivate指令可以帮用户在外观上区分出当前选中的 活动 路由，当与它关联的RouterLink被激活时，路由器会把css类active添加到这个元素上。我可以把该指令添加到a元素或它的父元素上。
### 6.路由器状态
  在导航时每个生命周期成功完成时，路由器会构建出一个ActivatedRoute组成的树，它表示路由器的当前状态。我可以在应用中的任何地方用Router服务及其routesState属性来访问当前的RouterState值。
  RouterState中的每个ActivateRoute都提供了从任意激活路由开始向上或者向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。
### 7.激活的路由
  该路由的路径和参数可以通过注入进来的一个名叫ActivatedRoute的路由服务来获取。它有一大堆信息，包括：
属性 | 说明
-- | --
url | 路由路径的Observable对象，是一个由路由路径中的各个部分组成的字符串数组
data | 一个Observable，其中包含提供给路由的data对象，也包含由解析守卫解析而来的值
paramMap | 一个Observable，其中包含一个由当前路由的必要参数和可选参数组成的map对象。用这个map可以获取来自同名参数的单一值或多重值
queryParamMap | 一个Observable，其中包含一个对所有路由都有效的查询参数组成的map对象，用这个map可以获取来自查询参数的单一值或多重值
fragment | 一个适用于所有路由的URL的fragment的Observable
outlet | 要把该路由渲染到的RouterOutlet的名字，对于无名路由，它的路由名是primary，而不是空串
routeConfig | 用于该路由的路由配置信息，其中包含原始路径
parent | 当该路由是一个子路由时，表示该路由的父级ActivatedRoute
firstChild | 包含该路由的子路由列表中的第一个ActivatedRoute
children | 包含当前路由下所有已激活的子路由
  有两个旧式属性仍然是有效的，但它们不如其替代品那样强力，建议不再使用，将来也有可能被废弃：
  - params -- 一个Observable对象，其中包含当前路由的必要参数和可选参数，改用paramMap
  - queryParams --一个Observable对象，其中包含对所有路由都有效的查询参数，改用queryParamMap
### 8.路由事件
  在每次导航中，Router都会通过Router.events属性发布一些导航事件。这些事件的范围涵盖了从开始导航到结束导航之间的很多时间点。下表中列出了全部导航事件：
路由器事件 | 说明
-- | --
NavigationStart | 本事件会在导航开始时触发
RoutesRecognized | 本事件会在路由器解析完URL，并识别出了响应的路由时触发
RouteConfigLoadStart | 本事件会在Router对一个路由配置进行惰性加载之前触发
RouteConfigLoadEnd | 本事件会在路由被惰性加载之后触发
NavigationEnd | 本事件会在导航成功结束之后触发
NavigationCancel | 本事件会在导航被取消之后触发，这可能是因为在导航期间某个路由守卫返回了false
NavigationError | 这个事件会在导航由于意料之外的错误而失败时触发
  当打开了enableTracing选项时，这些事件也同时会记录到控制台中，由于这些事件是以Observable的形式提供的，所以我可以对自己感兴趣的事件进行filter()，并subscribe()它们，以便根据导航过程中的事假顺序做出决策。
### 9.总结一下
  该应用有一个配置过的路由器，外壳组件中有一个RouterOutlet，它能显示路由器所生成的视图。他还有一些RouterLink，用户可以点击，来通过路由器进行导航。下面是一些路由器中的关键词汇及其含义
路由器部件 | 含义
-- | --
Router | 为激活的URL显示应用组件，管理从一个组件到另一个组件的导航
RouterModule | 一个独立的Angular模块，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令
Routes（路由数组） | 定义了一个路由数组，每一个都会把一个URL路由映射到一个组件
Route（路由） | 定义路由器该如何根据URL模式来导航到组件。大多数路由都是由路径和组件类构成
RouterOutlet（路由出口） | 该指令用来标记出路由器应该在哪里显示视图
RouterLink（路由链接） | 这个指令把可点击的HTML元素绑定到某个路由，点击带有routerLink指令（绑定到字符串或链接参数数组）的元素时就会触发一次导航
RouterLinkActive（活动路由链接） | 当 HTML 元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类。
ActivatedRoute（激活的路由） | 为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。
RouterState（路由器状态） | 路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。
链接参数数组  | 这个数组会被路由器解释成一个路由操作指南。你可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法。
路由组件  | 一个带有RouterOutlet的 Angular 组件，它根据路由器的导航来显示相应的视图。
## 三、范例应用
  现在要说的是如何开发一个带路由的多页面应用。接下来重点说它的设计决策，并描述路由的关键特性，如果：
  - 把应用的各个特性组织成模块
  - 导航到组件（Persons链接到 人物列表 组件）
  - 包含一个路由参数（当路由到 人物详情 时，把该英雄的id传进去
  - 子路由（危机中心特性有一组自己的路由）
  - CanActivate守卫（检查路由的访问权限）
  - CanActivateChild守卫（检查子路由的访问权限）
  - CanDeactivate守卫（询问是否丢弃为保存的更改）
  - Resolve守卫（预先获取路由数据）
  - 惰性加载特性模块
  - CanLoad守卫（在加载特性模块之前进行检查）
## 四、从路由器开始
### 1.设置<base href>
  路由器使用浏览器的history.pushState进行导航。有了pushState，就能按所期望的样子来显示应用内部的URL路径，虽然我使用的全部是客户端合成的视图，但应用内部的这些URL看起来和来自服务器的没什么不同。
  必须往本应用的index.html添加一个<base href>元素，这样pushState才能正常工作。当引用CSS文件、脚本和图片时，浏览器会用<base href>的值作为相对URL的前缀。把<base>元素添加到<head>元素中。如果app目录是应用的根目录，对于本应用，可以像这样设置index.html中的href值：
```html
<base href="/">
```
### 2.从路由库中导入
  先从路由库导入一些符号，路由器在它自己的@angular/router包中。它不是Angular内核的一部分，该路由器是可选的服务，这是因为并不是所有应用都需要路由，并且，如果需要还可能需要另外的路由库。
  通过一些路由来配置路由器，可以教路由器如何进行导航
#### 2.1 定义路由
  路由器必须用路由定义的列表进行配置。第一个配置中定义了由两个路由构成的数组，它们分别通过path导航到了CrisisListComponent 和 PersonListComponent 组件。
  每个定义都被翻译成了一个Route对象。该对象有一个path字段，表示该路由中的URL路径部分，和一个component字段，表示与该路由相关联的组件。当浏览器的URL变化时或在代码中告诉路由器导航到一个路径时，路由器就会翻出它用来保存这些路由定义的注册表。
  直白的说，可以这样解释第一个路由：
  - 当浏览器地址栏的URL变化时，如果它匹配上了路径部分/cirisis-center，路由器就会激活一个CrisisListComponent的实例，并显示它的视图
  - 当应用程序请求导航到路径/crisis-center时，路由器激活一个CrisisListComponent实例，显示它的视图，并将该路径更新到浏览器地址栏和历史。
    下面是第一个配置，把路由数组传递到RouterModule.forRoot方法，该方法返回一个包含已配置的Router服务提供商模块和一些其它路由包需要的服务提供商。应用启动时，Router将在当前浏览器URL的基础上进行初始导航：
```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { RouterModule, Routes } from '@angular/router';

import { AppComponent }          from './app.component';
import { CrisisListComponent }   from './crisis-list.component';
import { PersonListComponent }     from './person-list.component';

const appRoutes: Routes = [
  { path: 'crisis-center', component: CrisisListComponent },
  { path: 'persons', component: PersonListComponent },
];

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } // 调试用
    )
  ],
  declarations: [
    AppComponent,
    PersonListComponent,
    CrisisListComponent,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```
  在AppModule中提供RouterModule，让该路由器在应用的任何地方都能被使用。作为简单的路由配置，将添加配置好的RouterModule到AppModule中就足够了。随着应用的成长，需要将路由配置重构到单独的文件，并创建路由模块。
### 3.AppComponent外壳组件
  根组件AppComponent是本应用的外壳。它在顶部有一个标题、一个带两个链接的导航条，在底部有一个路由器出口，路由器会在它所指定的位置上把视图切入或调出页面。
  该组件所对应的模板是这样的：
```typescript
template: `
  <h1>Angular Router</h1>
  <nav>
    <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
    <a routerLink="/persons" routerLinkActive="active">Persons</a>
  </nav>
  <router-outlet></router-outlet>
`
```
### 4.路由出口
  RouterOutlet是一个来自路由库的组件，路由器会在<router-outlet>标签中显示视图。(路由器会把router-outlet元素添加到了DOM中，紧接着立即在这个之后插入导航到的视图元素)
### 5.routerLink绑定
  每个A标签还有一个到RouterLinkActive指令的属性绑定，就像routerLinkActive="..."。等号右边的模板表达式包含用空格分割的一些CSS类。当路由激活时路由器就会把它们添加到此链接上（反之则移除）。还可以把RouterLinkActive指令绑定到一个CSS类组成的数组，如果[routerLinkActive]="['....']"。
  RouterLinkActive指令会基于当前的RouterState对象来为激活的ROuterLink切换CSS类。这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。要改变这种行为，可以把[routerLinkActiveOpttions]绑定到{exact:true}表达式，如果使用了{exact:true}，那么只有在其URL与当前URL精确匹配时才会激活指定的RouterLink。
### 6.路由器指令采集
  RouterLink、RouterLinkActivate和RouterOutlet是由RouterModule包提供的指令。现在可以把他用在模板中了。
```typescript
//app.component.ts
import (Component) from '@angular/core'
@Component({
    selector: 'app-root',
    template: `
    	 <nav>
      <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
      <a routerLink="/persons" routerLinkActive="active">Persons</a>
    </nav>
    <router-outlet></router-outlet>
    `
})
export class AppComponent{}
```
### 7.通配符路由
  之前在应用中创建过两个路由，一个是/crisis-center，另一是/persons。所有其它URL都会导致路由器抛出错误，并让应用崩溃。
  可恶意添加一个通配符来拦截所有无效的URL，并优雅的处理它们。通配符路由的path是两个星号，它会匹配任何URL。当路由器匹配不上以前定义的那些路由时，它就会选择这个路由。通配符路由可以导航到自定义的 404 notfound这种组件上去，也可以重定向到一个现有路由。
  **路由器使用先匹配者优先的策略来选择路由，通配符路由是路由配置中最没有特定性的那个，因此务必确保它是配置中的最后一个路由**
  检验这个特性，可以在PersonListComponent的模板中添加一个带有RouterLink的按钮，并且把链接设置为'/sidekinks'
```typescript
import { Component } from '@angular/core';

@Component({
  template: `
    <h2>Persons</h2>
    <p>Get your persons here</p>

    <button routerLink="/sidekicks">Go to sidekicks</button>
  `
})
export class PersonListComponent { }
```
  当用户点击该按钮的时候，应用就会失败，因为没有定义过sidekicks路由。不添加 /sidekicks路由，定义一个通配符路由，让它直接导航到PageNotFoundComponent组件：
```typescript
{ path: '**', component: PageNotFoundComponent }
```
  创建PageNotFoundComponent，以便在用户访问无效网址时显示它：
```typescript
import { Component } from '@angular/core';

@Component({
  template: '<h2>Page not found</h2>'
})
export class PageNotFoundComponent {}
```
  像其它组件一样，把PageNotFoundComponent添加到AppModule的声明中。现在当用户访问/sidekicks或任何无效的URL时，浏览器就会显示 Page not found了。浏览器的地址栏扔指向无效的URL。
### 8.把默认路由设置为人物列表
  应用启动的时候，浏览器地址栏中的初始URL是这样的：localhost:4200，它不能匹配上任何具体的路由，于是就会走到通配符路由中去，并且显示PageNotFoundComponent。
  这个应用需要有一个有效的默认路由，在这里用人物列表作为默认页，当用户点击Persons链接的时候，它应该就导航到列表页
### 9. 重定向路由
  首选方案是添加一个redirect路由来把最初的相对路径（' '）转换成期望的默认路径（/persons），浏览器地址栏会显示.../persons，就像直接导航到那里的一样。在通配符路由上方添加一个默认路由：
```typescript
const appRoutes: Routes = [
  { path: 'crisis-center', component: CrisisListComponent },
  { path: 'persons',        component: PersonListComponent },
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];
```
  重定向路由需要一个pathMatch属性，来告诉路由器如何用URL去匹配路由的路径，否则路由器就会报错。在本应用中，路由器应该是有在完整的URL等于 ' ' 的时候才选择PersonListComponent组件，因此要把pathMatch设置为‘full‘
```txt
	从技术角度说，pathMatch = 'full' 导致 URL 中剩下的、未匹配的部分必须等于 ''。 在这个例子中，跳转路由在一个顶级路由中，因此剩下的URL 和完整的URL 是一样的。
	pathMatch 的另一个可能的值是 'prefix'，它会告诉路由器：当剩下的URL 以这个跳转路由中的 prefix 值开头时，就会匹配上这个跳转路由。
	在这里不能这么做！如果 pathMatch 的值是 'prefix'，那么每个URL 都会匹配上 ''。
	尝试把它设置为 'prefix'，然后点击 Go to sidekicks 按钮。别忘了，它是一个无效 URL，本应显示“Page not found”页。 但是，你仍然在“英雄列表”页中。在地址栏中输入一个无效的 URL，你又被路由到了 /Persons。 每一个 URL，无论有效与否，都会匹配上这个路由定义。
	默认路由应该只有在整个URL 等于 '' 时才重定向到 PersonListComponent，别忘了把重定向路由设置为 pathMatch = 'full'。
```
## 五、路由模块
  在原始的路由配置中，听过了仅有两个路由的简单配置来设置应用的路由。对于简单的路由，没有问题，但是随着应用的成长，需要用到更多的路由器特性，比如守卫、解析器和子路由等，这就需要重构路由了。建议是将路由信息移到一个单独的特殊用途的模块，叫做路由模块。
  路由模块有一系列特性：
  - 把路由这个关注点从其它应用类关注点中分离出去
  - 测试特性模块时，可以替换或移除路由模块
  - 为路由服务提供商（包括守卫和解析等）提供一个共同的地方
  - 不要声明组件
### 1.将路由配置重构为路由模块
  在/app目录下创建一个名叫app-routing.module.ts的文件，以包含这个路由模块。
  导入CrisisListComponent和PersonListComponent组件，就像app.module.ts中一样，然后把Router的导入语句和路由配置以及RouterModule.forRoot移入这个路由模块中。遵循规约，添加一个AppRoutingModule类并导出它，以便稍后在AppModule中导入它。最后可以通过把它添加到该模块的exports数组中来再次导出RouterModule，通过在AppModule中导入AppRoutingModule并再次导出RouterModule，那些声明在AppModule中的组件就可以访问路由指令了，比如RouterLink和RouterOutlet。
  完事儿之后，文件就是这样的：
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { CrisisListComponent } from './crisis-list.component';
import { PersonListComponent } from './person-list.component';
import { PageNotFoundComponent } from './not-found.component';

const appRoutes: Routes = [
  { path: 'crisis-center', component: CrisisListComponent },
  { path: 'persons',        component: PersonListComponent },
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } //仅供调试
    )
  ],
  exports: [
    RouterModule
  ]
})
export class AppRoutingModule {}
```
  接下来，修改 app.module.ts 文件，首先从 app-routing.module.ts 中导入新创建的 AppRoutingModule， 然后把 imports 数组中的 RouterModule.forRoot 替换为 AppRoutingModule。
```typescript
import { NgModule }       from '@angular/core';
import { BrowserModule }  from '@angular/platform-browser';
import { FormsModule }    from '@angular/forms';

import { AppComponent }     from './app.component';
import { AppRoutingModule } from './app-routing.module';

import { CrisisListComponent }   from './crisis-list.component';
import { PersonListComponent }     from './person-list.component';
import { PageNotFoundComponent } from './not-found.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    PersonListComponent,
    CrisisListComponent,
    PageNotFoundComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```
### 2.是否需要路由模块
  路由模块在根模块或者特性模块替换了路由配置，在路由模块或者模块内部配置路由，但不要同时在两处都配置。路由模块是设计选择，它的价值在配置很复杂，并包含专门守卫和解析器服务时尤其明显。在配置很简单时，它可能就是多余的了。
  在配置很简答时，一些开发者跳过路由模块，并将路由配置直接混合在关联模块中。
  从中选择一种模式，并坚持模式的一致性。大多数开发者都应该采用路由模块，以保持一致性，它在配饰复杂时，能确保代码干净，它让测试特性模块更加容易，它的存在让人一眼就能看出这个模块是带路由的。开发者可以很自然的从路由模块中查找和扩展路由配置。
## 六、人物特征区
  知道了如何用RouterLink指令进行导航，接下来要：
  - 用模块把应用和路由组织为一些特性区
  - 命令式的从一个组件导航到另一个
  - 通过路由传递必要的信息和可选信息
    典型的应用具有多个特性区，每个特性区都专注于特定的业务用途。虽然可以把文件都放在src/app目录下，但是这并不现实，后期很难维护，大部分开发人员更喜欢把每个特性区都放在它自己的目录下。
    现在我准备把应用拆分成多个不同的特性模块，每个特有模块都有自己的关注点，然后，我就可以把它们导入到主模块中，并且在它们之间导航。
### 1.添加人物管理功能
  按照下面的步骤：
  - 创建src/app/persons文件夹
  - 在 app 目录下删除占位用的 person-list.component.ts 文件。
  - 在 src/app/persons 目录下创建新的 person-list.component.ts 文件。
  - 把部分代码复制到 app.component.ts 中。
  - 做一些微小但必要的修改：
      1.删除 selector（路由组件不需要它们）。
      2.删除 <h1>。
      3.给 <h2> 加文字，改成 <h2>PERSONS</h2>。
      4.删除模板底部的 <person-detail>。
      5.把 AppComponent 类改名为 PersonListComponent。
  - 把 person-detail.component.ts 和 person.service.ts 复制到 Persons 子目录下。
  - 在 persons 子目录下（不带路由）的 persons.module.ts 文件，内容如下：
```typescript
import { NgModule }       from '@angular/core';
import { CommonModule }   from '@angular/common';
import { FormsModule }    from '@angular/forms';

import { PersonListComponent }    from './person-list.component';
import { PersonDetailComponent }  from './person-detail.component';

import { PersonService } from './person.service';

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
  ],
  declarations: [
    PersonListComponent,
    PersonDetailComponent
  ],
  providers: [ PersonService ]
})
export class PersonsModule {}
```
### 2.人物特性区的路由需求
  人物 特性有两个相互协作的组件，列表和详情。列表视图是自给自足的，我导航到它，它会自行获取人物列表并显示它们。
  详情视图就不同了，它要显示一个特定的人物，但是它本身无法知道是哪一个人，这个信息必须来自外部。
  当用户从列表中选择了一个人物时，，应用就导航到详情页去显示那个人物。通过把所选人物id编码进路由的URL中，就能告诉详情视图应该显示谁。
### 3.人物特性区路由配置
  在persons目录下创建一个新的persons-routing.module.ts文件，使用的技术和以前创建AppRoutingModule时一样：
```typescript
import { NgModule }             from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { PersonListComponent }    from './Person-list.component';
import { PersonDetailComponent }  from './Person-detail.component';

const PersonsRoutes: Routes = [
  { path: 'persons',  component: PersonListComponent },
  { path: 'person/:id', component: PersonDetailComponent }
];

@NgModule({
  imports: [
    RouterModule.forChild(personsRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class PersonRoutingModule { }
```
  从新位置src/app/persons/目录中导入人物相关的组件，定义两个 人物管理 路由，并导出PersonRoutingModule类。现在有了Persons模块的路由，还得在RouterModule中把它们注册给路由器，和AppRoutingModule中的做法几乎完全一样。这里有少量但是关键的不同点。在AppRoutingModule中，使用了静态的RouterModule.forRoot方法来注册路由和完全应用级服务提供商。在特性模块中，要改用forChild方法。
```txt
	只在根模块AppRoutingModule中调用RouterModule.forRoot(如果在AppModule中注册应用的顶级路由，那就在AppModule中调用)。在其它模块中，就必须调用RouterModule.forChild方法来注册附属路由
```
### 4.把路由模块添加到PersonsModule中
  把PersonRouterModule添加到PersonModule中，就像为AppModule添加 AppRoutingModule一样。
```typescript
import { NgModule }       from '@angular/core';
import { CommonModule }   from '@angular/common';
import { FormsModule }    from '@angular/forms';

import { PersonListComponent }    from './Person-list.component';
import { PersonDetailComponent }  from './Person-detail.component';

import { PersonService } from './Person.service';

import { PersonRoutingModule } from './Persons-routing.module';

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
    PersonRoutingModule
  ],
  declarations: [
    PersonListComponent,
    PersonDetailComponent
  ],
  providers: [ PersonService ]
})
export class PersonsModule {}
```
### 5.移除重复的 人物管理 路由
  人物 类的路由目前定义在两个地方：PersonsRoutingModule中（并最终给PersonsModule）和AppRoutingModule中。由特性模块提供的路由会被路由器再组合上它们所导入的模块的路由。这让我可以继续定义特性路由模块中的路由，而不是修改主路由配置。
  但是都不希望把同一个路由定义两次，那就移除PersonListComponent的导入和来自app-routing.module.ts中的/persons路由。
  保留默认路由和通配符路由。它们是应用程序顶层该自己处理的关注点：
```typescript
import { NgModule }              from '@angular/core';
import { RouterModule, Routes }  from '@angular/router';

import { CrisisListComponent }   from './crisis-list.component';
// import { PersonListComponent }  from './Person-list.component';  // <-- delete this line
import { PageNotFoundComponent } from './not-found.component';

const appRoutes: Routes = [
  { path: 'crisis-center', component: CrisisListComponent },
  // { path: 'persons',     component: PersonListComponent }, // <-- delete this line
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } // 仅供调试
    )
  ],
  exports: [
    RouterModule
  ]
})
export class AppRoutingModule {}
```
### 6.把 人物管理 模块导入到AppModule
  人物这个特性模块已经准备好了，但是应用仍然不知道PersonsModule的存在，打开app.module.ts按照下面的步骤进行修改。
  导入PersonsModule并且把它加到根模块AppModule的@NgModule元数据中的imports数组中。
  从AppModule的declarations中移除PersonListComponent，因为它现在已经改由PersonsModule提供了。这一步很重要，因为一个组件只能声明在一个属主模块中。这个例子中Persons模块就是Persons组件的属主模块，而AppModule要通过导入PersonsModule才能使用这些组件。
  最终AppModule不再了解那些特定于 人物 特性的知识，比如它的组件、路由细节等。我可以让人物特性独立演化，添加更多的组件或各种各样的路由。这就是为每个特性区创建独立模块后获得的核心优势
  现在AppModule变这样：
```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { PersonsModule } from './persons/persons.module';
import { CrisisListComponent } from './crisis-list.component';
import { PageNotFoundComponent } from './not-found.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    PersonsModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    CrisisListComponent,
    PageNotFoundComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```
### 7.导入模块的顺序很重要
  看看该模块的imports数组。注意，AppRoutingModule是最后一个，最重要的是，它位于PersonsModule之后。
```ttypescript
imports: [
  BrowserModule,
  FormsModule,
  PersonsModule,
  AppRoutingModule
],
```
  路由配置的顺序很重要，路由器会接受第一个匹配上导航所要求的路径的那个路由。当所有路由都在同一个AppRoutingModule时，要把默认路由和通配符路由放在最后，这样路由器才有机会匹配到/persons路由，否则他就会先遇到并匹配上该通配符路由，并导航到 not found。这些路由不再位于单一文件中，他们分布在两个不同的模块中：AppRoutingModule和PersonsRoutingModule。
  每个路由模块都会根据导入的顺序把自己的路由配置追加进去。如果先列出了AppRoutingModule，那么通配符路由就会被注册在 人物管理 路由之前。通配符路由将会拦截住每一个到 人物管理 路由的导航，因此事实上屏蔽了所有人物管理路由。
### 8.带参数的路由定义
  回到PersonsRoutingModule并再次检查这些路由定义，PersonDetailComponent的路由有点特殊有没有：
```typescript
{ path: 'person/:id', component: PersonDetailComponent }
```
  注意 :id，它为路由参数在路径中创建一个 空位，在这里，路由器把人物的id插入到那个空位中。如果要告诉路由器导航到详情组件，并让它显示 Sherlock，那么就希望地址栏是这样显示的：localhost:4200/person/01。
  如果用户把这个URL输入到地址栏，路由器就会识别这种模式，同样进入 Sherlock的详情视图
### 9.在列表视图中设置路由参数
  然后导航到 PersonDetailComponent 组件。在那里期望看到所选人物的详情，这需要两部分信息：导航目标和该人物的 id。因此，这个链接参数数组中有两个条目：目标路由的path（路径），和一个用来指定所选人物 id 的路由参数。
```typescript
['/person', person.id] // { 15 }
```
  路由器从该数组中组合出了目标URL：localhost:4200/person/01
### 10.Activated Route实战
  从路由器包中导入Router、ActivatedRoute和Params类：
```typescript
import { Router, ActivatedRoute, ParamMap } from '@angular/router';
```
  这里导入switchMap操作符是因为稍后将会处理路由参数的可观察对象Observable：
```typescript
import {switchMap} from 'rxjs/operators'
```
  通常直接写一个构造函数，让Angular把组件所需的服务注入进来，自动定义同名的私有变量，并把它们存进去：
```typescript
constructor(
  private route: ActivatedRoute,
  private router: Router,
  private service: PersonService
) {}
```
  然后在ngOnInit方法中，用ActivatedRoute服务来接收路由的参数，从参数中取得该英雄的id，并接收此英雄用于显示：
```typescript
ngOnInit() {
  this.Person$ = this.route.paramMap.pipe(
    switchMap((params: ParamMap) =>
      this.service.getPerson(params.get('id')))
  );
}
```
  paramMap 的处理过程有点稍复杂。当这个 map 的值变化时，你可以从变化之后的参数中 get() 到其 id 参数。然后，让 PersonService 去获取一个具有此 id 的人物，并返回这个 PersonService 请求的结果。想使用 RxJS 的 map 操作符，但 PersonService 返回的是一个 Observable<Person>。 所以要改用 switchMap 操作符来打平这个 Observable。
  switchMap 操作符还会取消以前未完成的在途请求。如果用户使用新的 id 再次导航到该路由，而 PersonService 仍在接受老 id 对应的人物，那么 switchMap 就会抛弃老的请求，并返回这个新 id 的人物信息。
  这个可观察对象的 Subscription（订阅）将会由 AsyncPipe 处理，并且组件的 person属性将会设置为刚刚接收到的这个人物。
  **ParamMap API**
  ParamMap API是参照URLSearchParams接口来设计的，它提供了一些方法来处理对路由参数和查询参数的参数访问：
成员 | 说明
has(name) | 如果这个参数名位于参数列表中，就返回true
get(name) | 如果这个 map 中有参数名对应的参数值（字符串），就返回它，否则返回 null。如果参数值实际上是一个数组，就返回它的第一个元素
getAll(name) | 如果这个 map 中有参数名对应的值，就返回一个字符串数组，否则返回空数组。当一个参数名可能对应多个值的时候，请使用 getAll。
keys | 返回这个map中的所有参数名组成的字符串数组
  **参数的可观察对象与组件复用**
  在这个例子中，接收了路由参数的Observable对象，这种写法暗示着这些路由参数在该组件的生存期内可能会变化。确实如此，默认情况下，如果它没有访问过其它组件就导航到了同一个组件实例，那么路由器倾向于复用组件实例。如果复用，这些参数可以变化。假设父组件的导航栏有“前进”和“后退”按钮，用来轮流显示英雄列表中中英雄的详情。 每次点击都会强制导航到带前一个或后一个 id 的 PersonDetailComponent 组件。
  你不希望路由器仅仅从 DOM 中移除当前的 PersonDetailComponent 实例，并且用下一个 id 重新创建它。 那可能导致界面抖动。 更好的方式是复用同一个组件实例，并更新这些参数。
  不幸的是，ngOnInit 对每个实例只调用一次。 你需要一种方式来检测在同一个实例中路由参数什么时候发生了变化。 而 params 属性这个可观察对象（Observable）干净漂亮的处理了这种情况。
  **Snapshot（快照）：当不需要 Observable 时的替代品**
  本应用不需要复用 PersonDetailComponent。 用户总是会先返回英雄列表，再选择另一位英雄。 所以，不存在从一个英雄详情导航到另一个而不用经过英雄列表的情况。 这意味着路由器每次都会创建一个全新的 PersonDetailComponent 实例。
  假如你很确定这个 PersonDetailComponent 组件的实例永远、永远不会被复用，那就可以使用快照来简化这段代码。
  route.snapshot 提供了路由参数的初始值。 你可以通过它来直接访问参数，而不用订阅或者添加 Observable 的操作符。 这样在读写时就会更简单：
```typescript
ngOnInit() {
  let id = this.route.snapshot.paramMap.get('id');
  this.person$ = this.service.getPerson(id);
}
```
### 11.导航回列表组件
  PersonDetailComponent 组件有一个“Back”按钮，关联到它的 gotoPersons 方法，该方法会导航回 PersonListComponent 组件。路由的 navigate 方法同样接受一个单条目的链接参数数组，你也可以把它绑定到 [routerLink] 指令上。 它保存着到 PersonListComponent 组件的路径：
```typescript
gotoPersons() {
  this.router.navigate(['/Persons']);
}
```
### 12.路由参数是否必选
  如果想导航到 PersonDetailComponent 以对 id 为 01 的英雄进行查看并编辑，就要在路由的 URL 中使用路由参数来指定必要参数值 localhost:4200/person/01
  当从 PersonDetailComponent 返回时，你很快就会通过把正在查看的英雄的 id 作为可选参数包含在 URL 中来实现这个特性。
  可选信息有很多种形式。搜索条件通常就不是严格结构化的，比如 name='wind\*'；有多个值也很常见，如 after='12/31/2015'&before='1/1/2017'； 而且顺序无关，如 before='1/1/2017'&after='12/31/2015'，还可能有很多种变体格式，如 during='currentYear'。
  这么多种参数要放在 URL 的路径中可不容易。即使你能制定出一个合适的 URL 方案，实现起来也太复杂了，得通过模式匹配才能把 URL 翻译成命名路由。
  可选参数是在导航期间传送任意复杂信息的理想载体。 可选参数不涉及到模式匹配并在表达上提供了巨大的灵活性。
  和必要参数一样，路由器也支持通过可选参数导航。 在你定义完必要参数之后，再通过一个独立的对象来定义可选参数。
  通常，对于强制性的值（比如用于区分两个路由路径的）使用必备参数；当这个值是可选的、复杂的或多值的时，使用可选参数。
### 13.人物列表：选定一个人物（也可以不选）
  当导航到 PersonDetailComponent 时，你可以在路由参数中指定一个所要编辑的英雄 id，只要把它作为链接参数数组中的第二个条目就可以了。
```typescript
['/person', person.id] // { 15 }
```
  路由器在导航 URL 中内嵌了 id 的值，这是因为你把它用一个 :id 占位符当做路由参数定义在了路由的 path 中：
```typescript
{ path: 'person/:id', component: PersonDetailComponent }
```
  当用户点击后退按钮时，PersonDetailComponent 构造了另一个链接参数数组，可以用它导航回 PersonListComponent。
```typescript
gotoPersons() {
  this.router.navigate(['/persons']);
}
```
  该数组缺少一个路由参数，这是因为你那时没有理由往 PersonListComponent 发送信息。
  但现在有了。你要在导航请求中同时发送当前英雄的 id，以便 PersonListComponent 可以在列表中高亮这个英雄。 这是一个有更好，没有也无所谓的特性，就算没有它，列表照样能显示得很完美。
  传送一个包含可选id 参数的对象。 为了演示，这里还在对象中定义了一个没用的额外参数（foo），PersonListComponent 应该忽略它。 下面是修改过的导航语
```typescript
gotoPersons(person: Person) {
  let personId = person ? person.id : null;
  // Pass along the Person id if available
  // so that the personList component can select that person.
  // Include a junk 'foo' property for fun.
  this.router.navigate(['/persons', { id: personId, foo: 'foo' }]);
}
```
  该应用仍然能工作，点击back按钮返回英雄列表视图。注意浏览器的地址栏，它应该是这样的，不过也取决于在哪里运行：localhost:4200/person:id=01;foo=foo
  d 的值像这样出现在 URL 中（;id=15;foo=foo），但不在 URL 的路径部分。 “persons”路由的路径部分并没有定义 :id。
  可选的路由参数没有使用“？”和“&”符号分隔，因为它们将用在 URL 查询字符串中。 它们是用“;”分隔的。 这是矩阵 URL标记法.
### 14.ActivatedRoute服务中的路由参数
  英雄列表仍然没有改变，没有那个人物被加亮显示。
  PersonListComponent 还完全不需要任何参数，也不知道该怎么处理它们。你可以改变这一点。
  以前，当从 PersonListComponent 导航到 PersonDetailComponent 时，你通过 ActivatedRoute 服务订阅了路由参数这个 Observable，并让它能用在 PersonDetailComponent 中。 你把该服务注入到了 PersonDetailComponent 的构造函数中。
  这次，你要进行反向导航，从 PersonDetailComponent 到 PersonListComponent。
  首先，你扩展该路由的导入语句，以包含进 ActivatedRoute 服务的类：
```typescript
import { ActivatedRoute, ParamMap } from '@angular/router';
```
  导入switchMap操作符，在路由参数的Observable对象上执行操作:
```typescript
import { Observable } from 'rxjs';
import { switchMap } from 'rxjs/operators';
```
  接着注入ActivatedRoute到PersonListComponent的构造函数中：
```typescript
export class PersonListComponent implements OnInit {
  persons$: Observable<person[]>;

  private selectedId: number;

  constructor(
    private service: PersonService,
    private route: ActivatedRoute
  ) {}

  ngOnInit() {
    this.persons$ = this.route.paramMap.pipe(
      switchMap((params: ParamMap) => {
        // (+) before `params.get()` turns the string into a number
        this.selectedId = +params.get('id');
        return this.service.getPersons();
      })
    );
  }
}
```
  ActivatedRoute.paramMap属性是一个路由参数的可观察对象，当用户导航到这个组件时，paramMap会发射一个新值，其中包含一个id，在ngOnInit中，订阅这些值，设置到selectedId，并获取人物数据。
  用css类绑定更新模板，把它绑定到isSelected方法上。如果该方法返回true，此绑定就会添加CSS类selected，否则就移除它，在<li>标记中找到它，就像这样：
```typescript
template: `
  <h2>Persons</h2>
  <ul class="items">
    <li *ngFor="let person of Persons$ | async"
      [class.selected]="person.id === selectedId">
      <a [routerLink]="['/person', person.id]">
        <span class="badge">{{ person.id }}</span>{{ person.name }}
      </a>
    </li>
  </ul>
  <button routerLink="/sidekicks">Go to sidekicks</button>
`
```
### 15.为路由组件添加动画
  这个人物的特性模块就要完成了，但这个特性还没有平滑的转场效果。所以需要添加一些动画。首先导入 BrowserAnimationsModule：
```typescript
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

@NgModule({
  imports: [
    BrowserAnimationsModule
```
  在根目录src/app/下创建一个animations.ts，内容如下：
```typescript
import { animate, state, style, transition, trigger } from '@angular/animations';

// Component transition animations
export const slideInDownAnimation =
  trigger('routeAnimation', [
    state('*',
      style({
        opacity: 1,
        transform: 'translateX(0)'
      })
    ),
    transition(':enter', [
      style({
        opacity: 0,
        transform: 'translateX(-100%)'
      }),
      animate('0.2s ease-in')
    ]),
    transition(':leave', [
      animate('0.5s ease-out', style({
        opacity: 0,
        transform: 'translateY(100%)'
      }))
    ])
  ]);
```
  这个文件做了以下工作
  - 导入动画符号以构建动画触发器、控制状态并管理状态之间的过渡
  - 导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名叫routerAnimation的动画触发器，带动画的组件将会引用这个名字
  - 指定了一个通配符状态  ，它匹配该路由组价存在时的任何动画状态
  - 定义两个过渡效果，其中一个（：enter）在组件进入应用视图时让它从屏幕左侧欢动进入，另一个（：leave）在组件离开应用视图时让它向下飞出。
    可以为其它路由组件用不同的转场效果创建更多的触发器，现在这个触发器先用着。
    返回PersonDetailComponent，从'./animatiions.ts'中导入slideInDownAnimation，从@angular/core中导入HostBinding装饰器，把一个包含slideInDownAnimation的animations数组添加到@Component的元数据中。
    然后把三个@HostBinding属性添加到类中以设置这个路由组件元素的动画和样式。
```typescript
@HostBinding('@routeAnimation') routeAnimation = true;
@HostBinding('style.display')   display = 'block';
@HostBinding('style.position')  position = 'absolute';
```
  传给了第一个 @HostBinding 的 '@routeAnimation' 匹配了 slideInDownAnimation触发器的名字 routeAnimation。 把 routeAnimation 属性设置为 true，因为你只关心 :enter 和 :leave 这两个状态。另外两个 @HostBinding 属性指定组件的外观和位置。当进入该路由时，PersonDetailComponent 将会从左侧缓动进入屏幕，而离开路由时，将会向下划出。
## 七、危机中心
  现在是时候往该应用的危机中心添加一些真实的特性了。
  先从模仿 人物管理 中的特性开始：
  - 删除危机中心的占位文件
  - 创建app/crisis-center文件夹
  - 把app/persons中的文件复制到新的危机中心文件夹
  - 在这些新文件中，把每一个对 person 替换为 crisis，并把persons替换为crises
    我会把CrisisService转换成模拟的危机列表，而不再是模拟的人物列表：
```typescript
import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';
export class Crisis {
  constructor(public id: number, public name: string) { }
}
const CRISES = [
  new Crisis(1, '天塌了'),
  new Crisis(2, '地陷了'),
  new Crisis(3, '小花猫不见了')
];
```
  最终的危机中心可以作为引入子路由这个新概念的基础。
### 1.带有子路由的危机中心
  这里会展示如何组织危机中心，来满足Angular应用所推荐的模式：
  - 把每个特性放在自己的目录中
  - 每个特性都有自己的Angular特性模块
  - 每个特性区都有自己的根组件
  - 每个特性区的根组件中都有自己的路由出口及其子路由
  - 特性区的路由很少与其它特性区的路由交叉
### 2.子路由组件
  往crisis-center目录下添加下列crisis-center.component.ts文件：
```typescript
import { Component } from '@angular/core';

@Component({
  template:  `
    <h2>CRISIS CENTER</h2>
    <router-outlet></router-outlet>
  `
})
export class CrisisCenterComponent { }
```
  CrisisCenterComponent 和 AppComponent 有下列共同点：
  - 它是危机中心特性区的根，正如AppComponent是整个应用的根
  - 它是危机管理特性区的壳，正如 AppComponent 是管理高层工作流的壳
    就像大多数的壳一样，CrisisCenterComponent类也非常简单，甚至比AppComponent更简单：它没有业务逻辑，它的模板中没有链接，只有一个标题和用于放置危机中心的子视图的<router-outlet>，与AppComponent和大多数其它组件不同的是，它甚至都没有指定选择器selector，它不需要选择器，因为我 不会把这个组件嵌入到某个父模板中，而是使用路由器导航到它。
### 3.子路由配置
  把下面这个crisis-center-home.component.ts添加到crisis-center目录下，作为 危机中心 特性区的宿主页面：
```typescript
import { Component } from '@angular/core';

@Component({
  template: `
    <p>Welcome to the Crisis Center</p>
  `
})
export class CrisisCenterHomeComponent { }
```
  像 persons-routing.module.ts 文件一样，也创建一个 crisis-center-routing.module.ts。 但这次，要把子路由定义在父路由 crisis-center 中
```typescript
const crisisCenterRoutes: Routes = [
  {
    path: 'crisis-center',
    component: CrisisCenterComponent,
    children: [
      {
        path: '',
        component: CrisisListComponent,
        children: [
          {
            path: ':id',
            component: CrisisDetailComponent
          },
          {
            path: '',
            component: CrisisCenterHomeComponent
          }
        ]
      }
    ]
  }
];
```
  注意，父路由crisis-center有一个children属性，它有一个包含CrisisListComponent的路由。CrisisListModule路由还有一个带两个 路由的children数组。
  这两个路由导航到了危机中心的两个子组件：CrisisCenterHomeComponent 和 CrisisDetailComponent。对这些路由的处理中有一些重要的不同。路由器会把这些路由对应的组件放在 CrisisCenterComponent 的 RouterOutlet 中，而不是 AppComponent 壳组件中的。CrisisListComponent 包含危机列表和一个 RouterOutlet，用以显示 Crisis Center Home 和 Crisis Detail 这两个路由组件。Crisis Detail 路由是 Crisis List 的子路由。由于路由器默认会复用组件，因此当你选择了另一个危机时，CrisisDetailComponent 会被复用。
  作为对比，回到PersonDetail 路由时，每当选择了不同的英雄时，该组件都会被重新创建。在顶级，以 / 开头的路径指向的总是应用的根。 但这里是子路由。 它们是在父路由路径的基础上做出的扩展。 在路由树中每深入一步，你就会在该路由的路径上添加一个斜线 /（除非该路由的路径是空的）。如果把该逻辑应用到危机中心中的导航，那么父路径就是 /crisis-center。要导航到 CrisisCenterHomeComponent，完整的 URL 是 /crisis-center (/crisis-center + '' + '')。要导航到 CrisisDetailComponent 以展示 id=2 的危机，完整的 URL 是 /crisis-center/2 (/crisis-center + '' + '/2')。
  这个例子中包含站点部分的绝对URL，就是：
```typescript
localhost:4200/crisis-center/2
```
  这里是完整的crisis-center.routing.ts及其导入语句：
```typescript
import { NgModule }             from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { CrisisCenterHomeComponent } from './crisis-center-home.component';
import { CrisisListComponent }       from './crisis-list.component';
import { CrisisCenterComponent }     from './crisis-center.component';
import { CrisisDetailComponent }     from './crisis-detail.component';

const crisisCenterRoutes: Routes = [
  {
    path: 'crisis-center',
    component: CrisisCenterComponent,
    children: [
      {
        path: '',
        component: CrisisListComponent,
        children: [
          {
            path: ':id',
            component: CrisisDetailComponent
          },
          {
            path: '',
            component: CrisisCenterHomeComponent
          }
        ]
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(crisisCenterRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class CrisisCenterRoutingModule { }
```
### 4.把危机中心模块导入到AppModule的路由中
  就像PersonsModule模块中一样，必须把CrisisCenterModule添加到AppModule的imports数组中 ，就在AppRoutingModule前面：
```typescript
import { NgModule }       from '@angular/core';
import { CommonModule }   from '@angular/common';
import { FormsModule }    from '@angular/forms';

import { AppComponent }            from './app.component';
import { PageNotFoundComponent }   from './not-found.component';

import { AppRoutingModule }        from './app-routing.module';
import { PersonsModule }            from './persons/persons.module';
import { CrisisCenterModule }      from './crisis-center/crisis-center.module';

import { DialogService }           from './dialog.service';

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
    PersonsModule,
    CrisisCenterModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    PageNotFoundComponent
  ],
  providers: [
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```
  从app.routing.ts中移除危机中心的初始路由，这些特性路由现在是由PersonsModule和CrisisCenter特性模块提供的。app-routing.module.ts文件中只有应用的顶级路由，比如默认路由和通配符路由：
```typescript
import { NgModule }                from '@angular/core';
import { RouterModule, Routes }    from '@angular/router';

import { ComposeMessageComponent } from './compose-message.component';
import { PageNotFoundComponent }   from './not-found.component';

const appRoutes: Routes = [
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } //仅供调试
    )
  ],
  exports: [
    RouterModule
  ]
})
export class AppRoutingModule {}
```
### 5.相对导航
  虽然构建除了危机中心特性区，但是仍然在使用以斜杠开头的绝对路径来导航到危机详情的路由。路由器会从路由配置的顶层来匹配像这样的绝对路径。
  虽然 可以继续像危机中心特性区一样使用绝对路径，但是那样会把链接钉死在在特定的父路由结构上。 如果修改了父路径 /crisis-center，那就不得不修改每一个链接参数数组。通过改成定义相对于当前 URL 的路径，你可以把链接从这种依赖中解放出来。 当你修改了该特性区的父路由路径时，该特性区内部的导航仍然完好无损。
  例子如下：
	路由器支持在链接参数数组中使用“目录式”语法来为查询路由名提供帮助：
	./ 或 无前导斜线 形式是相对于当前级别的。
	../ 会回到当前路由路径的上一级。
	可以把相对导航语法和一个祖先路径组合起来用。 如果不得不导航到一个兄弟路由，你可以用 ../<sibling> 来回到上一级，然后进入兄弟路由路径中。
  用Router.navigate方法导航到相对路径，必须提供当前的ActivatedRoute，来让路由器知道现在处于路由树中的什么位置。在链接参数数组中，添加一个带有relativeTo属性的对象，并把它设置为当前的ActivatedRoute，这样路由器就会基于当前激活路由的位置来计算出目标URL。
	当调用路由器的navigateByUrl时，总是要指定完整的绝对路径。
### 6.使用相对URL导航到危机列表
  现在已经注入过了ActivatedRoute。需要把它来和相对导航路径组合在一起。如果使用RouterLink来代替Router服务进行导航，就要使用相同的链接参数数组，不过不再需要提供relativeTo属性，ActivatedRoute已经隐含在了RouterLink指令中。
  修改 CrisisDetailComponent 的 gotoCrises 方法，来使用相对路径返回危机中心列表。
```typescript
//相对路径返回
this.router.navigate(['../', { id: crisisId, foo: 'foo' }], { relativeTo: this.route });
//这里使用了../语法返回上一级，如果当前危机的id是3，那么最终返回到的路径就是/crisis-center./:id=3;foo=foo
```
### 7.用命名出口显示多重路由
  现在想要给用户提供一种方式来联系危机中心，当用户点击Contact按钮时，要在一个弹出框中显示一条消息。即使在应用中的不同页面之间切换，这个弹出框也应该始终保持打开状态，直到用户发送了消息或者手动取消、显示并不能把这个弹出框跟其它放在同一个路由出口中。
  到目前位置，只定义了单路由出口，并且在其中潜逃了子路由以便对路由分组，在每个模板中，路由器只能支持一个无名主路由出口。模板哈可以有多个命名的路由出口，每个命名出口都有自己有一组带组件的路由，多重出口可以在同一时间根据不同的路由来显示不同的内容。
  在AppComponent中添加一个名叫 popup 的出口，就在无名出口的下方：
```html
<router-outlet></router-outlet>
<router-outlet name="popup"></router-outlet>
```
  学会了如何把一个弹出框组件路由到该出口，那里就是将会出现弹出框的地方。
#### 7.1 第二路由
  命名出口是第二路由的目标。第二路由很像主路由，配置方式也一样。它们只有一些关键的不同点：
  - 它们彼此互不依赖。
  - 它们与其它路由组合使用。
  - 它们显示在命名出口中。
    在 src/app/compose-message.component.ts 中创建一个名叫 ComposeMessageComponent 的新组件。 它显示一个简单的表单，包括一个头、一个消息输入框和两个按钮： “Send” 和 “Cancel”
    ![图片](contact-popup.png)
下面树该组件及其模板
**compose-message.component.ts**
```typescript
import { Component, HostBinding } from '@angular/core';
import { Router }                 from '@angular/router';

import { slideInDownAnimation }   from './animations';

@Component({
  templateUrl: './compose-message.component.html',
  styles: [ ':host { position: relative; bottom: 10%; }' ],
  animations: [ slideInDownAnimation ]
})
export class ComposeMessageComponent {
  @HostBinding('@routeAnimation') routeAnimation = true;
  @HostBinding('style.display')   display = 'block';
  @HostBinding('style.position')  position = 'absolute';

  details: string;
  sending = false;

  constructor(private router: Router) {}

  send() {
    this.sending = true;
    this.details = 'Sending Message...';

    setTimeout(() => {
      this.sending = false;
      this.closePopup();
    }, 1000);
  }

  cancel() {
    this.closePopup();
  }

  closePopup() {
    // 向命名出口提供 空 值清除指定出口的内容
    this.router.navigate([{ outlets: { popup: null }}]);
  }
}
```
**compose-message.component.html**
```typescript
<h3>Contact Crisis Center</h3>
<div *ngIf="details">
  {{ details }}
</div>
<div>
  <div>
    <label>Message: </label>
  </div>
  <div>
    <textarea [(ngModel)]="message" rows="10" cols="35" [disabled]="sending"></textarea>
  </div>
</div>
<p *ngIf="!sending">
  <button (click)="send()">Send</button>
  <button (click)="cancel()">Cancel</button>
</p>
```
  它看起来几乎和以前见到的其它组件一样，但有两个需要注意的区别：
  主要send()方法在发送消息和关闭弹出框之间通过等待模拟了一秒钟的延迟。closePopup()方法用把popup出口导航到null的方式关闭了弹出框。
  像其它组件一样，还要把ComposeMessageComponent添加到AppModule的declarations中。
#### 7.2 添加第二路由
  打开AppRoutingModule，并把一个新的compose路由添加到appRoutes中。
```typescript
{
  path: 'compose',
  component: ComposeMessageComponent,
  outlet: 'popup'
}
```
  对path和compose这个属性是熟悉的了，注意这个新的属性outlet被设置成为了 popup，这个路由现在指向了popup出口，而ComposeMessageComponent 也将显示在那里。用户需要某种途径来打开这个弹出框。打开AppComponent，并添加一个 Contact 链接
```html
<a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
```
  虽然compose 路由被钉死在了popup出口上，但这仍然不足以向RouterLink指令表明要加载该路由。还要在链接参数数组中指定这个命名出口，并通过属性绑定的形式把它绑定到RouterLink上。
  链接参数数组包含一个只有一个 outlets 属性的对象，它的值是另一个对象，这个对象以一个或多个路由的出口名作为属性名。 在这里，它只有一个出口名“popup”，它的值则是另一个链接参数数组，用于指定 compose 路由。意思是，当用户点击此链接时，在路由出口 popup 中显示与 compose 路由相关联的组件。
	当有且只有一个无名出口时，外部对象中的这个 outlets 对象并不是必须的。
	路由器假设这个路由指向了无名的主出口，并为你创建这些对象。
	路由到一个命名出口就会揭示一个以前被隐藏的真相： 你可以在同一个 RouterLink 指令中为多个路由出口指定多个路由。
	这里实际上没能这样做。要想指向命名出口，就得使用一种更强大也更啰嗦的语法。
#### 7.4 第二路由导航：在导航期间合并路由
  导航到危机中心 并点击 Contact，会在浏览器的地址栏看到这样的URL：
```typescript
http://.../crisis-center(popup:compose)
```
  这个URL中有意思的部分是 ... 后面的这些：
  - crisis-center是主导航
  - 圆括号包裹的部分是第二路由
  - 第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）
    点击Persons链接，再次查看URL：
```typescript
http://.../persons(popup:compose)
```
  主导航的变化了，而第二路由没有变。路由器在导航树中对两个独立的分支保持追踪，并在URL中对这棵树进行表达。
  还可以添加更多出口和更多路由（无论是在顶层还是在嵌套的子层）来创建一个带有多个分支的导航树。路由器将会生成相应的URL。通过像前面那样填充outlets对象，我可以告诉路由器立即导航到一棵完整的树，然后把这个对象通过一个链接参数数组传给router.navigate方法。
#### 7.5 清除第二路由
  正如刚刚说的，除非导航到新的组件，否则路由出口中的组件会始终存在。这里涉及到的第二出口也同样如此。每个第二出口都有自己独立的导航，跟主出口的导航彼此独立。修改主出口中的当前路由并不会影响到popup出口，这就是为什么在危机中心和英雄管理之间导航时，弹出框始终都是可见的。
  点击send或cancel按钮，则会清除弹出框视图，来看一下closePopup()方法：
```typescript
closePopup() {
  this.router.navigate([{ outlets: { popup: null }}]);
}
```
  它使用Router.navigate()方法进行强制导航，并传入了一个链接参数数组。就像在AppComponent中绑定到的ConcatRouterLink一样，它也包含了一个带有outlets属性的对象，outlets属性的值是另一个对象，该对象用一些出口名称作为属性名，唯一的命名出口是 popup，但这次，popup的值是null，null不是一个路由，但却是一个合法的值，把popup这个RouterOutlet设置为null会清除该出口，并且从当前URL中移除第二路由popup。
## 八、路由守卫
  现在，任何用户都能在任何时候导航到任何地方。但有时候这样是不对的。
  - 该用户可能无权导航到目标组件
  - 可能用户得先登录或者认证一下
  - 在显示目标组件前，可能得先获取某些数据。
  - 在离开组件前，可能要先保存修改
  - 可能还要询问用户：是否要放弃本次更改，而不用保存它们？
    这些可以往路由配置中添加守卫，来处理这些场景。
    守卫返回一个值，以控制路由器的行为：
  - 如果它返回true，导航 过程会继续
  - 如果它返回false，导航过程会终止，且用户会留在原地
	守卫还可以告诉路由器导航到别处，这样也取消当前的导航
    守卫可以用同步的方式返回一个布尔值，但在很多情况下，守卫无法用同步的方式给出答案，守卫可能会向用户问一个问题，把更改保存到服务器，或者获取新数据，而这些都是异步操作。因此路由的守卫可以返回一个Observable<boolean>或Promise<boolean>，并且路由器会等待这个可观察对象被解析为true或false。
    路由器可以支持多种守卫接口：
  - 用CanActivate来处理导航到某路由的情况
  - 用CanActivateChild来处理导航到某子路由的情况
  - 用CanDeaactivate来处理从当前路由离开的情况
  - 用Resolve在路由激活之前获取路由数据
  - 用CanLoad来处理异步导航到某特性模块的情况
    在分层路由的每个级别上，都可以设置多个守卫。路由器会按照从最深的子路由从下往上检查的顺序来检查CanDeaactivate()和CanActivateChild()守卫，然后它会按照从上到下的顺序检查CanActivate()守卫。如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫 。如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。
### 1.CanActivate：要求认证
  应用程序通常会根据访问者来决定是否授予某个特性区的访问权，我可以只对已认证过的用户或具有特定角色的用户授予访问权，还可以阻止或限制用户访问权，直到用户账户激活为止。CanActivate守卫是一个管理这些导航类业务规则的工具。
#### 1.1 添加一个 管理 特性模块
  等会儿会使用一些新的管理特性来扩展危机中心。那些特性尚未定义，但是我可以先从添加一个名叫AdminModule的特性模块开始。创建一个admin目录，它带有一个特性模块文件、一个路由配置文件和一些支持性组件。
  管理特性模块包含AdminComponent，它用于在特性模块内的仪表盘路由以及两个尚未完成的用于管理危机个人物的组件之间进行路由
**admin-dashboard.component.ts**
```typescript
import { Component } from '@angular/core';
@Component({
  template:  `
    <p>Dashboard</p>
  `
})
export class AdminDashboardComponent { }
```
**admin.component.ts**
```typescript
import { Component } from '@angular/core';

@Component({
  template:  `
    <h3>ADMIN</h3>
    <nav>
      <a routerLink="./" routerLinkActive="active"
        [routerLinkActiveOptions]="{ exact: true }">Dashboard</a>
      <a routerLink="./crises" routerLinkActive="active">Manage Crises</a>
      <a routerLink="./persons" routerLinkActive="active">Manage Persons</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class AdminComponent {
}
```
**admin.module.ts**
```typescript
import { NgModule }       from '@angular/core';
import { CommonModule }   from '@angular/common';

import { AdminComponent }           from './admin.component';
import { AdminDashboardComponent }  from './admin-dashboard.component';
import { ManageCrisesComponent }    from './manage-crises.component';
import { ManagePersonsComponent }    from './manage-persons.component';

import { AdminRoutingModule }       from './admin-routing.module';

@NgModule({
  imports: [
    CommonModule,
    AdminRoutingModule
  ],
  declarations: [
    AdminComponent,
    AdminDashboardComponent,
    ManageCrisesComponent,
    ManagePersonsComponent
  ]
})
export class AdminModule {}
```
**manage-crisis.component.ts**
```typescript
import { Component } from '@angular/core';

@Component({
  template:  `
    <p>Manage your crises here</p>
  `
})
export class ManageCrisesComponent { }
```
**manage-persons.component.ts**
```typescript
import { Component } from '@angular/core';

@Component({
  template:  `
    <p>Manage your persons here</p>
  `
})
export class ManagePersonsComponent { }
```
  由于 AdminModule 中 AdminComponent 中的 RouterLink 是一个空路径的路由，所以它会匹配到管理特性区的任何路由。 但只有在访问 Dashboard 路由时才希望该链接被激活。 往 Dashboard 这个 routerLink 上添加另一个绑定 [routerLinkActiveOptions]="{ exact: true }"， 这样就只有当用户导航到 /admin 这个 URL 时才会激活它，而不会在导航到它的某个子路由时。
  最初的管理路由配置如下：
```typescript
const adminRoutes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    children: [
      {
        path: '',
        children: [
          { path: 'crises', component: ManageCrisesComponent },
          { path: 'persons', component: ManagePersonsComponent },
          { path: '', component: AdminDashboardComponent }
        ]
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(adminRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class AdminRoutingModule {}
```
### 2.无组件路由：不借助组件对路由进行分组
  来看AdminComponent下的子路由，这里有一个带path和children的子路由，但它没有使用component。这并不是配置中的失误，而是在使用无组件路由。这里的目标是对admin路径下的 危机中心 管理类路由进行分组，但并不需要另一个仅用来分组路由的组件。一个无组件的路由能让守卫子路由变得更容易。
  接下来把AdminModule导入到app.module.ts中，并把它加入imports数组中来注册这些管理类路由。
```typescript
import { NgModule }       from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { PageNotFoundComponent } from './not-found.component';
import { AppRoutingModule } from './app-routing.module';
import { PersonsModule } from './persons/persons.module';
import { CrisisCenterModule } from './crisis-center/crisis-center.module';
import { AdminModule } from './admin/admin.module';
import { DialogService } from './dialog.service';

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
    PersonsModule,
    CrisisCenterModule,
    AdminModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    PageNotFoundComponent
  ],
  providers: [
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```
  然后往壳组件AppComponent中添加一个链接，让用户能点击它，以访问该特性：
```typescript
template: `
  <h1 class="title">Angular Router</h1>
  <nav>
    <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
    <a routerLink="/persons" routerLinkActive="active">Persons</a>
    <a routerLink="/admin" routerLinkActive="active">Admin</a>
    <a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
  </nav>
  <router-outlet></router-outlet>
  <router-outlet name="popup"></router-outlet>
  `
```
#### 2.1 守护 管理特性 区
  现在 危机中心 的每个路由都是对所有人开放的，这些新的管理特性应该只能被已登录用户访问。我可以在用户登录之前隐藏这些链接，但这样会有点复杂并难以维护。但是我可以换一种方式：写一个CanActivate()守卫，将正在尝试访问管理组件匿名用户重定向到登录页。这是一种具有通用性的守护目标（通常会有其它特性需要登录用户才能访问），所以我要在应用的根目录下创建一个auth-guard.ts文件。此时，守卫的第一个版本只是被用来看 是如何工作的，并么有做什么有用的事情，它只是往控制台写日志，并且立即返回true，让导航继续而已
```typescript
import { Injectable }     from '@angular/core';
import { CanActivate }    from '@angular/router';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate() {
    console.log('AuthGuard#canActivate called');
    return true;
  }
}
```
  接下来，打开crisis-center.route.ts，导入AuthGuard类，修改管理路由并通过CanActivate ()守卫应用AuthGuard：
```typescript
import { AuthGuard }                from '../auth-guard.service';

const adminRoutes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [AuthGuard],
    children: [
      {
        path: '',
        children: [
          { path: 'crises', component: ManageCrisesComponent },
          { path: 'persons', component: ManagePersonsComponent },
          { path: '', component: AdminDashboardComponent }
        ],
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(adminRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class AdminRoutingModule {}
```
  管理特性区现在受此守卫保护了，不过这样的保护还不够。
#### 2.2 教AuthGuard进行认证
  先让AuthGuard至少能 假装进行认证。AuthGuard可以调用应用中的一项服务，该服务能让用户登录，并且保存当前用户的信息。下面是一个AuthService示范：
```typescript
import { Injectable } from '@angular/core';

import { Observable, of } from 'rxjs';
import { tap, delay } from 'rxjs/operators';

@Injectable()
export class AuthService {
  isLoggedIn = false;
  // 存储URL，这样可以在登录以后进行重定向
  redirectUrl: string;

  login(): Observable<boolean> {
    return of(true).pipe(
      delay(1000),
      tap(val => this.isLoggedIn = true)
    );
  }

  logout(): void {
    this.isLoggedIn = false;
  }
}
```
  虽然它不会真的进行登录，但足够让你进行这个讨论了。 它有一个 isLoggedIn 标志，用来标识是否用户已经登录过了。 它的 login 方法会仿真一个对外部服务的 API 调用，返回一个可观察对象（observable）。在短暂的停顿之后，这个可观察对象就会解析成功。 redirectUrl 属性将会保存在 URL 中，以便认证完之后导航到它。
  现在就修改 AuthGuard 来调用它。
```typescript
import { Injectable }       from '@angular/core';
import {
  CanActivate, Router,
  ActivatedRouteSnapshot,
  RouterStateSnapshot
}                           from '@angular/router';
import { AuthService }      from './auth.service';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    let url: string = state.url;

    return this.checkLogin(url);
  }

  checkLogin(url: string): boolean {
    if (this.authService.isLoggedIn) { return true; }

    //存储试图重定向的URL
    this.authService.redirectUrl = url;

    // 用额外的导航导航到登录页面
    this.router.navigate(['/login']);
    return false;
  }
}
```
  注意，把 AuthService 和 Router 服务注入到构造函数中。 还没有提供 AuthService，这里要说明的是：可以往路由守卫中注入有用的服务。
  该守卫返回一个同步的布尔值。如果用户已经登录，它就返回 true，导航会继续。这个 ActivatedRouteSnapshot 包含了即将被激活的路由，而 RouterStateSnapshot 包含了该应用即将到达的状态。 你应该通过守卫进行检查。如果用户还没有登录，就会用 RouterStateSnapshot.url 保存用户来自的 URL 并让路由器导航到登录页（你尚未创建该页）。 这间接导致路由器自动中止了这次导航，checkLogin() 返回 false 并不是必须的，但这样可以更清楚的表达意图。
#### 2.3 添加LoginComponent
  现在需要一个LoginComponent来让用户登录进这个应用。在登录之后，就会跳转到前面保存的 URL，如果没有，就跳转到默认 URL。 该组件没有什么新内容，你把它放进路由配置的方式也没什么新意。
  在 login-routing.module.ts 中注册一个 /login 路由，并把必要的提供商添加 providers 数组中。 在 app.module.ts 中，导入 LoginComponent 并把它加入根模块的 declarations 中。 同时在 AppModule 中导入并添加 LoginRoutingModule。
  **app.module.ts**
```typescript
import { NgModule }       from '@angular/core';
import { BrowserModule }  from '@angular/platform-browser';
import { FormsModule }    from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

import { Router } from '@angular/router';

import { AppComponent }            from './app.component';
import { AppRoutingModule }        from './app-routing.module';

import { PersonsModule }            from './persons/persons.module';
import { ComposeMessageComponent } from './compose-message.component';
import { LoginRoutingModule }      from './login-routing.module';
import { LoginComponent }          from './login.component';
import { PageNotFoundComponent }   from './not-found.component';

import { DialogService }           from './dialog.service';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    PersonsModule,
    LoginRoutingModule,
    AppRoutingModule,
    BrowserAnimationsModule
  ],
  declarations: [
    AppComponent,
    ComposeMessageComponent,
    LoginComponent,
    PageNotFoundComponent
  ],
  providers: [
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
  // 仅诊断：检查路由器配置
  constructor(router: Router) {
    console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
  }
}
```
**login.component.ts**
```typescript
import { Component }   from '@angular/core';
import { Router }      from '@angular/router';
import { AuthService } from './auth.service';

@Component({
  template: `
    <h2>LOGIN</h2>
    <p>{{message}}</p>
    <p>
      <button (click)="login()"  *ngIf="!authService.isLoggedIn">Login</button>
      <button (click)="logout()" *ngIf="authService.isLoggedIn">Logout</button>
    </p>`
})
export class LoginComponent {
  message: string;

  constructor(public authService: AuthService, public router: Router) {
    this.setMessage();
  }

  setMessage() {
    this.message = 'Logged ' + (this.authService.isLoggedIn ? 'in' : 'out');
  }

  login() {
    this.message = 'Trying to log in ...';

    this.authService.login().subscribe(() => {
      this.setMessage();
      if (this.authService.isLoggedIn) {
        // 从我们的AUTH服务获得重定向URL，如果没有设置重定向，就使用默认值
        let redirect = this.authService.redirectUrl ? this.authService.redirectUrl : '/crisis-center/admin';

        //重定向用户
        this.router.navigate([redirect]);
      }
    });
  }

  logout() {
    this.authService.logout();
    this.setMessage();
  }
}
```
**login-routing.module.ts**
```typescript
import { NgModule }             from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AuthGuard }            from './auth-guard.service';
import { AuthService }          from './auth.service';
import { LoginComponent }       from './login.component';

const loginRoutes: Routes = [
  { path: 'login', component: LoginComponent }
];

@NgModule({
  imports: [
    RouterModule.forChild(loginRoutes)
  ],
  exports: [
    RouterModule
  ],
  providers: [
    AuthGuard,
    AuthService
  ]
})
export class LoginRoutingModule {}
```
### 3.CanActivateChild：保护子路由
  还可以使用CanActivateChild守卫来保护子路由，CanActivateChild守卫和CanActivate守卫很像，它们的区别在于，CanActivateChild 会在任何子路由被激活之前运行。要保护管理特性模块，防止它被非授权访问，还要保护这个特性模块内部的那些子路由。
  扩展 AuthGuard 以便在 admin 路由之间导航时提供保护。 打开 auth-guard.service.ts 并从路由库中导入 CanActivateChild 接口。接下来，实现 CanActivateChild 方法，它所接收的参数与 CanActivate 方法一样：一个 ActivatedRouteSnapshot 和一个 RouterStateSnapshot。 CanActivateChild 方法可以返回 Observable<boolean> 或 Promise<boolean> 来支持异步检查，或 boolean 来支持同步检查。 这里返回的是 boolean：
```typescript
import { Injectable }       from '@angular/core';
import {
  CanActivate, Router,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  CanActivateChild
}                           from '@angular/router';
import { AuthService }      from './auth.service';

@Injectable()
export class AuthGuard implements CanActivate, CanActivateChild {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    let url: string = state.url;

    return this.checkLogin(url);
  }

  canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    return this.canActivate(route, state);
  }

/* . . . */
}
```
  同样把这个AuthGuard添加到无组件的管理路由，来同时保护它的所有子路由，而不是为每个路由单独添加这个AuthGuard：
```typescript
const adminRoutes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [AuthGuard],
    children: [
      {
        path: '',
        canActivateChild: [AuthGuard],
        children: [
          { path: 'crises', component: ManageCrisesComponent },
          { path: 'persons', component: ManagePersonsComponent },
          { path: '', component: AdminDashboardComponent }
        ]
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(adminRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class AdminRoutingModule {}
```
### 4.CanDeactivate：处理未保存的更改
  回到 Persons 工作流，该应用立刻接受对人物的任何修改，不做任何校验。在现实世界中，得先把用户的改动积累起来。 可能不得不进行跨字段的校验，可能要找服务器进行校验，可能得把这些改动保存成一种待定状态，直到用户或者把这些改动作为一组进行确认或撤销所有改动。
  当用户要导航到外面时，该怎么处理这些既没有审核通过又没有保存过的改动呢？ 不能马上离开，不在乎丢失这些改动的风险，这样的用户体验特别差。最好能暂停，并让用户决定该怎么做。 如果用户选择了取消，就留下来，并允许更多改动。 如果用户选择了确认，那就进行保存。
  在保存成功之前，还可以继续推迟导航。如果让用户立即移到下一个界面，而保存却失败了（可能因为数据不符合有效性规则），就会丢失该错误的上下文环境。
  在等待服务器的答复时，没法阻塞它 —— 这在浏览器中是不可能的。 只能用异步的方式在等待服务器答复之前先停止导航。这就需要 CanDeactivate 守卫。
### 5.取消与保存
  这个例子不与服务器通讯，但是有另一种方式来演示异步的路由器钩子。用户在CrisisDetailComponent中更新危机信息。与PersonDetailComponent不同，用户的改动不会 立即更新危机的实体对象，当用户按下save按钮的时候，应用就更新这个实体对象；如果选择了cancel，那就放弃更改。
  这两个按钮都会在保存或取消之后导航回危机列表
```typescript
cancel() {
  this.gotoCrises();
}
save() {
  this.crisis.name = this.editName;
  this.gotoCrises();
}
```
  如果用户尝试不保存或撤销就导航到外面该怎么办？ 用户可以按浏览器的后退按钮，或点击英雄的链接。 这些操作都会触发导航。本应用应该自动保存或取消吗？都不行。应用应该弹出一个确认对话框来要求用户明确做出选择，该对话框会用异步的方式等用户做出选择。
	也能用同步的方式等用户的答复，阻塞代码。但如果能用异步的方式等待用户的答复，应用就会响应性更好，也能同时做别的事。异步等待用户的答复和等待服务器的答复是类似的。
  DialogService（为了在应用级使用，已经注入到了 AppModule）就可以做到这些。它返回promise，当用户最终决定了如何去做时，它就会被解析 —— 或者决定放弃更改直接导航离开（true），或者保留未完成的修改，留在危机编辑器中（false）。
  创建了一个 Guard，它将检查这个（任意）组件中是否有 canDeactivate() 函数。 CrisisDetailComponent 就会有这个方法。 但是该守卫并不需要知道 CrisisDetailComponent 确认退出激活状态的详情。 它只需要检查该组件是否有一个 canDeactivate() 方法，并调用它。 这就让该守卫可以复用。
```typescript
import { Injectable }    from '@angular/core';
import { CanDeactivate } from '@angular/router';
import { Observable }    from 'rxjs';

export interface CanComponentDeactivate {
 canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
}

@Injectable()
export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {
  canDeactivate(component: CanComponentDeactivate) {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
```
  另外，也可以为 CrisisDetailComponent 创建一个特定的 CanDeactivate 守卫。 在需要访问外部信息时，canDeactivate() 方法为你提供了组件、ActivatedRoute 和 RouterStateSnapshot 的当前实例。 如果只想为这个组件使用该守卫，并且需要获取该组件属性或确认路由器是否允许从该组件导航出去时，这会非常有用。
```typescript
import { Injectable }           from '@angular/core';
import { Observable }           from 'rxjs';
import { CanDeactivate,
         ActivatedRouteSnapshot,
         RouterStateSnapshot }  from '@angular/router';

import { CrisisDetailComponent } from './crisis-center/crisis-detail.component';

@Injectable()
export class CanDeactivateGuard implements CanDeactivate<CrisisDetailComponent> {

  canDeactivate(
    component: CrisisDetailComponent,
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean> | boolean {
    //拿到Crisis center 的id
    console.log(route.paramMap.get('id'));

    // 拿到当前路由
    console.log(state.url);

    // 如果没有crisis或crisis不变，允许同步导航（“真”）
    if (!component.crisis || component.crisis.name === component.editName) {
      return true;
    }
    // 否则，使用对话框服务向用户询问并返回其可观察到的结果，当用户决定时，其解析为真或假。
    return component.dialogService.confirm('Discard changes?');
  }
}
```
  看看CrisisDetailComponent组件，它已经实现了对未保存的更改进行确认的工作流：
```typescript
canDeactivate(): Observable<boolean> | boolean {
  if (!this.crisis || this.crisis.name === this.editName) {
    return true;
  }
  return this.dialogService.confirm('Discard changes?');
}
```
  注意，canDeactivate 方法可以同步返回，如果没有危机，或者没有未定的修改，它就立即返回 true。但是它也可以返回一个承诺（Promise）或可观察对象（Observable），路由器将等待它们被解析为真值（继续导航）或假值（留下）。往 crisis-center.routing.module.ts 的危机详情路由中用 canDeactivate 数组添加一个 Guard（守卫）。
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { CrisisCenterHomeComponent } from './crisis-center-home.component';
import { CrisisListComponent } from './crisis-list.component';
import { CrisisCenterComponent } from './crisis-center.component';
import { CrisisDetailComponent } from './crisis-detail.component';
import { CanDeactivateGuard } from '../can-deactivate-guard.service';

const crisisCenterRoutes: Routes = [
  {
    path: '',
    redirectTo: '/crisis-center',
    pathMatch: 'full'
  },
  {
    path: 'crisis-center',
    component: CrisisCenterComponent,
    children: [
      {
        path: '',
        component: CrisisListComponent,
        children: [
          {
            path: ':id',
            component: CrisisDetailComponent,
            canDeactivate: [CanDeactivateGuard]
          },
          {
            path: '',
            component: CrisisCenterHomeComponent
          }
        ]
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(crisisCenterRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class CrisisCenterRoutingModule { }
```
  还要把这个 Guard 添加到 AppRoutingModule 的 providers 中去，以便 Router 可以在导航过程中注入它
```typescript
import { NgModule }              from '@angular/core';
import { RouterModule, Routes }  from '@angular/router';
import { ComposeMessageComponent } from './compose-message.component';
import { CanDeactivateGuard }      from './can-deactivate-guard.service';
import { PageNotFoundComponent }   from './not-found.component';

const appRoutes: Routes = [
  {
    path: 'compose',
    component: ComposeMessageComponent,
    outlet: 'popup'
  },
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } //仅供调试
    )
  ],
  exports: [
    RouterModule
  ],
  providers: [
    CanDeactivateGuard
  ]
})
export class AppRoutingModule {}
```
### 6.Resolve：预先获取组价数据
  在 Person Detail 和 Crisis Detail 中，它们等待路由读取完对应的英雄和危机。
  这种方式没有问题，但是它们还有进步的空间。 如果你在使用真实 api，很有可能数据返回有延迟，导致无法即时显示。 在这种情况下，直到数据到达前，显示一个空的组件不是最好的用户体验。
  最好预先从服务器上获取完数据，这样在路由激活的那一刻数据就准备好了。 还要在路由到此组件之前处理好错误。 但当某个 id 无法对应到一个危机详情时，就没办法处理它。 这时最好把用户带回到“危机列表”中，那里显示了所有有效的“危机”。总之，我希望的是只有当所有必要数据都已经拿到之后，才渲染这个路由组件。
  这就需要Resolve守卫了。
### 7.导航前预先加载路由信息
  目前，CrisisDetailComponent 会接收选中的危机。 如果该危机没有找到，它就会导航回危机列表视图。
  如果能在该路由将要激活时提前处理了这个问题，那么用户体验会更好。 CrisisDetailResolver 服务可以接收一个 Crisis，而如果这个 Crisis 不存在，就会在激活该路由并创建 CrisisDetailComponent 之前先行离开。
  在“危机中心”特性区中创建 crisis-detail-resolver.service.ts 文件。
```typescript
import { Injectable } from '@angular/core';
import { Router, Resolve, RouterStateSnapshot,
         ActivatedRouteSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { map, take } from 'rxjs/operators';

import { Crisis, CrisisService }  from './crisis.service';

@Injectable()
export class CrisisDetailResolver implements Resolve<Crisis> {
  constructor(private cs: CrisisService, private router: Router) {}

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<Crisis> {
    let id = route.paramMap.get('id');

    return this.cs.getCrisis(id).pipe(
      take(1),
      map(crisis => {
        if (crisis) {
          return crisis;
        } else { //id 没有找到
          this.router.navigate(['/crisis-center']);
          return null;
        }
      })
    );
  }
}
```
  在CrisisDetailComponent.nngOnInit中拿到相关的危机检索逻辑，并且把它们移到CrisisDetailResolver中，导入Crisis模型、CrisisService和Router以便让我可以在找不到指定的危机导航到别处。为了更明确一点，可以实现一个带有一个Crisis类型的Resolve接口。注入 CrisisService 和 Router，并实现 resolve() 方法。 该方法可以返回一个 Promise、一个 Observable 来支持异步方式，或者直接返回一个值来支持同步方式。
  CrisisService.getCrisis 方法返回了一个可观察对象，这是为了防止在数据获取完毕前加载路由。 如果它没有返回一个有效的 Crisis，就把用户导航回 CrisisListComponent，并取消以前到 CrisisDetailComponent 尚未完成的导航。
  把这个解析器（resolver）导入到 crisis-center-routing.module.ts 中，并往 CrisisDetailComponent 的路由配置中添加一个 resolve 对象。
  别忘了把 CrisisDetailResolver 服务添加到 CrisisCenterRoutingModule 的 providers 数组中。
```typescript
import { CrisisDetailResolver }   from './crisis-detail-resolver.service';

@NgModule({
  imports: [
    RouterModule.forChild(crisisCenterRoutes)
  ],
  exports: [
    RouterModule
  ],
  providers: [
    CrisisDetailResolver
  ]
})
export class CrisisCenterRoutingModule { }
```
  CrisisDetailComponent不应该再去获取这个危机的详情。把CrisisDetailComponent改成从ActivatedRoute.data.crisis 属性中获取危机详情，这正是重新配置路由的恰当时机。 当 CrisisDetailComponent 要求取得危机详情时，它就已经在那里了。
```typescript
ngOnInit() {
  this.route.data
    .subscribe((data: { crisis: Crisis }) => {
      this.editName = data.crisis.name;
      this.crisis = data.crisis;
    });
}
```
  两个关键点
  1.路由器的这个Resolve接口是可选的。CrisisDetailResolver并没有继承自某个基类。路由器只要找到了这个方法，就会调用它
  2.要依赖路由器调用此守卫。不必关心用户用哪种方式导航离开，这是路由器的工作。你只要写出这个类，等路由器从那里取出它就可以了。
  3.由路由器提供的 Observable 必须 完成（complete），否则导航不会继续。
### 8.查询参数及片段
  在这个查询参数例子中，只为路由指定了参数，但是该如何定义一些所有路由中都可用的可选参数，就应该查询参数了。
  片段可以引用页面中带有特定 id 属性的元素.
  修改 AuthGuard 以提供 session_id 查询参数，在导航到其它路由后，它还会存在。再添加一个锚点（A）元素，来能跳转到页面中的正确位置。
  为 router.navigate 方法添加一个 NavigationExtras 对象，用来导航到 /login 路由。
```typescript
import { Injectable } from '@angular/core';
import {
  CanActivate, Router,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  CanActivateChild,
  NavigationExtras
} from '@angular/router';
import { AuthService } from './auth.service';

@Injectable()
export class AuthGuard implements CanActivate, CanActivateChild {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    let url: string = state.url;

    return this.checkLogin(url);
  }

  canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    return this.canActivate(route, state);
  }

  checkLogin(url: string): boolean {
    if (this.authService.isLoggedIn) { return true; }

    // 存储视图重定向的URL
    this.authService.redirectUrl = url;

    // 创建虚拟会话id
    let sessionId = 123456789;

    // 设置包含全局查询参数和片段的导航额外对象
    let navigationExtras: NavigationExtras = {
      queryParams: { 'session_id': sessionId },
      fragment: 'anchor'
    };

    // 用额外的导航导航到登录页面
    this.router.navigate(['/login'], navigationExtras);
    return false;
  }
}
```
  还可以在导航之间保留查询参数 和片段 ，而无需再次再导航中提供。在 LoginComponent 中的 router.navigate 方法中，添加第二个参数，该对象提供了 preserveQueryParams 和 preserveFragment，用于传递到当前的查询参数中并为下一个路由提供片段。
```typescript
// 设置导航超文本对象，该对象通过全局查询参数和片段
let navigationExtras: NavigationExtras = {
  queryParamsHandling: 'preserve',
  preserveFragment: true
};

// 重定向到用户
this.router.navigate([redirect], navigationExtras);
```
	queryParamsHandling 特性还提供了 merge 选项，它将会在导航时保留当前的查询参数，并与其它查询参数合并。
  由于要在登陆后导航到危机管理特征区的路由，所以还得修改它，来处理这些全局查询参数和片段：
```typescript
import { Component, OnInit }  from '@angular/core';
import { ActivatedRoute }     from '@angular/router';
import { Observable }         from 'rxjs';
import { map }                from 'rxjs/operators';

@Component({
  template:  `
    <p>Dashboard</p>

    <p>Session ID: {{ sessionId | async }}</p>
    <a id="anchor"></a>
    <p>Token: {{ token | async }}</p>
  `
})
export class AdminDashboardComponent implements OnInit {
  sessionId: Observable<string>;
  token: Observable<string>;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    // 如果可用，捕获会话ID
    this.sessionId = this.route
      .queryParamMap
      .pipe(map(params => params.get('session_id') || 'None'));

    // 如果可用，捕获片段
    this.token = this.route
      .fragment
      .pipe(map(fragment => fragment || 'None'));
  }
}
```
  查询参数和片段可通过 Router 服务的 routerState 属性使用。和路由参数类似，全局查询参数和片段也是 Observable 对象。 在修改过的英雄管理组件中，你将借助 AsyncPipe 直接把 Observable 传给模板。
  按照下列步骤试验下：点击Crisis Admin按钮，它会带着我提供的 queryParamMap 和 fragment 跳转到登录页。 点击登录按钮，你就会被重定向到 Admin Dashboard 页。 注意，它仍然带着上一步提供的 queryParamMap 和 fragment。
  我可以用这些持久化信息来携带需要为每个页面都提供的信息，如认证令牌或会话的 ID 等。
	“查询参数”和“片段”也可以分别用 RouterLink 中的 preserveQueryParams 和 preserveFragment 保存。
## 九、异步路由
  完成上面的步骤以后，程序已经扩大了。在继续构建特征区的过程中，应用的尺寸将会变得更大。在某一个时间点，将会达到一个顶点，应用将会需要过多的时间来加载。
  要想解决这个问题，可以通过引进异步路由，可以获得在请求时才惰性加载特性模块的能力。惰性加载有多个优点：
  - 可以只在用户请求时才加载某些特性区
  - 对于那些只访问应用程序某些区域的用户，这样才能加快加载速度
  - 可以持续扩充多想加载特性区的功能，而不用增加初始加载的包体积
    目前完成了一部分，通过把应用组织成一些模块：AppModule、PersonsModule、AdminModule和CrisisCenterModule，已经有了可以用于实现惰性加载的候选者。有些模块必须在启动时加载，但其它的都可以而且应该惰性加载。比如AdminModule就只有少数已认证的用户才需要它，所以我应该只有在正确的人请求它时才加载。、
### 1.惰性加载路由配置
  把admin-routing.module.ts中的admin路径从admin改为空路径。Router支持空路径，可以使用它们来分组路由，而不用往URL中添加额外的路径片段。用户仍旧访问/admin，并且AdminComponent仍然作为用来包含子路由的路由组件。打开AppRoutingModule，并把一个新的admin路由添加到它的appRoutes数组中。
  给它的一个loadChildren属性（不是children属性），把它设置为AdminModule的地址。该地址是AdminModule的文件路径（相对于app目录的），，加上一个#分隔符，再加上导出模块的类名AdminModule：
```typescript
{
  path: 'admin',
  loadChildren: 'app/admin/admin.module#AdminModule',
},
```
  当路由器导航到这个路由时，它会用loadChildren字符串来动态加载AdminModule，然后把AdminModule添加到当前的路由配置中，最后，它把所请求的路由加载到目标admin组件中。
  惰性加载和重新配置工作只会发生一次，也就是在该路由首次被请求时，在后续的请求中，该模块和路由都是立即可用的。
	Angular提供一个内置模块加载器，支持SystemJS来异步加载模块，如果我使用其它捆绑工具比如Webpack，则使用Webpack的机制来异步加载模块。
  最后一步是把管理特性区从主应用中完全分离开。根模块AppModule既不能加载也不能引用AdminModule及其文件。
  在app.module.ts中，从顶部移除AdminModule的导入语句，并且从Angular模块的imports数组中移除AdminModule。
### 2.CanLoad守卫：保护对特性模块的未授权加载
  我已经使用了CanActivate保护AdminModule了，它会阻止未授权用户访问管理特性区。如果用户未登录，它就会跳转到登录页。但是路由器仍然会加载AdminModule，即使用户无法访问它的任何一个组件。理想的方式是只有在用户已登录的情况下才会加载AdminModule。
  添加一个CanLoad守卫，它只在用户已登录并且尝试访问管理特性区的时候，才加载一次AdminModule。现有的AuthGuard的checkLogin（）方法中已经有了支持CanLoad守卫的基础 逻辑。打开auth-guard.service.ts，从@angular/router中导入CanLoad接口，把它添加到AuthGuard类的implements列表中，然后实现canLoad，代码如下：
```typescript
canLoad(route:Route): boolean{
    let url=`${route.path}`
    return this.checkLogin(url)
}
```
  路由器会把canLoad()方法的route参数设置为准备访问的目标URL。如果用户已经登录了，checkLogin()方法就会重定向到那个URL。现在把AuthGuard导入到AppRoutingModule中，并把AuthGuard添加到admin路由的canLoad数组中。完整的admin路由是这样的：
```typescript
{
  path: 'admin',
  loadChildren: 'app/admin/admin.module#AdminModule',
  canLoad: [AuthGuard]
},
```
### 3.预加载：特性区的后台加载
  现在看一下如何使用预加载技术异步加载模块。看起来应用一直都是这么做的，但其实并不是这样，AppModule在应用启动时就被加载了，它是立即加载的。而AdminModule只有当用户点击某个链接时才会加载，它是惰性加载的。预加载是介于两者之间的一种方式。看一下危机中心，用户第一眼不会看到它，默认情况下，人物管理才是第一视图。为了获得尽可能小的初始加载体积和最快的加载速度，应该对AppModule和PersonsModule进行立即加载。
  我可以惰性加载危机中心。但是可以肯定用户会在启动应用之后的几分钟内访问危机中心。理想情况下，应用启动时应该只加载AppModule和PersonsModule，然后几乎立即开始加载CrisisCenterModule，在用户浏览到危机中心之前，该模块应该已经加载完毕，可供访问了。
  这就是预加载。
#### 3.1 预加载的工作原理
  在每次成功的导航后，路由器会在自己的配置中查找尚未加载并且可以预加载的模块。是否加载某个模块，以及要加载哪些模块，取决于预加载策略。
  Router人内置了两种预加载策略：
  - 完全不预加载，这是默认值。惰性加载的特性区仍然会按需加载
  - 预加载所有惰性加载的特性区
    默认情况下，路由器或者完全不预加载或者预加载每个惰性加载模块。路由器还支持自定义加载策略，以便完全控制要预加载哪些模块以及何时加载。
#### 3.2 惰性加载危机中心
  修改路由配置，来惰性加载CrisisCenterModule。修改的步骤和配置惰性加载AdminModule时一样：
  1. 把CrisisCenterRoutingModule中的路径从crisis-center改为空字符串
  2. 往AppRoutingModule中添加一个crisis-center路由
  3. 设置loadChildren字符串来加载CrisisCenterModule
  4. 从aoo.module.ts中移除所有对CrisisCenterModule的引用
    下面是打开预加载之前的模块修改版：
    **app.module.ts**
```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

import { Router } from '@angular/router';
import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { PersonsModule } from './persons/persons.module';
import { ComposeMessageComponent } from './compose-message.component';
import { LoginRoutingModule } from './login-routing.module';
import { LoginComponent } from './login.component';
import { PageNotFoundComponent } from './not-found.component';
import { DialogService } from './dialog.service';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    PersonsModule,
    LoginRoutingModule,
    AppRoutingModule,
    BrowserAnimationsModule
  ],
  declarations: [
    AppComponent,
    ComposeMessageComponent,
    LoginComponent,
    PageNotFoundComponent
  ],
  providers: [
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
  // 仅诊断：检查路由器配置
  constructor(router: Router) {
    console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
  }
}
```
  **app-routing.module.ts**
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes} from '@angular/router';
import { ComposeMessageComponent } from './compose-message.component';
import { PageNotFoundComponent } from './not-found.component';
import { CanDeactivateGuard } from './can-deactivate-guard.service';
import { AuthGuard } from './auth-guard.service';

const appRoutes: Routes = [
  {
    path: 'compose',
    component: ComposeMessageComponent,
    outlet: 'popup'
  },
  {
    path: 'admin',
    loadChildren: 'app/admin/admin.module#AdminModule',
    canLoad: [AuthGuard]
  },
  {
    path: 'crisis-center',
    loadChildren: 'app/crisis-center/crisis-center.module#CrisisCenterModule'
  },
  { path: '',   redirectTo: '/persons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
    )
  ],
  exports: [
    RouterModule
  ],
  providers: [
    CanDeactivateGuard
  ]
})
export class AppRoutingModule {}
```
  **crisis-center-routing.module.ts**
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { CrisisCenterHomeComponent } from './crisis-center-home.component';
import { CrisisListComponent } from './crisis-list.component';
import { CrisisCenterComponent } from './crisis-center.component';
import { CrisisDetailComponent } from './crisis-detail.component';
import { CanDeactivateGuard } from '../can-deactivate-guard.service';
import { CrisisDetailResolver }   from './crisis-detail-resolver.service';

const crisisCenterRoutes: Routes = [
  {
    path: '',
    component: CrisisCenterComponent,
    children: [
      {
        path: '',
        component: CrisisListComponent,
        children: [
          {
            path: ':id',
            component: CrisisDetailComponent,
            canDeactivate: [CanDeactivateGuard],
            resolve: {
              crisis: CrisisDetailResolver
            }
          },
          {
            path: '',
            component: CrisisCenterHomeComponent
          }
        ]
      }
    ]
  }
];

@NgModule({
  imports: [
    RouterModule.forChild(crisisCenterRoutes)
  ],
  exports: [
    RouterModule
  ],
  providers: [
    CrisisDetailResolver
  ]
})
export class CrisisCenterRoutingModule { }
```
  现在可以尝试一下，并确认在点击了 Crisis Center按钮之后加载了CrisisCenterModule。要为所有惰性加载模块启用预加载功能，请从Angular的路由模块导入PreloadAllModules。RouterModule.forRoot方法的第二个参数接受一个附加配置选项对象，preloadingStrategy就是其中之一。把PreloadAllModules添加到forRoot调用中：
```typescript
RouterModule.forRoot(
  appRoutes,
  {
    enableTracing: true, //仅供调试
    preloadingStrategy: PreloadAllModules
  }
)
```
  这会让Router预加载器立即加载所有惰性加载路由（带loadChildren属性的路由）。当访问http://localhost:4200 时，/persons路由立即随之启动，并且路由器在加载了PersonsModule之后立即开始加载CrisisCenterModule。然而，AdminModule没有预加载，有什么东西阻塞了它。
#### 3.4 CanLoad会阻塞预加载
  PreloadAllModules 策略不会加载被CanLoad守卫所保护的特性区。这是刻意设计的。
  几步之前刚刚给 AdminModule 中的路由添加了 CanLoad 守卫，以阻塞加载那个模块，直到用户认证结束。 CanLoad 守卫的优先级高于预加载策略。如果我要加载一个模块并且保护它防止未授权访问，请移除 canLoad 守卫，只单独依赖CanActivate守卫。
### 4.自定义预加载策略
  在大多数场景下，预加载每个惰性加载模块就很好了，但是有时候它缺并不是正确的选择，特别是在移动设备和低宽带连接下。可能出于用户的测量和其它商业和技术因素而选择只对某些特性模块进行预加载。
  使用自定义预加载策略，我可以控制路由器预加载哪些路由以及如何加载。在这里将添加一个自定义策略，它只预加载那些data.preload标志为true的路由。我可以往路由的data属性中添加任何东西。在AppRoutingModule的crisis-center路由中设置data.preload标志：
```typescript
{
  path: 'crisis-center',
  loadChildren: 'app/crisis-center/crisis-center.module#CrisisCenterModule',
  data: { preload: true }
},
```
  往项目中添加一个新的名叫selective-preloading-strategy.ts的文件，并在其中定义 一个服务类SelectivePreloadingStrategy，代码长这样：
```typescript
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable()
export class SelectivePreloadingStrategy implements PreloadingStrategy {
  preloadedModules: string[] = [];

  preload(route: Route, load: () => Observable<any>): Observable<any> {
    if (route.data && route.data['preload']) {
      // 向预加载模块数组添加路由路径
      this.preloadedModules.push(route.path);

      // 记住控制台的路由路径
      console.log('Preloaded: ' + route.path);

      return load();
    } else {
      return of(null);
    }
  }
}
```
  SelectivePreloadingStrategy实现了PreloadingStrategy，它只有一个方法preload。
  路由器会用两个参数调用preload方法：
  1. 要加载的路由
  2. 一个加载器（loader）函数，它能异步加载带路由的模块
    preload的实现必须返回一个Observable，如果该路由应该预加载，它就会返回调用加载器函数所返回的Observable。如果该路由不应该预加载，它就返回一个null值的Observable对象。
    在当前例子中，preload方法只有在路由的data.preload标识为真时才会加载该路由。它还有一个副作用，SelectivePreloadimgStrategy会把所选路由的path记录在它的公共数组preloadModules中。很快就会扩展AdminDashboardComponent来注入该服务，并且显示它的preloadModules数组。
    但是首先，要对AppRoutingModule做少量修改：
  1. 把 SelectivePreloadingStrategy 导入到 AppRoutingModule 中。
  2. 把 PreloadAllModules 策略替换成对 forRoot 的调用，并且传入这个 SelectivePreloadingStrategy。
  3. 把 SelectivePreloadingStrategy 策略添加到 AppRoutingModule 的 providers 数组中，以便它可以注入到应用中的任何地方。
    现在编辑AdminDashboardComponent以显示这些预加载路由的日志
  1. 导入SelectivePreloadingStrategy
  2. 把它注入到仪表盘的构造函数中
  3. 修改模板来显示这个策略的preloadedModules数组
    当完成时，代码长这样：
    **admin-dashboard.componnent.ts**
```typescript
import { Component, OnInit }    from '@angular/core';
import { ActivatedRoute }       from '@angular/router';
import { Observable }           from 'rxjs';
import { map }                  from 'rxjs/operators';

import { SelectivePreloadingStrategy } from '../selective-preloading-strategy';


@Component({
  template:  `
    <p>Dashboard</p>

    <p>Session ID: {{ sessionId | async }}</p>
    <a id="anchor"></a>
    <p>Token: {{ token | async }}</p>

    Preloaded Modules
    <ul>
      <li *ngFor="let module of modules">{{ module }}</li>
    </ul>
  `
})
export class AdminDashboardComponent implements OnInit {
  sessionId: Observable<string>;
  token: Observable<string>;
  modules: string[];

  constructor(
    private route: ActivatedRoute,
    private preloadStrategy: SelectivePreloadingStrategy
  ) {
    this.modules = preloadStrategy.preloadedModules;
  }

  ngOnInit() {
    // 如果可用，捕获会话ID
    this.sessionId = this.route
      .queryParamMap
      .pipe(map(params => params.get('session_id') || 'None'));

    // 如果可用，捕获片段
    this.token = this.route
      .fragment
      .pipe(map(fragment => fragment || 'None'));
  }
}
```
  一旦应用加载完了初始路由，CrisisCenterModule也被预加载了。通过Admin特性区中的记录就可以验证它，Preloaded Modules中没有列出crisis-center，它也被记录到了浏览器的控制台
## 十、使用重定向迁移URL
  现在已经设置好了路由，并且用命令式和声明式的方式导航到了很多不同的路由。但是任何应用的需求都会随着时间而改变。我把链接/persons和person/:id指向了PersonListComponent和PersonDetailComponent组件。如果有这样一个需求，要把链接persons变成superpersons，我还是想要以前的URL能正常导航。但是并不想在应用中找到并修改每一个链接，这时候，重定向就可以省去这些琐碎的重构工作。
### 1.把/persons修改为/superpersons
  先取得Person路由，并把它们迁移到新的URL。Router（路由器）会在开始导航之前现在配置中检查所有重定向语句，以便将来按需触发重定向，要支持这种修改，就要在persons-routing.module文件中把老的路由重定向到新的路由：
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { PersonListComponent } from './person-list.component';
import { PersonDetailComponent }  from './person-detail.component';

const personsRoutes: Routes = [
  { path: 'persons', redirectTo: '/superpersons' },
  { path: 'person/:id', redirectTo: '/superperson/:id' },
  { path: 'superpersons',  component: PersonListComponent },
  { path: 'superperson/:id', component: PersonDetailComponent }
];

@NgModule({
  imports: [
    RouterModule.forChild(personsRoutes)
  ],
  exports: [
    RouterModule
  ]
})
export class PersonRoutingModule { }
```
  注意，这里有两种类型的重定向。第一种是不带参数的从/persons重定向到/superpersons。这是一种非常直观的重定向。第二种是从/person/:id重定向到/superperson/:id，它还要包含一个：id路由参数，路由器重定向时使用强大的撇皮模式匹配功能，这样，路由器就会检查URL，并且把path中带的路由参数替换成相应的目标形式。以前，我导航形式如/person/01的URL时，带了一个路由参数id，它的值是01
	在重定向的时候，路由还支持查询参数和fragment
	- 当使用就绝对地址重定向时，路由器会将使用路由配置的redirectTo属性中规定的查询参数和片段
	- 当使用相对地址重定向时，路由器将会使用源地址中的查询参数和片段
  在修改app-routing.module.ts之前，要先考虑一条重要的规则。目前我把空路径路由重定向到了/persons，它又被重定向到了/superpersons，这样不行，从设计上就不不行，因为路由器在每一层的路由配置中只会处理一次重定向。这样可以防止无限循环的重定向。
  所以我要在app-routing.module.ts中修改空路径路由，让它重定向到/superpersons
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { ComposeMessageComponent }  from './compose-message.component';
import { PageNotFoundComponent } from './not-found.component';

import { CanDeactivateGuard } from './can-deactivate-guard.service';
import { AuthGuard } from './auth-guard.service';
import { SelectivePreloadingStrategy } from './selective-preloading-strategy';

const appRoutes: Routes = [
  {
    path: 'compose',
    component: ComposeMessageComponent,
    outlet: 'popup'
  },
  {
    path: 'admin',
    loadChildren: 'app/admin/admin.module#AdminModule',
    canLoad: [AuthGuard]
  },
  {
    path: 'crisis-center',
    loadChildren: 'app/crisis-center/crisis-center.module#CrisisCenterModule',
    data: { preload: true }
  },
  { path: '',   redirectTo: '/superpersons', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      {
        enableTracing: true, //仅供调试
        preloadingStrategy: SelectivePreloadingStrategy,

      }
    )
  ],
  exports: [
    RouterModule
  ],
  providers: [
    CanDeactivateGuard,
    SelectivePreloadingStrategy
  ]
})
export class AppRoutingModule { }
```
  由于RouterLink指令没有关联到路由配置，所以需要修改相关的路由链接，以便在新的路由激活时，它们也能保持激活状态。要修改app.componnent.ts模板中的/persons路由链接
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h1 class="title">Angular Router</h1>
    <nav>
      <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
      <a routerLink="/superpersons" routerLinkActive="active">Persons</a>
      <a routerLink="/admin" routerLinkActive="active">Admin</a>
      <a routerLink="/login" routerLinkActive="active">Login</a>
      <a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
    </nav>
    <router-outlet></router-outlet>
    <router-outlet name="popup"></router-outlet>
  `
})
export class AppComponent {
}
```
  当这些重定向设置好之后，所有以前的路由都指向了它们的新目标，并且每个URL也仍然能正常工作。
## 十一、审查路由配置
  本应用中，大量的精力被投入在一系列路由模块文件里配置路由器上，并且小心的以合适的顺序列出它们。但是这些路由是否真的如同预想那样执行了，路由器的真实配置是怎样的。通过注入Router并检查它的config属性，可以随时审查路由器的当前配置。例如，把AppModule修改为这样，并在浏览器的控制台窗口中查看最终的路由配置：
```typescript
import { Router } from '@angular/router';

export class AppModule {
  // 仅诊断：检查路由器配置
  constructor(router: Router) {
    console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
  }
}
```
## 十二、附录
### 1.附录：链接参数数组
  链接参数数组保存路由导航时所需的成分：
  - 指向目标组件的那个路由的路由（path）
  - 必备路由参数和可选路由参数，它们将进入该路由的URL
    我可以把RouterLink指令绑定到一个数组，就像这样：
```html
<a [routerLink]="['/persons]">Persons</a>
```
  在指定路由参数时，写过一个双元素的数组，就像这样：
```html
<a [routerLink]="['/person', person.id]">
  <span class="badge">{{ person.id }}</span>{{ person.name }}
</a>
```
  我可以在对象中提供可选的路由参数，就像这样：
```html
<a [routerLink]="['/crisis-center', { foo: 'foo' }]">Crisis Center</a>
```
  这三个例子涵盖了我在单级路由的应用中所需的一切，在我添加一个像危机中心一样的子路由时，可以创建新链接数组。之前曾为危机中心指定过一个默认的子路由，以便能使这种简单的RouterLink：
```html
<a [routerLink]="['/crisis-center']">Crisis Center</a>
```
  分解一下：
  - 数组中的第一个条目标记出了父路由(/crisis-center)
  - 这个父路由没有参数，因此这步已经完成了
  - 没有默认的子路由，所以需要选取一个
  - 若是决定跳转到CrisisListComponent，它的路由路径是 '/'，但是不需要显示添加它
  - 最后 ['/crisis-center']
    更进一步，这次要构建一个从根组件往下导航到 巨龙危机 时的链接参数数组：
```html
<a [routerLink]="['/crisis-center', 1]">Dragon Crisis</a>
```
  - 数组中的第一个条目标记出了父路由(/crisis-center)
  - 这个父路由没有参数，因此这步已经完成了
  - 数组中的第二个条目('/:id')用来标记出到指定危机的详情页的子路由
  - 详细的子路由需要一个id路由参数
  - 我把 巨龙危机的id添加为该数组中的第二个条目
  - 最终生成的路径 /crisis-center/1
    只要想，也可以用危机中心路由单独定义AppComponent的模板：
```typescript
template: `
  <h1 class="title">Angular Router</h1>
  <nav>
    <a [routerLink]="['/crisis-center']">Crisis Center</a>
    <a [routerLink]="['/crisis-center/1', { foo: 'foo' }]">Dragon Crisis</a>
    <a [routerLink]="['/crisis-center/2']">Shark Crisis</a>
  </nav>
  <router-outlet></router-outlet>
`
```
  とにかく，我可以用一级、两级或多级路由来写应用程序。链接参数数组提供了用来表示任意深度路由的链接参数数组以及任意合法的路由参数徐柳、必须的路由器参数以及可选的路由参数对象
### 2.附录：LocationStrategy以及浏览器URL样式
  当路由器导航到一个新的组件视图时，它会用该视图的URL来更新浏览器的当前地址以及历史。严格来说，这个URL其实是本地的，浏览器不会把该URL发给服务器，并且不会重新加载此页面。
  现在HTML5浏览器支持history.pushStateAPI，这是一项可以改变浏览器的当前地址和历史，却又不会触发服务器端页面请求的技术。路由器可以合成一个  自然的  URL，它看起来和那些需要进行页面加载的URL没什么区别。
  下面是危机中心的URL的 HTML5 pushState 风格下的样子：
```typescript
localhost:4200/crisis-center/
```
  老旧的浏览器在当前地址的URL变化时总会往服务器发送页面请求，唯一的例外规则是：当这些变化位于 # （被称为hash）后面时不会发送。通过把应用内的路由URL拼接在 # 之后，路由器可以获得这条 例外规则 带来的优点，下面是到 危机中心 路由的 hash URL：
```typescript
lcoalhost:4200/src/#/crisis-cennter/
```
  路由器通过两种LocationStrategy提供商来支持所有这些风格：
  1. PathLocationStrategy - 默认的策略，支持 HTML5 pushState风格
  2. HashLocationStrategy - 支持 hash URL 风格
    RouterModule.forRoot函数把LocationStrategy设置成了PathLocationStrategy，使其成为了默认策略。可以在启动过程中改写它，来切换到HashLocationStrategy风格。
#### 2.1 哪种策略更好
  策略是必须选择的，并且在项目的早期就得选好。一旦该应用进入了生产阶段，要改起来就难了，因为外面已经有了大量对应用URL的引用。
  几乎所有的Angular项目都会使用默认的HTML5风格。它生成的URL更易于被用户理解，它也为将来做服务端渲染预留了空间。在服务器端渲染指定的页面，是一项可以在该应用首次加载时大幅提升响应速度的技术。那些原本需要十秒甚至更长时间加载的应用，可以预先在服务端渲染好，并在少于一秒的时间内完整呈现在用户的设备上。只有当应用的 URL 看起来像是标准的 Web URL，中间没有 hash（#）时，这个选项才能生效。
#### 2.2 HTML5 URL与<base href>
  由于路由器默认使用“HTML 5 pushState”风格，所以必须用一个base href来配置该策略（Strategy）。
  配置该策略的首选方式是往 index.html 的 <head> 中添加一个<base href> element标签。
```html
<base href="/">
```
  如果没有此标签，当通过“深链接”进入该应用时，浏览器就不能加载资源（图片、CSS、脚本）。如果有人把应用的链接粘贴进浏览器的地址栏或从邮件中点击应用的链接时，这种问题就发生。有些开发人员可能无法添加 <base> 元素，这可能是因为它们没有访问 <head> 或 index.html 的权限。
  它们仍然可以使用 HTML 5 格式的 URL，但要采取两个步骤进行补救：
  - 用适当的APP_BASE_HREF值提供（provide）路由器。
  - 对所有 Web 资源使用绝对地址：CSS、图片、脚本、模板 HTML。
#### 2.3 HashLocationStrategy策略
  可以在根模块的RouterModule.forRoot的第二个参数中传入一个带有useHash:true的对象，以回到HashLocationStrategy的传统方式：
```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { Routes, RouterModule } from '@angular/router';
import { AppComponent } from './app.component';
import { PageNotFoundComponent } from './not-found.component';
const routes: Routes = [
];
@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/
  ],
  declarations: [
    AppComponent,
    PageNotFoundComponent
  ],
  providers: [
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```










