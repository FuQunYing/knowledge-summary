## 神策数据

###### 他们提供的SDK是随意使用的，前端打通之后，可以选择传到他们给的的数据接收地址上，但是如果你不购买他们的产品账号，是没有办法查看的；如果想要使用产品分析，也需要根据具体需求付费之类的，分析会给用户打标签、分群，利于后续产品运营等；需要联系他们的技术员/售前咨询，来确定需求和购买产品。

###### 或者只使用它们的api，数据接收到自己家的服务器上，只能查看数据，可视化可以自己写一套看板出来。

###### 对比百度数据来说，百度统计提供了免费的数据看板，页面数据pv，uv，用户来源等都可以直接查看。分析产品也是单独购买的


- User Profile 用户配置
- track 跟踪
- properties 属性
- distinct_id "独特的"，对用户的标识
- referer 引用，引用页，推荐人，推荐页

### 1.接入前
- 用户标识及关联
- 确定待接入产品的关联方案（需求考察）
- 采集方案设计 - 埋点需求文档 - 业务侧产品经理在输出“产品需求文档”时，同步输出
- 结合场景设计事件


### 2.基础知识

- 核心依据：使用**事件模型（Event模型）**来描述用户在产品上的各种行为
- 事件模型包括事件（Event）和用户（User）两个核心实体，同时配合物品（Item）实体可以做各种维度分析
- 神策分析提供了接口，上传和修改这两类相应的数据
- 有PV统计（加code就行）
```json
{
	"distinct_id": "2b0a6f51a3cd6775",
	"time": 1434556935000,
	"type": "track",
	"anonymous_id": "2b0a6f51a3cd6775",
	"event": "PageView",
	"properties": { 
		"$ip" : "180.79.35.65",
		"user_agent" : "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.）",
		"page_name" : "网站首页",
		"url" : "www.demo.com",
		"referer" : "www.referer.com"
	} 
}
```

#### 2.1.Event实体

- Event描述了一个用户在某个时间点、某个地方，以某种方式完成了某个具体的事情，包含的关键因素：Who、When、Where、How、What

```json
$app_version：应用版本
$city： 城市
$manufacturer： 设备制造商，字符串类型，如"Apple"
$model： 设备型号，字符串类型，如"iphone6"
$os： 操作系统，字符串类型，如"iOS"
$os_version： 操作系统版本，字符串类型，如"8.1.1"
$screen_height： 屏幕高度，数字类型，如1920
$screen_width： 屏幕宽度，数字类型，如1080
$wifi： 是否 WIFI，BOOL类型，如true
// 根据需求添加或减少字段
// 比如我在京东点进去了一个商品详情页，用户就是我，时间点就是进入页面时的时间戳，地点就是当时我的手机定位，How：概念比较广，包括我使用了啥设备，使用了啥浏览器/App（版本），操作系统的版本，如果是在浏览器打开的，那进入的渠道是什么，跳过来的referer是啥....what就去描述我这个事件的具体内容了
```

#### 2.2.使用原则

- 梳理自己的数据使用需求，并据此做好Event的划分和字段设计
- 推荐后端记录Event：很多行为前端没有提供相应的功能，拿不到对应的数据；针对App来说，后端修改程序更加方便，APP端记录数据的话，每次修改都要等APp发版和用户更新；App 端收集数据会有丢失的风险，并且上传数据也不及时。App 端为了避免浪费用户的流量，一般情况下，都是将多条数据打包，并且等待网络状况良好以及应用处于前台时才压缩上传，因此，自然会造成上传数据不及时，很有可能某一天的数据会等待好几天才传到服务器端，这自然会导致每天的指标都计算有偏差。同时，由于 App 端可以缓存的内容有限，用户设备的网络连接等问题，App 端收集的数据目前也没有太好的手段保证 100% 不丢失。**所以，除非某个行为只在前端发生，对后端没有任何请求，否则，建议永远只在后端收集数据**
- 划分原则：为了节约使用成本，从需求触发，记录那些只会分析到的Event；Event数量不应过多，对于一个典型的用户产品，数量不超过20为宜；Event不局限于用户在App、Web界面等前端的操作和使用，一些电话投诉、线下接收服务、线下商家消费，如果能获取到相应数据，也可以作为相应的Event
- 字段设计原则：先根据需求梳理分析指标和维度，然后再倒推需要每个Event记录的字段；Cookie、后端返回内容之类的，没必要记录收集；尽量使用预置字段；某个Event字段设计一旦确定，则不要再修改它的类型和取值含义。

#### 2.3.User实体

- 每个User对应一个真实用户，distinct_id进行标识，描述用户的长期属性；一般记录User Profile的场所，是用户进行注册、完善个人资料、修改个人资料等有限场合；应收集字段取决于产品形态及分析需求
- 字段记录在Profile还是Event：基本原则就是，Profile 记录的是用户特征的属性，例如：出生地、性别、注册地、首次广告来源类型等。而记录在 Event 的字段，记录的是事件发生时的特征，字段的取值具有场景性，例如 省份、城市 、设备型号、是否登录状态等。

#### 2.4.Item实体

- Event-User模型中，被设计为不可变的，实际应用中是多变的，所以通过Item进行补充
- 典型场景是用作神策分析的维度表 - 详细需阅读高级功能部分的文档

### 3.数据格式

- 不同端的SDK不同，但是内部实现上都使用统一的数据格式。
- 一些既定的数据格式 - - 见文档

#### 3.1数据整体格式
- track - 记录一个Event和关联的properties
- track_signup - ‘original_id’’

#### 3.2Profile相关操作
- profile_set - 设置一个用户的Profile，覆盖
- profile_set_once - 不覆盖
- profile_increment - 增减NUMBER类型的Profile值
- profile_delete - 删除一个用户整个的Profile
- profile_append - 添加一个或多个值，不去重
- profile_unset - 将某个用户的某些属性值设置为空

#### 3.3Item相关操作
- item_set - 直接设置一个item，覆盖
- item_delete - 删除整个item

### 4.属性数据类型

- js SDK 采集不到$app_version、$wifi、$carrier(运营商名称)、$network_type、$utm_matching_type(渠道追踪匹配模式)

### 5.导入数据的限制

#### 5.1一般限制
- 变量名不能以数字开头，只包含大小写字母、数字、下划线和$
- 变量名不能与已经存在的虚拟事件、虚拟属性的变量名重复
- 系统要求变量名完全一致，包括大小写
- type字段的取值只能是上面说的那几个，大小写也要一致
- properties字段必须存在，值可以为空（{}）
- 事件time字段允许的范围是固定的
- 自定义的变量名避开保留的属性名

#### 5.2事件时间限制
- 使用客户端SDK导入数据，服务端默认只接收事件发生时间在接收时间向前10天和未来向后1小时内的数据
- 使用后端语言SDK，默认2年内和向后1小时

#### 5.3显示名的相关限制
- 方便管理，除了变量名，还有显示名
- 保证与属性名一一对应

#### 5.4同名属性同类型
- 对Event属性，一个属性名，只能有一种类型
- Profile属性也是
- 对于一个属性名，在Event和Profile中可以具有不同的类型

#### 5.5属性长度有限制

#### 5.6属性数有上限
- 建议值300以内，硬上限2000

#### 5.7保留字段 - 看文档

### 6.标识用户
- 合适的用户标识可以提高用户行为分析的准确性

#### 6.1基本概念
- 神策分析使用神策ID来对每个产品的用户进行唯一的标识
- 典型的distinct_id有两种，设备ID、登录ID

#### 6.2三种方案 - 不兼容
- 只使用设备ID
	- 适合没有用户注册体系，或者极少数用户会进行多设备登录的产品，如工具类产品，搜索引擎
	- 直接使用客户端SDK产生的设备ID作为distinct_id即可，也可以直接调用identify作为接口来传入自定义的设备ID
	- 不管用户是谁，设备不变，神策ID不变
- 关联设备ID和登录ID（一对一）
	- 需要贯通一个用户在一个设备上注册前后的行为；需要贯通一个注册用户在不同设备上登录之后的行为
	- 客户端接入，使用js的SDK进行埋点，具体调用流程
		- 在SDK初始化完成之后，神策的SDK会自动生成一个设备ID作为用户标识
		- 用户注册成功、登录成功、初始化SDK的时候，客户端主动调用login接口
		- 在用户注销的时候，有几种选择
			- 不做任何操作，相当于继续使用之前的用户标识来进行追踪 - 选这个
			- 主动调用logout()方法，清空登录ID，重新使用设备ID作为用户标识
			- js还可以调用logout(true)，不仅清空登录ID，还初始化设备ID
	- 前端获取前端缓存中ID的方法：sensors.quick('getAnonymouseID');返回匿名ID
- 关联设备ID和登录ID（多对一）
	- 一个用户在多设备下的行为被贯通
	- 实施方法与方案二相同

### 7.新增用户及首日首次标记

- ** 不要再线上页面直接切换不同项目的数据接收地址，会导致首日首次，id关联异常**
- 新用户的标记在客户端完成，前端事件公共属性，是否首日访问($is_first_day)
	- web端实现逻辑：用户第一次访问埋入神策SDK页面的当天（第一天），js SDK会在网页的cookie中设置一个首日访问的标记，并在设置第一天24点之前，该标记记为首日为true，第一天触发的网页端所有事件中，$is_first_day=true。第一天之后，标记为首日为false，$is_first_day=false
	- 小程序存在Storage里
	- APP存在本地缓存
- 首次访问时间($first_visit_time)
	- web端、小程序端：集成神策JS、MiniProgram SDK之后，设置autotrack开启全埋点，SDK会默认在用户第一次浏览页面/启动小程序时，调用profile_set_once接口给用户设置首次访问时间属性



























