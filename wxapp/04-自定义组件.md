## 四、自定义组件
从小程序基础库版本1.6.3开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本1.6.3或更高。

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。


> **自定义组件的创建：**

类似于页面，一个自定义组件由json wxml wxss js4个文件组成。要编写一个自定义组件，首先需要在json文件中进行自定义组件声明（将component字段设为true）：
```json
{
    "component":true
}
```
同时，还要在wxml文件中编写组件模板，在wxss文件中加入组件样式，它们的写法与页面写法类似。
```html
<!-- 这是自定义组件的内部WXML结构 -->
<view class="inner">
  {{innerText}}
</view>
<slot></slot>
```
```css
/* 这里的样式只应用于这个自定义组件 */
.inner {
  color: red;
}
```
**注意：**
在组件wxss中不应使用ID选择器、属性选择器和签名选择器

在自定义组件的js文件中，需要使用Component()来注册组件，并提供组价的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件wxml的渲染，其中属性值是可由组件外部传入的。
```javascript
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```
> **自定义组件的使用**

使用已注册的自定义组件前，首先要在页面的json文件中进行引用声明，此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：
```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```
这样，在页面的wxml中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。
```html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
```
自定义组件的wxml节点结构在与数据结合之后，将被插入到引用位置内。

**注意：为页面添加usingComponents 会使得页面的逻辑发生一些细微变化（具体而言，页面会具有一些组件的特征）。如果页面比较复杂，需要测试一下页面逻辑是否有变化。**

**Tips：**

  - 对于基础库的1.5.x版本， 1.5.7 也有部分自定义组件支持。
  - 因为WXML节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
  - 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。
  - 自定义组件和使用自定义组件的页面所在项目根目录名不能以“wx-”为前缀，否则会报错。
  - 旧版本的基础库不支持自定义组件，此时，引用自定义组件的节点会变为默认的空节点。
### 1.组件模板和样式
  类似于页面，自定义组件拥有自己的wxml模板和wxss样式
#### 1.1 组件模板
  组件模板的写法与页面模板相同，组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。在组件模板中可以提供一个\<slot>节点，用于承载组件引用时提供的子节点。
```html
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点</view>
  <slot></slot>
</view>

<!-- 引用组件的页面模版 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```
  注意在模板中引用到的自定义组件及其对应的节点名需要在json文件中显式定义，否则会被当做一个无意义的节点，除此以外，节点名也可以被声明为抽象节点。
#### 1.2 模板数据绑定
  与普通的wxml模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。
```html
<!-- 引用组件的页面模版 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
<!--  组件的属性propA和propB将收到页面传递的数据。页面可以通过setData来改变绑定的数据字段。 -->
```

  **注意：**
  这样的数据绑定只能传递JSON兼容数据。自基础库版本2.0.9开始，还可以在数据中包含函数（但这些函数不能在wxml中直接调用，只能传递给子组件）
#### 1.3 组件wxml的slot
  在组件的wxml中可以包含slot节点，用于承载组件使用者提供的wxml结构。
  默认情况下，一个组件的wxml中只能有一个slot，需要使用多个slot时，可以在组件js中声明启用。
```javascript
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```
  此时，可以在这个组件的wxml中使用多个slot，以不同的name来区分。
```html
<!-- 组件模板 -->
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>


<!-- 使用时，用 slot 属性来将节点插入到不同的slot上。 -->

<!-- 引用组件的页面模版 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```
#### 1.4 组件样式
  组件对应wxss文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意：
  - 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。
  - 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
  - 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
  - 继承样式，如 font 、 color ，会从组件外继承到组件内。
  - 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效。
```css
#a{}/*在组组件中不能使用*/
[a]{}/*在组组件中不能使用*/
button{}/*在组组件中不能使用*/
.a > .b {}/*除非.a是view组件节点，否则不一定会生效*/
/*除此以外，组件可以指定它所在节点的默认样式，使用:host选择器*/
/*组件custom-component.wxss*/
:host{
  color:yellow
}
```
```html
<!-- 页面的WXML -->
<custom-component>这段文本是黄色的</custom-component>
```
#### 1.5 外部样式类
  有时，组件希望接受外部传入的样式类（类似于view组件的hover-class属性）。此时可以在Component中用externalClasses定义段 定义若干个外部样式类。这个特性从小程序基础库版本1.9.90开始支持。
  **注意：**
  在同一个节点上使用普通样式类和外部样式类时，两个类的优先级时未定义的，因此最好避免这种情况：
```javascript
/* 组件 custom-component.js */
Component({
  externalClasses: ['my-class']
})
```
```html
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
```
#### 1.6 全局样式类
  使用外部样式类可以让组件使用指定的组件外样式类，如果 希望组件外样式类能够完全影响组件内部，可以将组件构造器中的options.addGlobalClass字段置为true。这个特性从小程序基础库版本 2.2.3 开始支持。

> 当开放了全局样式类，存在外部样式污染组件样式的风险，请谨慎选择。

**代码示例：**
```javascript
 //组件custom-component.js
 Component({
   options:{
     addGlobalClass:true
   }
 })
```
```html
<!-- 组件custom-component.wxml -->
<text class="red-text">这段文本由组件外的class决定</text>
```
```css
/*组件外的样式定义*/
.red-text{color:#f00}
```
### 2.Component构造器
#### 2.1 定义段与示例方法
  Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等

定义段 | 类型 | 是否必填 | 描述
- | - | - | - 
properties | Object Map | 否 | 组件的对外属性，是属性名到属性设置的映射表，属性设置可包含三个字段，type表示属性类型、value表示属性初始值、observer表示属性值被更改时的响应函数。
data | Object | 否 | 组件的内部数据，和properties一同用于组件的模板渲染
methods | Object | 否 | 组件的方法，包括事件响应函数和任意的自定义方法
behavior | String Array | 否 | 类似于mixins和traits的组件间代码复用机制
created | Function | 否 | 组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用setData
attached | Function | 否 | 组件生命周期函数，在组件实例进入页面节点树时执行
ready | Function | 否 | 组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用SelectorQuery）
moved | Function | 否 | 组件生命周期函数，在组件实例被移动到节点树另一位置时执行
detached | Function | 否 | 组件生命周期函数，在组件实例被页面节点树移除时执行
relations | Object | 否 | 组件间关系定义
externalClasses	 | String Array | 	否	 | 组件接受的外部样式类
options	 | Object Map |	否 |	一些选项（文档中介绍相关特性时会涉及具体的选项设置，这里暂不列举）
lifetimes |	Object |	否	| 组件生命周期声明对象，组件的生命周期：created、attached、ready、moved、detached将收归到lifetimes字段内进行声明，原有声明方式仍旧有效，如同时存在两种声明方式，则lifetimes字段内声明方式优先级最高
pageLifetimes |	Object |	否 |	组件所在页面的生命周期声明对象，目前仅支持页面的show和hide两个生命周期
definitionFilter |	Function |	否	| 定义段过滤器，用于自定义组件扩展，参见 自定义组件扩展

生命的组件实例可以在组件的方法、生命周期函数和属性observer中通过this访问。组件包含一些通用属性和方法：
